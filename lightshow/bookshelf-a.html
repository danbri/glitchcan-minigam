<!DOCTYPE html>
<html>
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Smart Bookshelf LED Controller (Final + Blab for All)</title>
  <style>
    /* Base page layout */
    body {
      margin: 0;
      padding: 1rem;
      background: #121212;
      color: white;
      font-family: -apple-system, system-ui, sans-serif;
      -webkit-font-smoothing: antialiased;
    }

    /* LED visualization container */
    .bookshelf {
      width: 100%;
      aspect-ratio: 16/9;
      position: relative;
      /* Fallback for browsers without aspect-ratio */
      height: 0;
      padding-bottom: 56.25%;
      background: #4a3925;
      border: 20px solid #654321;
      border-radius: 12px;
      overflow: hidden;
      margin-bottom: 10px;
    }
    @supports (aspect-ratio: 16/9) {
      .bookshelf {
        height: auto;
        padding-bottom: 0;
      }
    }

    .led-strip {
      position: absolute;
      top: 0;
      left: 10px;
      right: 10px;
      height: 25px;
      background: rgba(0,0,0,0.5);
      border-radius: 12px;
      display: flex;
      align-items: center;
      padding: 2px;
      gap: 2px;
      z-index: 2;
    }

    .led {
      flex: 1;
      height: 100%;
      position: relative;
    }
    .led-core {
      position: absolute;
      inset: 0;
      border-radius: 4px;
    }
    .led-glow {
      position: absolute;
      inset: -5px;
      border-radius: 8px;
      filter: blur(4px);
      -webkit-filter: blur(4px);
      opacity: 0.8;
    }

    .ambient-glow {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 150px;
      background: radial-gradient(ellipse at top,
          rgba(255,255,255,0.3) 0%,
          transparent 70%);
      mix-blend-mode: screen;
      pointer-events: none;
    }

    /* Controls container */
    .controls {
      background: #1a1a1a;
      border-radius: 12px;
      padding: 15px;
      margin-bottom: 220px;
    }

    /* Tab nav */
    .tab-nav {
      display: flex;
      gap: 5px;
      margin: -5px -5px 15px -5px;
      background: rgba(0,0,0,0.2);
      padding: 5px;
      border-radius: 8px;
      overflow-x: auto;
      scrollbar-width: none;
      -webkit-overflow-scrolling: touch;
    }
    .tab-nav::-webkit-scrollbar {
      display: none;
    }

    .tab-btn {
      flex: 1;
      min-width: max-content;
      padding: 12px 20px;
      border: none;
      background: rgba(255,255,255,0.05);
      color: white;
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      -webkit-tap-highlight-color: transparent;
      font-weight: 500;
    }
    .tab-btn.active {
      background: #2196F3;
    }

    /* Tab content */
    .tab-content > div {
      display: none;
    }
    .tab-content > div.active {
      display: block;
    }

    /* Pattern grid for pattern buttons */
    .pattern-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
      gap: 8px;
    }
    .pattern-grid button {
      padding: 12px;
      border: none;
      background: rgba(255,255,255,0.1);
      color: white;
      border-radius: 8px;
      cursor: pointer;
      transition: background 0.2s;
    }
    .pattern-grid button:hover {
      background: rgba(255,255,255,0.15);
    }

    /* Color controls */
    .color-controls {
      display: flex;
      gap: 15px;
      align-items: center;
    }
    input[type="color"] {
      width: 60px;
      height: 60px;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      -webkit-appearance: none;
      padding: 0;
    }
    input[type="color"]::-webkit-color-swatch-wrapper {
      padding: 0;
    }
    input[type="color"]::-webkit-color-swatch {
      border: none;
      border-radius: 8px;
    }

    input[type="range"] {
      flex: 1;
      height: 4px;
      -webkit-appearance: none;
      background: rgba(255,255,255,0.2);
      border-radius: 2px;
    }
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 20px;
      height: 20px;
      background: #2196F3;
      border: none;
      border-radius: 50%;
      cursor: pointer;
    }

    /* Debug panel at bottom */
    #debugPanel {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      height: 200px;
      background: rgba(0,0,0,0.95);
      color: #0f0;
      font-family: ui-monospace, monospace;
      padding: 10px;
      overflow-y: auto;
      z-index: 1000;
      font-size: 12px;
      line-height: 1.4;
      border-top: 1px solid rgba(255,255,255,0.1);
    }
    #debugPanel pre {
      margin: 0;
    }

    /* Expression UI (for "Expression" or any "Blab" pattern) */
    .expression-ui {
      margin: 10px 0;
      border: 1px solid rgba(255,255,255,0.2);
      padding: 10px;
      border-radius: 6px;
      display: none;
    }
    .expression-ui textarea {
      width: 100%;
      height: 70px;
      background: #222;
      color: #fff;
      border: 1px solid #444;
      border-radius: 4px;
      font-family: ui-monospace, monospace;
      resize: vertical;
      margin-bottom: 10px;
    }
    .expression-ui details {
      margin-top: 10px;
      background: #222;
      border-radius: 8px;
      padding: 6px;
    }
    .expression-ui summary {
      cursor: pointer;
      outline: none;
      font-weight: 600;
    }
    .expression-ui .slider-row {
      display: flex;
      align-items: center;
      gap: 5px;
      margin: 5px 0;
    }
    .expression-ui .slider-row label {
      width: 80px;
      font-size: 0.9em;
    }
    .expression-ui .slider-row input[type="range"] {
      flex: 1;
    }
    .expression-ui .speed-row {
      display: flex;
      align-items: center;
      gap: 10px;
    }
  </style>
</head>
<body>
  <!-- LED Visualization -->
  <div class="bookshelf">
    <div class="led-strip" id="ledStrip"></div>
    <div class="ambient-glow" id="ambientGlow"></div>
  </div>

  <!-- Tabs & Controls -->
  <div class="controls">
    <div class="tab-nav">
      <button class="tab-btn active" data-tab="patterns">Patterns</button>
      <button class="tab-btn" data-tab="colors">Colors</button>
      <button class="tab-btn" data-tab="debug">Debug</button>
    </div>

    <div class="tab-content">
      <!-- Patterns tab -->
      <div id="patterns" class="active">
        <div class="pattern-grid" id="patternGrid"></div>

        <!-- Expression UI shown if "Expression" or any "Blab" pattern is chosen -->
        <div class="expression-ui" id="expressionUI">
          <label style="font-weight:600;">Expression:</label>
          <textarea id="customExpression"></textarea>

          <div class="speed-row">
            <button id="updateExpressionBtn">Update</button>
            <label>Speed:</label>
            <input type="range" id="exprSpeedSlider" min="0.01" max="5" step="0.01" value="1">
            <span id="exprSpeedVal">1</span>
            <button id="exprResetTime">Reset Time</button>
          </div>

          <details>
            <summary>appargs (x,y,z,w)</summary>
            <div class="slider-row">
              <label>appargs.x</label>
              <input type="range" id="appargsX" min="0" max="1" step="0.01" value="0.5">
              <span id="appargsXVal">0.5</span>
            </div>
            <div class="slider-row">
              <label>appargs.y</label>
              <input type="range" id="appargsY" min="0" max="1" step="0.01" value="0.1">
              <span id="appargsYVal">0.1</span>
            </div>
            <div class="slider-row">
              <label>appargs.z</label>
              <input type="range" id="appargsZ" min="0" max="2" step="0.01" value="1">
              <span id="appargsZVal">1</span>
            </div>
            <div class="slider-row">
              <label>appargs.w</label>
              <input type="range" id="appargsW" min="0" max="2" step="0.01" value="1">
              <span id="appargsWVal">1</span>
            </div>
          </details>
        </div>
      </div>

      <!-- Color tab -->
      <div id="colors">
        <div class="color-controls">
          <input type="color" id="colorPicker" value="#ff0000">
          <input type="range" id="brightness" min="0" max="100" value="70">
        </div>
      </div>

      <!-- Debug tab -->
      <div id="debug">
        <div id="debugLog"></div>
      </div>
    </div>
  </div>

  <!-- Fixed debug panel -->
  <div id="debugPanel">
    <pre id="debugLog"></pre>
  </div>

  <!-- JSON config for patterns (adds “Blab” versions of all, plus “Expression”) -->
  <script id="controller-config" type="application/json">
  {
    "patterns": [
      { "label": "Pride",        "method": "pridePattern" },
      { "label": "Rainbow",      "method": "rainbowPattern" },
      { "label": "Sinelon",      "method": "sinelon" },
      { "label": "BPM",          "method": "bpm" },
      { "label": "Juggle",       "method": "juggle" },
      { "label": "Confetti",     "method": "confetti" },
      { "label": "Cylon",        "method": "cylonPattern" },
      { "label": "Solid",        "method": "solidColor" },

      { "label": "Pride Blab",   "method": "prideBlabPattern" },
      { "label": "Rainbow Blab", "method": "rainbowBlabPattern" },
      { "label": "Sinelon Blab", "method": "sinelonBlabPattern" },
      { "label": "BPM Blab",     "method": "bpmBlabPattern" },
      { "label": "Juggle Blab",  "method": "juggleBlabPattern" },
      { "label": "Confetti Blab","method": "confettiBlabPattern" },
      { "label": "Cylon Blab",   "method": "blabCylonPattern" },
      { "label": "Solid Blab",   "method": "solidBlabPattern" },

      { "label": "Expression",   "method": "customExpression" }
    ]
  }
  </script>

  <!-- math.js for custom expression logic -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.8.0/math.js"></script>
  <script>
    // Simple debug logger
    function debug(msg) {
      const log = document.getElementById('debugLog');
      const time = new Date().toLocaleTimeString();
      const entry = `[${time}] ${msg}\n`;
      log.textContent += entry;
      log.scrollTop = log.scrollHeight;
      console.log(entry);
    }

    // "vec3" helper for expressions
    const vec3 = function(r, g, b) {
      return math.matrix([r, g, b]);
    };
    vec3.mix = function(a, b, t) {
      return math.add(
        math.multiply(a, 1 - t),
        math.multiply(b, t)
      );
    };
    vec3.hsv = function(h, s, v) {
      h = ((h % 360) + 360) % 360;
      s = Math.max(0, Math.min(100, s)) / 100;
      v = Math.max(0, Math.min(100, v)) / 100;
      const c = v * s;
      const x = c * (1 - Math.abs(((h / 60) % 2) - 1));
      const m = v - c;
      let rgb;
      if (h < 60)  rgb = [c, x, 0];
      else if (h < 120) rgb = [x, c, 0];
      else if (h < 180) rgb = [0, c, x];
      else if (h < 240) rgb = [0, x, c];
      else if (h < 300) rgb = [x, 0, c];
      else rgb = [c, 0, x];
      return math.matrix([rgb[0] + m, rgb[1] + m, rgb[2] + m]);
    };
    vec3.rotate = function(v, angle) {
      const rgb = v.valueOf();
      const max = Math.max(...rgb);
      const min = Math.min(...rgb);
      const delta = max - min;
      let h;
      if (delta === 0) {
        h = 0;
      } else if (max === rgb[0]) {
        h = 60 * (((rgb[1] - rgb[2]) / delta) % 6);
      } else if (max === rgb[1]) {
        h = 60 * ((rgb[2] - rgb[0]) / delta + 2);
      } else {
        h = 60 * ((rgb[0] - rgb[1]) / delta + 4);
      }
      const s = (max === 0)? 0 : delta / max;
      const val = max;
      return vec3.hsv((h + angle + 360) % 360, s * 100, val * 100);
    };

    // Scope for expressions
    const exprScope = {
      sin: Math.sin,
      vec3,
      x: 0,       // LED position 0..1
      t: 0,       // time
      speed: 1,   // expression-based speed
      appargs: { x:0.5, y:0.1, z:1.0, w:1.0 }
    };

    class LEDStrip {
      constructor() {
        debug('Initializing LED strip');
        this.strip = document.getElementById('ledStrip');
        this.glow = document.getElementById('ambientGlow');
        this.leds = [];
        this.currentAnimation = null;
        this.createLEDs();

        // Basic color controls
        this.colorPicker = document.getElementById('colorPicker');
        this.brightness = document.getElementById('brightness');
        this.colorPicker.addEventListener('input', () => this.setColor());
        this.brightness.addEventListener('input', () => this.setColor());
        this.setColor();
      }

      createLEDs() {
        debug('Creating LED elements');
        for (let i = 0; i < 100; i++) {
          const led = document.createElement('div');
          led.className = 'led';
          led.innerHTML = `
            <div class="led-core"></div>
            <div class="led-glow"></div>
          `;
          this.strip.appendChild(led);
          this.leds.push({
            core: led.querySelector('.led-core'),
            glow: led.querySelector('.led-glow')
          });
        }
      }

      setColor() {
        const color = this.colorPicker.value;
        const brightnessVal = parseFloat(this.brightness.value) / 100;
        this.leds.forEach(led => {
          led.core.style.backgroundColor = color;
          led.glow.style.backgroundColor = color;
          led.core.style.opacity = brightnessVal;
          led.glow.style.opacity = brightnessVal * 0.8;
        });
        this.glow.style.opacity = brightnessVal * 0.5;
        this.glow.style.background = `
          radial-gradient(ellipse at top,
          ${color} 0%,
          transparent 70%)
        `;
      }

      // Cancel previous pattern animation
      cancelAnimation() {
        if (this.currentAnimation) {
          cancelAnimationFrame(this.currentAnimation);
          this.currentAnimation = null;
        }
      }

      // ======================
      // Original (Non-blab) Patterns
      // ======================
      pridePattern() {
        this.cancelAnimation();
        debug('Pride pattern: Rainbow wave');
        let offset = 0;
        const animate = () => {
          this.leds.forEach((led, i) => {
            const hue = (i + offset) % 360;
            const color = `hsl(${hue}, 100%, 50%)`;
            led.core.style.backgroundColor = color;
            led.glow.style.backgroundColor = color;
            led.core.style.opacity = 1;
            led.glow.style.opacity = 0.8;
          });
          offset = (offset + 2) % 360;
          this.currentAnimation = requestAnimationFrame(animate);
        };
        animate();
      }

      rainbowPattern() {
        this.cancelAnimation();
        debug('Rainbow pattern: Static spectrum');
        this.leds.forEach((led, i) => {
          const hue = (i * 360 / this.leds.length) % 360;
          const color = `hsl(${hue}, 100%, 50%)`;
          led.core.style.backgroundColor = color;
          led.glow.style.backgroundColor = color;
          led.core.style.opacity = 1;
          led.glow.style.opacity = 0.8;
        });
      }

      sinelon() {
        this.cancelAnimation();
        debug('Sinelon pattern: Moving dot with fade');
        let pos = 0;
        const animate = () => {
          this.leds.forEach(led => {
            const curr = parseFloat(led.core.style.opacity) || 0;
            const newVal = Math.max(0, curr - 0.05);
            led.core.style.opacity = newVal;
            led.glow.style.opacity = newVal * 0.8;
          });
          const theLED = this.leds[pos];
          theLED.core.style.backgroundColor = '#ff0000';
          theLED.glow.style.backgroundColor = '#ff0000';
          theLED.core.style.opacity = 1;
          theLED.glow.style.opacity = 0.8;

          pos = (pos + 1) % this.leds.length;
          this.currentAnimation = requestAnimationFrame(animate);
        };
        animate();
      }

      bpm() {
        this.cancelAnimation();
        debug('BPM pattern: Pulsing colors');
        const startTime = performance.now();
        const animate = () => {
          const time = performance.now() - startTime;
          const bpm = 62;
          this.leds.forEach((led, i) => {
            const hue = i * 2;
            const brightness = Math.sin(time * bpm * Math.PI / 30000 + i * 0.25) * 0.5 + 0.5;
            const color = `hsl(${hue}, 100%, 50%)`;
            led.core.style.backgroundColor = color;
            led.glow.style.backgroundColor = color;
            led.core.style.opacity = brightness;
            led.glow.style.opacity = brightness * 0.8;
          });
          this.currentAnimation = requestAnimationFrame(animate);
        };
        animate();
      }

      juggle() {
        this.cancelAnimation();
        debug('Juggle pattern: multiple bouncing points');
        const balls = [
          { pos: 0,  velocity: 3,  color: 'hsl(0,   100%, 50%)' },
          { pos: 30, velocity: 4,  color: 'hsl(80,  100%, 50%)' },
          { pos: 60, velocity: 5,  color: 'hsl(160, 100%, 50%)' }
        ];
        const animate = () => {
          this.leds.forEach(led => {
            const curr = parseFloat(led.core.style.opacity) || 0;
            const newVal = Math.max(0, curr - 0.05);
            led.core.style.opacity = newVal;
            led.glow.style.opacity = newVal * 0.8;
          });
          balls.forEach(ball => {
            ball.pos = (ball.pos + ball.velocity) % this.leds.length;
            const theLED = this.leds[Math.floor(ball.pos)];
            theLED.core.style.backgroundColor = ball.color;
            theLED.glow.style.backgroundColor = ball.color;
            theLED.core.style.opacity = 1;
            theLED.glow.style.opacity = 0.8;
          });
          this.currentAnimation = requestAnimationFrame(animate);
        };
        animate();
      }

      confetti() {
        this.cancelAnimation();
        debug('Confetti pattern: random flickers');
        const animate = () => {
          this.leds.forEach(led => {
            const curr = parseFloat(led.core.style.opacity) || 0;
            led.core.style.opacity = Math.max(0, curr - 0.02);
            led.glow.style.opacity = Math.max(0, (curr - 0.02) * 0.8);
          });
          for (let i=0; i<5; i++) {
            const idx = Math.floor(Math.random() * this.leds.length);
            const hue = Math.floor(Math.random() * 360);
            const color = `hsl(${hue}, 100%, 50%)`;
            this.leds[idx].core.style.backgroundColor = color;
            this.leds[idx].glow.style.backgroundColor = color;
            this.leds[idx].core.style.opacity = 1;
            this.leds[idx].glow.style.opacity = 0.8;
          }
          this.currentAnimation = requestAnimationFrame(animate);
        };
        animate();
      }

      cylonPattern() {
        this.cancelAnimation();
        debug('Cylon pattern: bouncing red eye');
        let pos = 0;
        let direction = 1;
        const animate = () => {
          this.leds.forEach((led, i) => {
            const distance = Math.abs(i - pos);
            const brightness = Math.max(0, 1 - distance / 5);
            led.core.style.backgroundColor = '#ff0000';
            led.glow.style.backgroundColor = '#ff0000';
            led.core.style.opacity = brightness;
            led.glow.style.opacity = brightness * 0.8;
          });
          pos += direction;
          if (pos >= this.leds.length - 1 || pos <= 0) {
            direction *= -1;
          }
          this.currentAnimation = requestAnimationFrame(animate);
        };
        animate();
      }

      solidColor() {
        this.cancelAnimation();
        debug('Solid color: using UI pickers');
        this.setColor();
      }

      // =================
      // BLAB versions
      // =================

      // Helper to run a built-in expression
      runBlabExpression(expr) {
        this.cancelAnimation();
        // Show expression UI
        const ui = document.getElementById('expressionUI');
        ui.style.display = 'block';
        // Put the built-in expr into the textarea
        document.getElementById('customExpression').value = expr.trim();

        try {
          this.exprCompiled = math.compile(expr.trim());
          debug('Blab expression compiled OK');
        } catch (err) {
          debug('Error compiling blab: ' + err.message);
          return;
        }
        // Reset time
        this.lastFrameTime = 0;
        exprScope.t = 0;
        exprScope.speed = parseFloat(document.getElementById('exprSpeedSlider').value) || 1;

        const animate = (timestamp) => {
          const dt = (timestamp - this.lastFrameTime) / 1000;
          this.lastFrameTime = timestamp;
          exprScope.t += dt;
          exprScope.speed = parseFloat(document.getElementById('exprSpeedSlider').value) || 1;

          this.leds.forEach((ledObj, i) => {
            exprScope.x = i / this.leds.length;
            try {
              const result = this.exprCompiled.evaluate(exprScope).valueOf();
              const maxVal = Math.max(...result);
              let scale = 1;
              if (maxVal <= 1) scale = 255;
              const r = Math.round(Math.min(255, Math.max(0, result[0]*scale)));
              const g = Math.round(Math.min(255, Math.max(0, result[1]*scale)));
              const b = Math.round(Math.min(255, Math.max(0, result[2]*scale)));
              const color = `rgb(${r},${g},${b})`;
              ledObj.core.style.backgroundColor = color;
              ledObj.glow.style.backgroundColor = color;
              ledObj.core.style.opacity = 1;
              ledObj.glow.style.opacity = 0.8;
            } catch (evalErr) {
              debug('Blab eval error: ' + evalErr.message);
            }
          });
          this.currentAnimation = requestAnimationFrame(animate);
        };
        animate(0);
      }

      // Pride Blab: approximate a rainbow wave
      prideBlabPattern() {
        debug('Pride Blab pattern');
        const expr = `
vec3.hsv(
  (x*360 + t*speed*120),
  100,
  100
)
        `;
        this.runBlabExpression(expr);
      }

      rainbowBlabPattern() {
        debug('Rainbow Blab pattern: static spectrum');
        const expr = `
vec3.hsv(
  x*360,
  100,
  100
)
        `;
        this.runBlabExpression(expr);
      }

      sinelonBlabPattern() {
        debug('Sinelon Blab pattern: single moving highlight (no fade mem)');
        // We do a bright red dot that moves. 2 * π cycle:
        const expr = `
let pos = 0.5 + 0.5*sin(t * speed * 6.283185);
vec3(
  max(0, 1 - abs(x - pos)*50),
  0,
  0
)
        `;
        this.runBlabExpression(expr);
      }

      bpmBlabPattern() {
        debug('BPM Blab pattern: wave brightness in multiple hues');
        // Quick approximation:
        const expr = `
let hue = x*360;
let amp = (sin(t * speed * 3.14159) + 1)/2;
vec3.hsv(
  hue,
  100,
  amp*100
)
        `;
        this.runBlabExpression(expr);
      }

      juggleBlabPattern() {
        debug('Juggle Blab pattern: sum of 3 sin waves, different hues');
        // We can't store fade over time, so do a simple additive color approach:
        const expr = `
let r = 0.5 + 0.5*sin(t*speed*6 + x*6);
let g = 0.5 + 0.5*sin(t*speed*4 + x*10);
let b = 0.5 + 0.5*sin(t*speed*5 + x*16);
vec3(r,g,b)
        `;
        this.runBlabExpression(expr);
      }

      confettiBlabPattern() {
        debug('Confetti Blab pattern: random-like flickers in expression? (approx with sin combos)');
        // There's no direct random in pure expression, so we do a trick with sin/cos:
        const expr = `
let flicker = sin((x*999 + t*speed*1000)) * sin((x*333 + t*speed*777));
vec3(
  max(0, flicker*1),
  max(0, -flicker*1),
  max(0, flicker*0.8)
)
        `;
        this.runBlabExpression(expr);
      }

      blabCylonPattern() {
        debug('Cylon Blab pattern');
        const builtInExpr = `
vec3(
  max(0, 1 - abs(x - (0.5 + 0.5*sin(t * speed * 3.14159))) * 10),
  0,
  0
)
        `;
        this.runBlabExpression(builtInExpr);
      }

      solidBlabPattern() {
        debug('Solid Blab pattern: pick color via appargs.x,y,z?');
        // Let’s assume user can vary color in 0..1 in appargs.x/y/z
        const expr = `
vec3(
  appargs.x,
  appargs.y,
  appargs.z
)
        `;
        this.runBlabExpression(expr);
      }

      // ====================
      // “Expression” pattern: user-defined
      // ====================
      customExpression() {
        this.cancelAnimation();
        debug('Starting Custom Expression pattern');
        // Show expression UI
        document.getElementById('expressionUI').style.display = 'block';

        const code = document.getElementById('customExpression').value.trim();
        try {
          this.exprCompiled = math.compile(code);
          debug('Custom expression compiled OK');
        } catch (err) {
          debug('Error compiling expression: ' + err.message);
          return;
        }
        this.lastFrameTime = 0;
        exprScope.t = 0;
        exprScope.speed = parseFloat(document.getElementById('exprSpeedSlider').value) || 1;

        const animate = (timestamp) => {
          const dt = (timestamp - this.lastFrameTime) / 1000;
          this.lastFrameTime = timestamp;
          exprScope.t += dt;
          exprScope.speed = parseFloat(document.getElementById('exprSpeedSlider').value) || 1;

          this.leds.forEach((ledObj, i) => {
            exprScope.x = i / this.leds.length;
            try {
              const result = this.exprCompiled.evaluate(exprScope).valueOf();
              const maxVal = Math.max(...result);
              let scale = 1;
              if (maxVal <= 1) scale = 255;
              const r = Math.round(Math.min(255, Math.max(0, result[0]*scale)));
              const g = Math.round(Math.min(255, Math.max(0, result[1]*scale)));
              const b = Math.round(Math.min(255, Math.max(0, result[2]*scale)));
              const color = `rgb(${r},${g},${b})`;
              ledObj.core.style.backgroundColor = color;
              ledObj.glow.style.backgroundColor = color;
              ledObj.core.style.opacity = 1;
              ledObj.glow.style.opacity = 0.8;
            } catch (evalErr) {
              debug('Eval error (customExpression): ' + evalErr.message);
            }
          });
          this.currentAnimation = requestAnimationFrame(animate);
        };
        animate(0);
      }

      // Start the chosen pattern
      startPattern(patternName) {
        debug(`Starting pattern: ${patternName}`);
        // Show expression UI if it's a “Blab” or “Expression”
        const exprUI = document.getElementById('expressionUI');
        exprUI.style.display =
          (patternName.endsWith('BlabPattern') || patternName === 'customExpression')
          ? 'block'
          : 'none';

        this.cancelAnimation();
        this.leds.forEach(led => {
          led.core.style.backgroundColor = '#000';
          led.glow.style.backgroundColor = '#000';
          led.core.style.opacity = 0;
          led.glow.style.opacity = 0;
        });

        if (typeof this[patternName] === 'function') {
          this[patternName]();
        } else {
          debug(`No pattern method named "${patternName}"`);
        }
      }
    }

    // Main: parse JSON, init classes, build UI, handle tabs
    document.addEventListener('DOMContentLoaded', () => {
      const configEl = document.getElementById('controller-config');
      let controllerConfig = {};
      try {
        controllerConfig = JSON.parse(configEl.textContent);
        debug('Loaded config: ' + JSON.stringify(controllerConfig));
      } catch (e) {
        debug('Error parsing JSON config: ' + e);
      }

      window.ledStrip = new LEDStrip();

      // Build pattern buttons from JSON
      const patternGrid = document.getElementById('patternGrid');
      if (controllerConfig.patterns) {
        controllerConfig.patterns.forEach(pattern => {
          const btn = document.createElement('button');
          btn.textContent = pattern.label;
          btn.onclick = () => ledStrip.startPattern(pattern.method);
          patternGrid.appendChild(btn);
        });
      }

      // Tab switching
      const tabs = document.querySelectorAll('.tab-btn');
      tabs.forEach(tab => {
        tab.addEventListener('click', () => {
          tabs.forEach(t => t.classList.remove('active'));
          tab.classList.add('active');
          const panels = document.querySelectorAll('.tab-content > div');
          panels.forEach(p => p.classList.remove('active'));
          document.getElementById(tab.dataset.tab).classList.add('active');
        });
      });

      // Expression UI event handlers
      const exprSpeedSlider = document.getElementById('exprSpeedSlider');
      const exprSpeedVal = document.getElementById('exprSpeedVal');
      exprSpeedVal.textContent = exprSpeedSlider.value;
      exprSpeedSlider.addEventListener('input', () => {
        exprSpeedVal.textContent = exprSpeedSlider.value;
      });

      document.getElementById('exprResetTime').addEventListener('click', () => {
        exprScope.t = 0;
        debug('Expression time reset to 0');
      });

      document.getElementById('updateExpressionBtn').addEventListener('click', () => {
        ledStrip.startPattern('customExpression');
      });

      // appargs sliders
      const ax = document.getElementById('appargsX'), axv = document.getElementById('appargsXVal');
      const ay = document.getElementById('appargsY'), ayv = document.getElementById('appargsYVal');
      const az = document.getElementById('appargsZ'), azv = document.getElementById('appargsZVal');
      const aw = document.getElementById('appargsW'), awv = document.getElementById('appargsWVal');
      ax.addEventListener('input', () => { exprScope.appargs.x = parseFloat(ax.value); axv.textContent = ax.value; });
      ay.addEventListener('input', () => { exprScope.appargs.y = parseFloat(ay.value); ayv.textContent = ay.value; });
      az.addEventListener('input', () => { exprScope.appargs.z = parseFloat(az.value); azv.textContent = az.value; });
      aw.addEventListener('input', () => { exprScope.appargs.w = parseFloat(aw.value); awv.textContent = aw.value; });
    });
  </script>
</body>
</html>