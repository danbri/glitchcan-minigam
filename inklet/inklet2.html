<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Riverbend - Immersive INK Stories</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Literata:ital,wght@0,400;0,600;1,400&family=Montserrat:wght@400;600;800&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary: #6d28d9;
            --primary-dark: #5b21b6;
            --primary-light: #8b5cf6;
            --background: #0f172a;
            --surface: #1e293b;
            --text: #f8fafc;
            --text-secondary: #cbd5e1;
            --accent-red: #f43f5e;
            --accent-blue: #3b82f6;
            --accent-green: #10b981;
            --choice-left: #f43f5e;
            --choice-middle: #10b981;
            --choice-right: #3b82f6;
            --choice-height: 40vh;
            --transition-time: 0.5s;
        }

        * {
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            font-family: 'Literata', serif;
            background-color: var(--background);
            color: var(--text);
            overflow: hidden;
            touch-action: none;
        }

        .app-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            position: relative;
            overflow: hidden;
        }

        .title-bar {
            background-color: var(--surface);
            padding: 12px 20px;
            position: sticky;
            top: 0;
            z-index: 10;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }

        .title-bar h1 {
            margin: 0;
            font-family: 'Montserrat', sans-serif;
            font-size: 1.5rem;
            font-weight: 800;
            text-transform: uppercase;
            letter-spacing: 1px;
            background: linear-gradient(45deg, var(--accent-red), var(--accent-blue));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .url-form {
            display: flex;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 20;
            background-color: var(--surface);
            padding: 12px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            transform: translateY(-100%);
            transition: transform 0.3s ease;
        }

        .url-form.active {
            transform: translateY(0);
        }

        #ink-url-input {
            flex-grow: 1;
            padding: 10px 16px;
            border: none;
            border-radius: 8px 0 0 8px;
            background-color: rgba(255, 255, 255, 0.1);
            color: var(--text);
            font-size: 0.9rem;
        }

        #ink-url-input:focus {
            outline: none;
            background-color: rgba(255, 255, 255, 0.15);
        }

        #load-ink-button {
            padding: 10px 16px;
            background-color: var(--primary);
            color: white;
            border: none;
            border-radius: 0 8px 8px 0;
            cursor: pointer;
            font-family: 'Montserrat', sans-serif;
            font-weight: 600;
            font-size: 0.9rem;
            transition: background-color 0.2s ease;
        }

        #load-ink-button:hover {
            background-color: var(--primary-dark);
        }

        .story-container {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            padding: 0;
            overflow: hidden;
            position: relative;
        }

        .image-container {
            position: relative;
            width: 100%;
            height: 35vh;
            overflow: hidden;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }

        #story-image {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transition: opacity 1s ease, transform 1.5s ease;
            transform-origin: center;
        }

        #story-image.hidden {
            opacity: 0;
        }

        #story-image.zoom-in {
            transform: scale(1.1);
        }

        .image-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 150px;
            background: linear-gradient(to top, var(--background), transparent);
        }

        .story-content {
            flex-grow: 1;
            padding: 24px;
            overflow-y: auto;
            position: relative;
            z-index: 2;
        }

        #story {
            max-width: 800px;
            margin: 0 auto 2rem;
            font-size: 1.2rem;
            line-height: 1.7;
            transition: opacity 0.5s ease;
        }

        #story p {
            margin-bottom: 1rem;
        }

        #story.fading {
            opacity: 0;
        }

        .status-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(15, 23, 42, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            backdrop-filter: blur(5px);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .status-overlay.active {
            opacity: 1;
            pointer-events: all;
        }

        #status {
            background-color: var(--surface);
            padding: 20px 40px;
            border-radius: 12px;
            box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.3);
            font-family: 'Montserrat', sans-serif;
            font-size: 1.2rem;
            text-align: center;
            max-width: 80%;
        }

        .status-spinner {
            display: inline-block;
            width: 24px;
            height: 24px;
            margin-right: 12px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: #fff;
            animation: spin 1s linear infinite;
            vertical-align: middle;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .choices-container {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: var(--choice-height);
            display: flex;
            z-index: 5;
            transition: transform 0.4s cubic-bezier(0.16, 1, 0.3, 1);
        }

        .choices-container.hidden {
            transform: translateY(100%);
        }

        .choice {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-end;
            padding: 20px;
            cursor: pointer;
            position: relative;
            overflow: hidden;
            transition: all var(--transition-time) cubic-bezier(0.16, 1, 0.3, 1);
            transform-origin: bottom center;
        }

        .choice-1 { background-color: var(--choice-left); }
        .choice-2 { background-color: var(--choice-middle); }
        .choice-3 { background-color: var(--choice-right); }

        .choice-emoji {
            font-size: 4rem;
            margin-bottom: 15px;
            transition: all var(--transition-time) cubic-bezier(0.34, 1.56, 0.64, 1);
            filter: grayscale(30%) opacity(0.8);
            transform-origin: center;
        }

        .choice:hover .choice-emoji {
            filter: grayscale(0%) opacity(1);
            transform: scale(1.1);
        }

        .choice-label {
            font-family: 'Montserrat', sans-serif;
            font-weight: 600;
            font-size: 1rem;
            text-align: center;
            opacity: 0.9;
            transition: all var(--transition-time) ease;
            background-color: rgba(0, 0, 0, 0.2);
            padding: 8px 16px;
            border-radius: 8px;
            max-width: 100%;
        }

        .choice:hover .choice-label {
            opacity: 1;
        }

        .expanding-choice {
            position: fixed;
            bottom: 0;
            height: var(--choice-height);
            transition: all var(--transition-time) cubic-bezier(0.16, 1, 0.3, 1);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-end;
            padding: 20px;
            z-index: 10;
        }

        .expanding-choice .choice-emoji {
            font-size: 4rem;
            margin-bottom: 15px;
            transition: all var(--transition-time) cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        .expanding-choice .choice-label {
            font-family: 'Montserrat', sans-serif;
            font-weight: 600;
            font-size: 1rem;
            text-align: center;
            background-color: rgba(0, 0, 0, 0.2);
            padding: 8px 16px;
            border-radius: 8px;
            max-width: 100%;
        }

        .menu-button {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 1.5rem;
            cursor: pointer;
            padding: 6px 12px;
            border-radius: 6px;
            transition: all 0.2s ease;
        }

        .menu-button:hover {
            background-color: rgba(255, 255, 255, 0.1);
            color: var(--text);
        }

        .restart-button {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 24px;
            background-color: var(--primary);
            color: white;
            border: none;
            border-radius: 8px;
            font-family: 'Montserrat', sans-serif;
            font-weight: 600;
            font-size: 1rem;
            cursor: pointer;
            z-index: 20;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            animation: float 3s ease-in-out infinite;
        }

        @keyframes float {
            0% { transform: translateX(-50%) translateY(0px); }
            50% { transform: translateX(-50%) translateY(-10px); }
            100% { transform: translateX(-50%) translateY(0px); }
        }

        /* Loading animation */
        .loading-animation {
            display: inline-block;
            position: relative;
            width: 80px;
            height: 80px;
            margin-bottom: 20px;
        }
        .loading-animation div {
            position: absolute;
            top: 33px;
            width: 13px;
            height: 13px;
            border-radius: 50%;
            background: var(--primary-light);
            animation-timing-function: cubic-bezier(0, 1, 1, 0);
        }
        .loading-animation div:nth-child(1) {
            left: 8px;
            animation: loading1 0.6s infinite;
        }
        .loading-animation div:nth-child(2) {
            left: 8px;
            animation: loading2 0.6s infinite;
        }
        .loading-animation div:nth-child(3) {
            left: 32px;
            animation: loading2 0.6s infinite;
        }
        .loading-animation div:nth-child(4) {
            left: 56px;
            animation: loading3 0.6s infinite;
        }
        @keyframes loading1 {
            0% { transform: scale(0); }
            100% { transform: scale(1); }
        }
        @keyframes loading2 {
            0% { transform: translate(0, 0); }
            100% { transform: translate(24px, 0); }
        }
        @keyframes loading3 {
            0% { transform: scale(1); }
            100% { transform: scale(0); }
        }

        /* Animation classes */
        @keyframes fade-in {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes slide-up {
            from { transform: translateY(20px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        .fade-in {
            animation: fade-in 0.5s ease forwards;
        }

        .slide-up {
            animation: slide-up 0.5s ease forwards;
        }

        @media (max-width: 768px) {
            .story-content {
                padding: 16px;
            }
            
            #story {
                font-size: 1.1rem;
                line-height: 1.6;
            }
            
            .title-bar h1 {
                font-size: 1.2rem;
            }
            
            .choice-label {
                font-size: 0.9rem;
                padding: 6px 12px;
            }
            
            .choice-emoji {
                font-size: 3rem;
            }
        }

        /* End screen styles */
        .end-screen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--background);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 50;
            opacity: 0;
            pointer-events: none;
            transition: opacity 1s ease;
            text-align: center;
            padding: 24px;
        }

        .end-screen.active {
            opacity: 1;
            pointer-events: all;
        }

        .end-screen h2 {
            font-family: 'Montserrat', sans-serif;
            font-size: 2.5rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(45deg, var(--accent-red), var(--accent-blue));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .end-screen p {
            font-size: 1.2rem;
            margin-bottom: 2rem;
            max-width: 600px;
        }
    </style>
</head>
<body>
    <div class="app-container">
        <div class="title-bar">
            <h1>Riverbend</h1>
            <button class="menu-button" id="menu-button">⚙️</button>
        </div>
        
        <div class="url-form" id="url-form">
            <input type="text" id="ink-url-input" value="riverbend.ink" placeholder="Enter URL of .ink file">
            <button id="load-ink-button">Load Story</button>
        </div>
        
        <div class="story-container">
            <div class="image-container">
                <img id="story-image" alt="Story scene" class="hidden">
                <div class="image-overlay"></div>
            </div>
            
            <div class="story-content">
                <div id="story"></div>
            </div>
        </div>
        
        <div class="choices-container" id="choices-container">
            <!-- Choices will be added here dynamically -->
        </div>
        
        <div class="status-overlay" id="status-overlay">
            <div id="status">
                <div class="loading-animation"><div></div><div></div><div></div><div></div></div>
                <div id="status-text">Loading story...</div>
            </div>
        </div>
        
        <div class="end-screen" id="end-screen">
            <h2>The End</h2>
            <p>Your journey through Riverbend has concluded. What mysteries remain undiscovered?</p>
            <button class="restart-button" id="end-restart-button">Begin Again</button>
        </div>
    </div>

    <script>
        // Main state variables
        let inkStoryContent = '';
        let storyKnots = {};
        let currentKnot = '';
        let imageBasePath = './'; // Base path for images
        let animationInProgress = false;
        let expandingElement = null;
        
        // DOM elements
        const storyElement = document.getElementById('story');
        const choicesContainer = document.getElementById('choices-container');
        const statusOverlay = document.getElementById('status-overlay');
        const statusText = document.getElementById('status-text');
        const inkUrlInput = document.getElementById('ink-url-input');
        const loadInkButton = document.getElementById('load-ink-button');
        const storyImage = document.getElementById('story-image');
        const menuButton = document.getElementById('menu-button');
        const urlForm = document.getElementById('url-form');
        const endScreen = document.getElementById('end-screen');
        const endRestartButton = document.getElementById('end-restart-button');
        
        // Emoji mapping for common themes in choices
        const emojiMap = {
            // Actions
            'go': '🚶', 'walk': '🚶‍♂️', 'run': '🏃‍♀️', 'look': '👀', 'search': '🔍',
            'take': '🤲', 'grab': '✊', 'hold': '👐', 'find': '🔎',
            'talk': '💬', 'ask': '❓', 'tell': '🗣️', 'speak': '🗯️',
            'listen': '👂', 'hear': '🔊', 'watch': '👁️', 'observe': '🧐',
            'wait': '⏳', 'stay': '⌛', 'hide': '🙈', 'escape': '🏃‍♂️',
            'open': '🔓', 'close': '🔒', 'climb': '🧗‍♀️', 'jump': '⏫',
            'drink': '🥤', 'eat': '🍽️', 'sleep': '😴', 'wake': '⏰',
            'use': '🔧', 'call': '📞', 'push': '👉', 'pull': '👈',
            'read': '📚', 'write': '✍️', 'follow': '🦮', 'lead': '🧭',
            
            // Directions
            'right': '➡️', 'left': '⬅️', 'up': '⬆️', 'down': '⬇️',
            'forward': '⏩', 'back': '⏪', 'north': '🧭', 'south': '🧭',
            'east': '🧭', 'west': '🧭', 'inside': '🚪', 'outside': '🌳',
            
            // Emotions
            'happy': '😊', 'sad': '😢', 'angry': '😠', 'afraid': '😨',
            'confused': '😕', 'surprised': '😲', 'excited': '🤩', 'calm': '😌',
            'suspicious': '🤨', 'curious': '🧐', 'worried': '😟', 'annoyed': '😒',
            
            // Objects
            'door': '🚪', 'key': '🔑', 'book': '📕', 'letter': '✉️',
            'light': '💡', 'dark': '🌑', 'water': '💧', 'fire': '🔥',
            'phone': '📱', 'money': '💰', 'clock': '🕰️', 'picture': '🖼️',
            'weapon': '🗡️', 'sword': '⚔️', 'gun': '🔫', 'shield': '🛡️',
            
            // Places
            'house': '🏠', 'room': '🏘️', 'cave': '🕳️', 'forest': '🌲',
            'mountain': '⛰️', 'river': '🏞️', 'lake': '🌊', 'beach': '🏖️',
            'city': '🏙️', 'village': '🏘️', 'castle': '🏰', 'tower': '🗼',
            
            // Misc
            'yes': '✅', 'no': '❌', 'maybe': '❓', 'help': '🆘',
            'danger': '⚠️', 'safe': '🛡️', 'secret': '🤫', 'trap': '⚡',
            'accept': '👍', 'refuse': '👎', 'ignore': '🙄', 'question': '❓',
            'restart': '🔄'
        };
        
        // Default choice emojis when no keyword match is found
        const defaultEmojis = ['🚀', '🧩', '🎯'];
        
        // Initialize the story player
        function init() {
            loadInkButton.addEventListener('click', loadInkStory);
            menuButton.addEventListener('click', toggleUrlForm);
            endRestartButton.addEventListener('click', restartStory);
            
            // Debug helper
            console.log('Initializing INK player...');
            
            // Load default story if URL is already provided
            if (inkUrlInput.value) {
                loadInkStory();
            } else {
                showStatus('Enter a URL to load an INK story');
            }
            
            // Add touch handling
            document.addEventListener('touchstart', handleTouchStart);
            document.addEventListener('touchmove', handleTouchMove);
            document.addEventListener('touchend', handleTouchEnd);
        }
        
        // Toggle the URL form
        function toggleUrlForm() {
            urlForm.classList.toggle('active');
        }
        
        // Load the INK story from the provided URL
        async function loadInkStory() {
            urlForm.classList.remove('active');
            const inkUrl = inkUrlInput.value.trim();
            if (!inkUrl) {
                showStatus('Please enter a URL to an INK file');
                return;
            }
            
            showStatus('Loading story...', true);
            console.log('Loading INK story from:', inkUrl);
            
            try {
                const response = await fetch(inkUrl);
                if (!response.ok) {
                    throw new Error(`Failed to load story: ${response.statusText}`);
                }
                
                inkStoryContent = await response.text();
                console.log('Story content loaded, length:', inkStoryContent.length);
                parseInkStory(inkStoryContent);
                
                // Log the first few knots to check content
                console.log("KNOT CONTENT CHECK:");
                Object.keys(storyKnots).slice(0, 3).forEach(knotName => {
                    console.log(`Knot "${knotName}":`, storyKnots[knotName]);
                });
                
                // Check if intro knot has content, if not use the first knot with actual content
                let startKnot = 'intro';
                
                // If intro exists but is empty, find the first knot with content
                if (storyKnots.intro && 
                    (storyKnots.intro.text.length === 0 && storyKnots.intro.choices.length === 0)) {
                    console.warn('Intro knot exists but has no content, looking for alternative starting knot');
                    
                    // Find first knot with text or choices
                    for (const knotName of Object.keys(storyKnots)) {
                        const knot = storyKnots[knotName];
                        if (knot.text.length > 0 || knot.choices.length > 0) {
                            startKnot = knotName;
                            console.log(`Found alternative starting knot with content: ${startKnot}`);
                            break;
                        }
                    }
                } else if (!storyKnots.intro) {
                    startKnot = Object.keys(storyKnots)[0];
                    console.log(`No intro knot found, using first knot: ${startKnot}`);
                }
                
                console.log('Starting at knot:', startKnot);
                console.log('Available knots:', Object.keys(storyKnots));
                
                setTimeout(() => {
                    hideStatus();
                    showKnot(startKnot);
                }, 1000);
            } catch (error) {
                console.error('Error loading story:', error);
                showStatus(`Error: ${error.message}`);
            }
        }
        
        // Parse the raw INK content into our internal format
        function parseInkStory(content) {
            storyKnots = {};
            
            console.log('Starting to parse INK story content');
            
            // Split the content by knot definitions
            const lines = content.split(/\r?\n/);
            let currentKnotName = '';
            let currentKnotContent = [];
            
            for (const line of lines) {
                // If this is a knot definition
                if (line.trim().startsWith('===')) {
                    // If we were already parsing a knot, save it
                    if (currentKnotName) {
                        console.log(`Parsing knot: ${currentKnotName} with ${currentKnotContent.length} lines`);
                        
                        // Special handling for intro knot - merge duplicate content
                        if (currentKnotName === 'intro' && storyKnots['intro']) {
                            console.log('Found duplicate intro knot, merging content');
                            
                            // Get the current content
                            const parsedContent = parseKnotContent(currentKnotContent);
                            
                            // Merge text and choices with existing intro knot
                            if (parsedContent.text.length > 0) {
                                storyKnots['intro'].text = parsedContent.text;
                            }
                            
                            if (parsedContent.choices.length > 0) {
                                storyKnots['intro'].choices = parsedContent.choices;
                            }
                            
                            if (parsedContent.image) {
                                storyKnots['intro'].image = parsedContent.image;
                            }
                            
                            console.log('Merged intro knot:', storyKnots['intro']);
                        } 
                        // For all other knots, don't overwrite existing ones
                        else if (!storyKnots[currentKnotName]) {
                            storyKnots[currentKnotName] = parseKnotContent(currentKnotContent);
                        } else {
                            console.warn(`Duplicate knot definition found for: ${currentKnotName} - skipping`);
                        }
                        
                        currentKnotContent = [];
                    }
                    
                    // Extract the new knot name - remove === and any trailing ===
                    let knotNameRaw = line.trim();
                    // Remove all === markers
                    knotNameRaw = knotNameRaw.replace(/^===\s*/, '').replace(/\s*===$/, '').trim();
                    
                    // If there's still === in the string, it's likely a format like "knot_name ==="
                    if (knotNameRaw.includes("===")) {
                        knotNameRaw = knotNameRaw.split("===")[0].trim();
                    }
                    
                    currentKnotName = knotNameRaw;
                    console.log(`Found knot definition: '${currentKnotName}'`);
                } 
                // If this is a directive like "-> intro"
                else if (line.trim().startsWith('->') && !currentKnotName) {
                    // This is the entry point directive
                    const startKnot = line.trim().replace('->', '').trim();
                    currentKnotName = startKnot;
                    console.log(`Found story entry point: ${currentKnotName}`);
                }
                // Otherwise, add to the current knot's content
                else if (currentKnotName) {
                    currentKnotContent.push(line);
                }
            }
            
            // Save the last knot
            if (currentKnotName && currentKnotContent.length > 0) {
                if (!storyKnots[currentKnotName]) {
                    console.log(`Parsing final knot: ${currentKnotName} with ${currentKnotContent.length} lines`);
                    storyKnots[currentKnotName] = parseKnotContent(currentKnotContent);
                } else {
                    console.warn(`Duplicate knot definition found for final knot: ${currentKnotName} - skipping`);
                }
            }
            
            console.log(`Finished parsing story. Found ${Object.keys(storyKnots).length} unique knots.`);
        }
        
        // Parse the content of a single knot
        function parseKnotContent(lines) {
            const knot = {
                text: [],
                choices: [],
                image: null
            };
            
            console.log("Processing knot with lines:", lines);
            
            // Process each line
            for (const line of lines) {
                const trimmedLine = line.trim();
                console.log("Processing line:", trimmedLine);
                
                // Check for image tags
                if (trimmedLine.includes("[[Image:")) {
                    const imageMatch = trimmedLine.match(/\[\[Image:\s*(.*?)\s*\]\]/);
                    if (imageMatch) {
                        const imagePath = imageMatch[1];
                        knot.image = imagePath;
                        console.log("Found image:", imagePath);
                    }
                }
                // Check for choice tags
                else if (trimmedLine.includes("[[") && trimmedLine.includes("]]") && trimmedLine.includes("->")) {
                    const choiceMatch = trimmedLine.match(/\[\[(.*?)\]\]\s*->\s*(.*)/);
                    if (choiceMatch) {
                        const choiceText = choiceMatch[1];
                        const target = choiceMatch[2].trim();
                        knot.choices.push({ text: choiceText, target: target });
                        console.log("Found choice:", choiceText, "->", target);
                    }
                }
                // Regular text - anything that's not a choice or image and not empty
                else if (trimmedLine && !trimmedLine.startsWith('->') && !trimmedLine.startsWith('===')) {
                    knot.text.push(trimmedLine);
                    console.log("Found text:", trimmedLine);
                }
            }
            
            console.log("Final knot content:", knot);
            
            return knot;
        }
        
        // Choose an emoji for a choice based on its text
        function chooseEmoji(choiceText) {
            const text = choiceText.toLowerCase();
            
            // Check each emoji keyword against the choice text
            for (const [keyword, emoji] of Object.entries(emojiMap)) {
                if (text.includes(keyword)) {
                    return emoji;
                }
            }
            
            // If we reach here, no keyword matched
            // Return a random default emoji
            const index = Math.floor(Math.random() * defaultEmojis.length);
            return defaultEmojis[index];
        }
        
        // Display a specific knot with animation
        function showKnot(knotName) {
            currentKnot = knotName;
            console.log('Showing knot:', knotName);
            
            // Check if this is an ending knot
            if (knotName === 'END') {
                console.log('End of story reached');
                showEndScreen();
                return;
            }
            
            // Get the knot data
            const knot = storyKnots[knotName];
            if (!knot) {
                console.error('Knot not found:', knotName);
                storyElement.innerHTML = `<p>Error: Knot "${knotName}" not found!</p>`;
                return;
            }
            
            console.log('Knot data:', knot);
            
            // Start with fading out current content
            storyElement.classList.add('fading');
            
            setTimeout(() => {
                try {
                    // Debug the knot content
                    console.log('Rendering knot text:', knot.text);
                    console.log('Rendering knot choices:', knot.choices);
                    console.log('Rendering knot image:', knot.image);
                    
                    // Update story text
                    if (knot.text && knot.text.length > 0) {
                        const paragraphs = knot.text
                            .filter(line => line && line.trim())
                            .map(line => `<p class="slide-up" style="opacity: 0;">${line}</p>`);
                        
                        storyElement.innerHTML = paragraphs.join('');
                        console.log('Updated story text with', paragraphs.length, 'paragraphs');
                    } else {
                        console.warn('No text content found for knot:', knotName);
                        storyElement.innerHTML = '<p class="slide-up" style="opacity: 0;">No story text available for this section.</p>';
                    }
                    
                    // Remove the fading class after content is updated
                    storyElement.classList.remove('fading');
                    
                    // Animate in paragraphs
                    const storyParagraphs = storyElement.querySelectorAll('p');
                    storyParagraphs.forEach((p, index) => {
                        setTimeout(() => {
                            p.style.opacity = '1';
                        }, 100 * index);
                    });
                    
                    // Update image with animation
                    updateImage(knot.image);
                    
                    // Update choices with animation
                    updateChoices(knot.choices);
                } catch (error) {
                    console.error('Error rendering knot:', error);
                    storyElement.innerHTML = '<p>Error rendering story content.</p>';
                    storyElement.classList.remove('fading');
                }
            }, 300);
        }
        
        // Update the story image with animation
        function updateImage(imagePath) {
            console.log('Updating image:', imagePath);
            
            if (imagePath) {
                storyImage.classList.add('hidden');
                
                // For demo/testing, use a placeholder if image doesn't exist
                const placeholderImage = 'https://placehold.co/600x400/1e293b/ffffff?text=Riverbend:+' + encodeURIComponent(imagePath);
                
                setTimeout(() => {
                    // First try to load the actual image
                    const actualImage = imageBasePath + imagePath;
                    
                    // Preload image to check if it exists
                    const img = new Image();
                    img.onload = function() {
                        // Image exists, use the actual image
                        storyImage.src = actualImage;
                        storyImage.classList.remove('hidden');
                        storyImage.classList.add('zoom-in');
                        console.log('Image displayed:', storyImage.src);
                        
                        // Reset zoom after animation completes
                        setTimeout(() => {
                            storyImage.classList.remove('zoom-in');
                        }, 1500);
                    };
                    
                    img.onerror = function() {
                        // Image doesn't exist, use placeholder
                        console.warn('Image not found, using placeholder:', placeholderImage);
                        storyImage.src = placeholderImage;
                        storyImage.classList.remove('hidden');
                        storyImage.classList.add('zoom-in');
                        
                        // Reset zoom after animation completes
                        setTimeout(() => {
                            storyImage.classList.remove('zoom-in');
                        }, 1500);
                    };
                    
                    // Start loading the image
                    img.src = actualImage;
                }, 300);
            } else {
                console.log('No image to display');
                storyImage.classList.add('hidden');
            }
        }
        
        // Update the choices with animation
        function updateChoices(choices) {
            console.log('Updating choices:', choices);
            choicesContainer.innerHTML = '';
            choicesContainer.classList.add('hidden');
            
            if (!choices || choices.length === 0) {
                console.log('No choices to display');
                return;
            }
            
            // Create each choice element
            choices.forEach((choice, index) => {
                const emoji = chooseEmoji(choice.text);
                const choiceEl = document.createElement('div');
                const choiceNumber = Math.min(index + 1, 3); // Only support up to 3 distinct styles
                choiceEl.className = `choice choice-${choiceNumber}`;
                choiceEl.dataset.target = choice.target;
                choiceEl.dataset.index = index;
                
                choiceEl.innerHTML = `
                    <div class="choice-emoji">${emoji}</div>
                    <div class="choice-label">${choice.text}</div>
                `;
                
                choiceEl.addEventListener('click', (e) => handleChoiceClick(e, index, choice.target));
                choicesContainer.appendChild(choiceEl);
                console.log(`Added choice ${index + 1}:`, choice.text, '→', choice.target);
            });
            
            // Show choices with animation
            setTimeout(() => {
                choicesContainer.classList.remove('hidden');
                console.log('Choices displayed');
            }, 500);
        }
        
        // Handle choice click
        function handleChoiceClick(event, index, target) {
            if (animationInProgress) return;
            animationInProgress = true;
            
            const choiceElement = event.currentTarget;
            const rect = choiceElement.getBoundingClientRect();
            
            // Create expanding element
            expandingElement = document.createElement('div');
            expandingElement.className = 'expanding-choice';
            expandingElement.style.backgroundColor = getComputedStyle(choiceElement).backgroundColor;
            expandingElement.style.left = `${rect.left}px`;
            expandingElement.style.width = `${rect.width}px`;
            expandingElement.innerHTML = choiceElement.innerHTML;
            document.body.appendChild(expandingElement);
            
            // Start expanding animation
            requestAnimationFrame(() => {
                expandingElement.style.height = '100%';
                expandingElement.style.left = '0';
                expandingElement.style.width = '100%';
                
                // Hide original choices
                choicesContainer.style.opacity = '0';
                
                // Grow emoji during expansion
                const emoji = expandingElement.querySelector('.choice-emoji');
                emoji.style.fontSize = '8rem';
                emoji.style.filter = 'grayscale(0%) opacity(1)';
                
                // Fade out choice background
                setTimeout(() => {
                    expandingElement.style.backgroundColor = 'rgba(0,0,0,0)';
                    storyElement.classList.add('fading');
                }, 500);
                
                // Once animation is complete, navigate to target
                setTimeout(() => {
                    expandingElement.remove();
                    expandingElement = null;
                    showKnot(target);
                    choicesContainer.style.opacity = '1';
                    animationInProgress = false;
                }, 1000);
            });
        }
        
        // Show the end screen
        function showEndScreen() {
            endScreen.classList.add('active');
        }
        
        // Hide the end screen
        function hideEndScreen() {
            endScreen.classList.remove('active');
        }
        
        // Restart the story
        function restartStory() {
            hideEndScreen();
            const startKnot = storyKnots.intro ? 'intro' : Object.keys(storyKnots)[0];
            showKnot(startKnot);
        }
        
        // Show a status message
        function showStatus(message, showLoader = false) {
            statusText.textContent = message;
            statusOverlay.classList.add('active');
            
            const loader = statusOverlay.querySelector('.loading-animation');
            if (showLoader) {
                loader.style.display = 'inline-block';
            } else {
                loader.style.display = 'none';
            }
        }
        
        // Hide the status message
        function hideStatus() {
            statusOverlay.classList.remove('active');
        }
        
        // Touch handling for choice expansion
        let touchStartY = 0;
        let touchStartX = 0;
        let choiceIndex = -1;
        let touchStartTime = 0;
        
        function handleTouchStart(event) {
            if (animationInProgress || !event.touches[0]) return;
            
            touchStartY = event.touches[0].clientY;
            touchStartX = event.touches[0].clientX;
            touchStartTime = Date.now();
            
            // Find the choice element that was touched
            const choice = document.elementFromPoint(touchStartX, touchStartY);
            const choiceEl = choice ? choice.closest('.choice') : null;
            
            if (choiceEl) {
                choiceIndex = parseInt(choiceEl.dataset.index);
            }
        }
        
        function handleTouchMove(event) {
            if (choiceIndex === -1 || !event.touches[0]) return;
            
            const touchY = event.touches[0].clientY;
            const touchX = event.touches[0].clientX;
            
            // Calculate how much the user has pulled down
            const deltaY = touchStartY - touchY;
            
            // If they're pulling up significantly
            if (deltaY > 50) {
                // Start expanding the choice
                if (!expandingElement && !animationInProgress) {
                    const choiceEl = document.querySelector(`.choice[data-index="${choiceIndex}"]`);
                    if (choiceEl) {
                        handleChoiceClick({currentTarget: choiceEl}, choiceIndex, choiceEl.dataset.target);
                    }
                }
            }
        }
        
        function handleTouchEnd(event) {
            const touchDuration = Date.now() - touchStartTime;
            
            // Treat short touches as taps/clicks
            if (touchDuration < 300 && choiceIndex !== -1) {
                const choiceEl = document.querySelector(`.choice[data-index="${choiceIndex}"]`);
                if (choiceEl && !animationInProgress) {
                    handleChoiceClick({currentTarget: choiceEl}, choiceIndex, choiceEl.dataset.target);
                }
            }
            
            choiceIndex = -1;
        }
        
        // Helper function to display debug information
        function debugStoryStructure() {
            const debugInfo = document.createElement('div');
            debugInfo.style.position = 'fixed';
            debugInfo.style.top = '100px';
            debugInfo.style.right = '20px';
            debugInfo.style.width = '300px';
            debugInfo.style.maxHeight = '500px';
            debugInfo.style.overflowY = 'auto';
            debugInfo.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
            debugInfo.style.color = '#fff';
            debugInfo.style.padding = '15px';
            debugInfo.style.borderRadius = '8px';
            debugInfo.style.zIndex = '1000';
            debugInfo.style.fontSize = '12px';
            debugInfo.style.fontFamily = 'monospace';
            
            let debugContent = '<h3>Story Structure</h3>';
            
            // Add story knots
            debugContent += '<h4>Knots:</h4>';
            const knotList = Object.keys(storyKnots);
            debugContent += `<p>Total knots: ${knotList.length}</p>`;
            
            // Display first 5 knots with details
            for (let i = 0; i < Math.min(5, knotList.length); i++) {
                const knotName = knotList[i];
                const knot = storyKnots[knotName];
                debugContent += `<details>
                    <summary>${knotName}</summary>
                    <p>Text lines: ${knot.text.length}</p>
                    <p>Choices: ${knot.choices.length}</p>
                    <p>Has image: ${knot.image ? 'Yes' : 'No'}</p>
                </details>`;
            }
            
            debugInfo.innerHTML = debugContent;
            
            // Add close button
            const closeBtn = document.createElement('button');
            closeBtn.innerText = 'Close';
            closeBtn.style.marginTop = '10px';
            closeBtn.style.padding = '5px 10px';
            closeBtn.addEventListener('click', () => debugInfo.remove());
            debugInfo.appendChild(closeBtn);
            
            document.body.appendChild(debugInfo);
        }
        
        // Initialize when the page loads
        window.addEventListener('DOMContentLoaded', init);
        
        // Expose debug function globally
        window.debugStoryStructure = debugStoryStructure;
    </script>
</body>
</html>