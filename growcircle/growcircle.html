<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Circle Growth Visualization</title>
    <style>
        body{margin:0;padding:0;background:#0f0f1f;color:white;font-family:sans-serif;overflow:hidden;display:flex;justify-content:center;align-items:center;height:100vh;}
        #container{position:relative;width:min(900px,95vw);height:min(600px,95vh);border-radius:12px;box-shadow:0 0 20px rgba(0,0,0,0.3);}
        canvas{position:absolute;top:0;left:0;width:100%;height:100%;}
        #controls{position:absolute;bottom:20px;left:0;width:100%;display:flex;justify-content:center;gap:20px;z-index:10;}
        button{background:#8d44ad;color:white;border:none;padding:10px 20px;border-radius:5px;cursor:pointer;font-size:16px;transition:all 0.3s;}
        button:hover{background:#9b59b6;transform:translateY(-2px);}
        button:active{transform:translateY(1px);}
        #stageTitle{position:absolute;top:20px;left:0;width:100%;text-align:center;font-size:min(24px,5vw);font-weight:bold;transition:opacity 0.5s,transform 0.5s;z-index:10;text-shadow:0 0 10px rgba(0,0,0,0.5);}
        #explanation{position:absolute;top:60px;left:50px;width:calc(100% - 100px);text-align:left;font-size:min(18px,4vw);line-height:1.5;transition:opacity 0.5s,transform 0.5s;z-index:10;text-shadow:0 0 10px rgba(0,0,0,0.5);}
        #formula{position:absolute;bottom:100px;left:0;width:100%;text-align:center;font-size:min(26px,5vw);font-family:'Times New Roman',serif;transition:opacity 0.5s;z-index:10;opacity:0;}
        #navigation{position:absolute;bottom:70px;left:0;width:100%;display:flex;justify-content:center;align-items:center;gap:10px;z-index:10;}
        .navDot{width:10px;height:10px;border-radius:50%;background:rgba(255,255,255,0.3);transition:all 0.3s;cursor:pointer;}
        .navDot.active{background:white;transform:scale(1.3);}
        #sliderContainer{position:absolute;bottom:150px;left:50%;transform:translateX(-50%);width:min(400px,80%);text-align:center;z-index:10;transition:opacity 0.5s;}
        #radiusSlider{width:100%;margin-bottom:10px;cursor:pointer;}
        #sliderLabel{font-size:min(16px,3.5vw);}
        #keyboardHint{position:absolute;bottom:15px;left:0;width:100%;text-align:center;font-size:14px;color:rgba(255,255,255,0.6);z-index:10;}
    </style>
</head>
<body>
    <div id="container">
        <canvas id="animationCanvas"></canvas>
        
        <div id="stageTitle">Growing Circles: Understanding Area Change</div>
        
        <div id="explanation">
            What happens to a circle's area when its radius grows slightly?
            Let's explore this visually, building intuition before any formulas.
        </div>
        
        <div id="formula"></div>
        
        <div id="sliderContainer">
            <input type="range" id="radiusSlider" min="1" max="40" value="10">
            <div id="sliderLabel">Change in radius (dr): 10 units</div>
        </div>
        
        <div id="navigation"></div>
        
        <div id="controls">
            <button id="prevBtn">Previous</button>
            <button id="nextBtn">Next</button>
        </div>
        
        <div id="keyboardHint">Use Left/Right arrow keys to navigate</div>
    </div>

    <script>
        // Core elements
        const container = document.getElementById('container');
        const canvas = document.getElementById('animationCanvas');
        const ctx = canvas.getContext('2d');
        const stageTitle = document.getElementById('stageTitle');
        const explanation = document.getElementById('explanation');
        const formula = document.getElementById('formula');
        const navigation = document.getElementById('navigation');
        const prevBtn = document.getElementById('prevBtn');
        const nextBtn = document.getElementById('nextBtn');
        const radiusSlider = document.getElementById('radiusSlider');
        const sliderLabel = document.getElementById('sliderLabel');
        const sliderContainer = document.getElementById('sliderContainer');
        
        // State variables
        let currentStep = 0;
        const totalSteps = 5;
        let animationFrameId = null;
        let time = 0;
        let dr = 10; // Initial change in radius
        let isTransitioning = false;
        let transitionProgress = 0;
        
        // Colors
        const colors = {
            blue: '#3498db',
            purple: '#8e44ad',
            green: '#2ecc71',
            orange: '#e67e22',
            yellow: '#f1c40f',
            red: '#e74c3c',
            teal: '#1abc9c',
            white: '#ffffff',
            background: '#0f0f1f'
        };
        
        // Setup high-resolution canvas
        function setupCanvas() {
            const style = getComputedStyle(container);
            const width = parseInt(style.width);
            const height = parseInt(style.height);
            
            canvas.width = width;
            canvas.height = height;
            
            const dpr = window.devicePixelRatio || 1;
            canvas.width = width * dpr;
            canvas.height = height * dpr;
            ctx.scale(dpr, dpr);
            
            canvas.style.width = `${width}px`;
            canvas.style.height = `${height}px`;
        }
        
        window.addEventListener('load', setupCanvas);
        window.addEventListener('resize', setupCanvas);
        
        // Setup navigation dots
        function setupNavigation() {
            navigation.innerHTML = '';
            for (let i = 0; i < totalSteps; i++) {
                const dot = document.createElement('div');
                dot.className = 'navDot';
                if (i === currentStep) dot.classList.add('active');
                dot.addEventListener('click', () => {
                    if (i !== currentStep && !isTransitioning) {
                        startTransition(i);
                    }
                });
                navigation.appendChild(dot);
            }
        }
        
        // Update navigation dots
        function updateNavigation() {
            const dots = navigation.querySelectorAll('.navDot');
            dots.forEach((dot, i) => {
                if (i === currentStep) {
                    dot.classList.add('active');
                } else {
                    dot.classList.remove('active');
                }
            });
        }
        
        // Event listeners
        radiusSlider.addEventListener('input', function() {
            dr = parseInt(this.value);
            sliderLabel.textContent = `Change in radius (dr): ${dr} units`;
            if (!isTransitioning) {
                render(currentStep);
            }
        });
        
        document.addEventListener('keydown', function(e) {
            if (isTransitioning) return;
            
            if (e.key === 'ArrowRight' || e.key === ' ') {
                if (currentStep < totalSteps - 1) {
                    startTransition(currentStep + 1);
                }
            } else if (e.key === 'ArrowLeft') {
                if (currentStep > 0) {
                    startTransition(currentStep - 1);
                }
            }
        });
        
        prevBtn.addEventListener('click', function() {
            if (currentStep > 0 && !isTransitioning) {
                startTransition(currentStep - 1);
            }
        });
        
        nextBtn.addEventListener('click', function() {
            if (currentStep < totalSteps - 1 && !isTransitioning) {
                startTransition(currentStep + 1);
            }
        });
        
        // Helper functions
        function getCenter() {
            return {
                x: canvas.width / (2 * (window.devicePixelRatio || 1)),
                y: canvas.height / (2 * (window.devicePixelRatio || 1))
            };
        }
        
        function getBaseRadius() {
            const center = getCenter();
            return Math.min(center.x, center.y) * 0.4;
        }
        
        function clear() {
            const width = canvas.width / (window.devicePixelRatio || 1);
            const height = canvas.height / (window.devicePixelRatio || 1);
            
            ctx.fillStyle = colors.background;
            ctx.fillRect(0, 0, width, height);
            
            // Subtle grid
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
            ctx.lineWidth = 1;
            for (let x = 0; x < width; x += 40) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, height);
                ctx.stroke();
            }
            for (let y = 0; y < height; y += 40) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
            }
        }
        
        // Drawing functions
        function hexToRgba(hex, alpha = 1) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }
        
        function drawCircle(x, y, radius, color, fill = false, lineWidth = 2) {
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, Math.PI * 2);
            ctx.strokeStyle = color;
            ctx.lineWidth = lineWidth;
            ctx.stroke();
            if (fill) {
                ctx.fillStyle = color;
                ctx.fill();
            }
        }
        
        function fillCircle(x, y, radius, color, alpha = 1) {
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, Math.PI * 2);
            ctx.fillStyle = hexToRgba(color, alpha);
            ctx.fill();
        }
        
        function drawLine(x1, y1, x2, y2, color, lineWidth = 2, dashed = false) {
            ctx.beginPath();
            if (dashed) ctx.setLineDash([5, 3]);
            else ctx.setLineDash([]);
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.strokeStyle = color;
            ctx.lineWidth = lineWidth;
            ctx.stroke();
            ctx.setLineDash([]);
        }
        
        function drawText(text, x, y, color, size = 20, align = 'left') {
            ctx.fillStyle = color;
            ctx.font = `${size}px Arial`;
            ctx.textAlign = align;
            ctx.fillText(text, x, y);
        }
        
        function drawArrow(fromX, fromY, toX, toY, color, lineWidth = 2) {
            const headLength = 15;
            const angle = Math.atan2(toY - fromY, toX - fromX);
            
            // Line
            ctx.beginPath();
            ctx.moveTo(fromX, fromY);
            ctx.lineTo(toX, toY);
            ctx.strokeStyle = color;
            ctx.lineWidth = lineWidth;
            ctx.stroke();
            
            // Arrow head
            ctx.beginPath();
            ctx.moveTo(toX, toY);
            ctx.lineTo(toX - headLength * Math.cos(angle - Math.PI/6), 
                       toY - headLength * Math.sin(angle - Math.PI/6));
            ctx.lineTo(toX - headLength * Math.cos(angle + Math.PI/6), 
                       toY - headLength * Math.sin(angle + Math.PI/6));
            ctx.closePath();
            ctx.fillStyle = color;
            ctx.fill();
        }
        
        // Render steps with intuition-first approach
        function renderStep0(progress = 1) {
            clear();
            const center = getCenter();
            const baseRadius = getBaseRadius();
            
            // Animated growing circle
            const animPulse = (Math.sin(time) * 0.5 + 0.5);
            const pulseScale = 0.2 * progress;
            const pulseRadius = baseRadius * (1 + animPulse * pulseScale);
            
            // Circle with pulsing effect
            fillCircle(center.x, center.y, pulseRadius, colors.blue, 0.3);
            drawCircle(center.x, center.y, pulseRadius, colors.blue, false, 2);
            
            // Radius line
            drawLine(center.x, center.y, center.x + pulseRadius, center.y, colors.green, 2);
            
            // Radius label with fade-in
            ctx.globalAlpha = progress;
            drawText("r", center.x + pulseRadius/2, center.y - 15, colors.green, 20, "center");
            ctx.globalAlpha = 1;
            
            // Text content
            stageTitle.textContent = "Watching a Circle Grow";
            explanation.innerHTML = "When a circle's radius changes, its area changes too.<br><br>Watch how the circle pulses as its radius grows and shrinks. What happens to the area?";
            
            // Hide formula initially
            formula.style.opacity = 0;
            sliderContainer.style.opacity = 0;
        }
        
        function renderStep1(progress = 1) {
            clear();
            const center = getCenter();
            const baseRadius = getBaseRadius();
            
            // Original circle
            fillCircle(center.x, center.y, baseRadius, colors.blue, 0.3);
            drawCircle(center.x, center.y, baseRadius, colors.blue, false, 2);
            
            // Radius
            drawLine(center.x, center.y, center.x + baseRadius, center.y, colors.green, 2);
            drawText("r", center.x + baseRadius/2, center.y - 15, colors.green);
            
            // Expanded circle with animated transition
            const growthProgress = Math.min(progress, 1);
            const expandedRadius = baseRadius + dr * growthProgress;
            
            drawCircle(center.x, center.y, expandedRadius, colors.orange, false, 2);
            
            // New radius
            const newRadiusX = center.x + baseRadius + dr * growthProgress;
            drawLine(center.x, center.y, newRadiusX, center.y, colors.orange, 2, true);
            
            if (progress > 0.5) {
                ctx.globalAlpha = (progress - 0.5) * 2;
                drawText("r + dr", center.x + baseRadius + dr/2, center.y - 30, colors.orange);
                ctx.globalAlpha = 1;
            }
            
            // Highlight the ring (donut) with animated fill
            if (progress > 0.3) {
                const ringAlpha = Math.min(((progress - 0.3) * 2), 1) * 0.5;
                ctx.beginPath();
                ctx.arc(center.x, center.y, expandedRadius, 0, Math.PI * 2);
                ctx.arc(center.x, center.y, baseRadius, 0, Math.PI * 2, true);
                ctx.closePath();
                ctx.fillStyle = hexToRgba(colors.orange, ringAlpha);
                ctx.fill();
            }
            
            // Label the ring with arrow
            if (progress > 0.7) {
                ctx.globalAlpha = (progress - 0.7) * 3.33;
                drawArrow(center.x + baseRadius + 70, center.y - 70, center.x + baseRadius + dr/2, center.y - 40, colors.red, 2);
                drawText("New Area", center.x + baseRadius + 100, center.y - 80, colors.red, 20, "center");
                ctx.globalAlpha = 1;
            }
            
            // Text content
            stageTitle.textContent = "The 'Donut Ring' of New Area";
            explanation.innerHTML = "When a circle's radius increases by a small amount (dr), the area grows by adding a thin ring around the original circle.<br><br>This 'donut ring' is the key to understanding how circle area changes.";
            formula.style.opacity = 0;
            
            // Show slider
            sliderContainer.style.opacity = progress;
        }
        
        function renderStep2(progress = 1) {
            clear();
            const center = getCenter();
            const baseRadius = getBaseRadius();
            
            // Original circle
            fillCircle(center.x, center.y, baseRadius, colors.blue, 0.3);
            drawCircle(center.x, center.y, baseRadius, colors.blue, false, 2);
            
            // Expanded circle
            drawCircle(center.x, center.y, baseRadius + dr, colors.orange, false, 2);
            
            // Highlight the ring (donut)
            ctx.beginPath();
            ctx.arc(center.x, center.y, baseRadius + dr, 0, Math.PI * 2);
            ctx.arc(center.x, center.y, baseRadius, 0, Math.PI * 2, true);
            ctx.closePath();
            ctx.fillStyle = hexToRgba(colors.orange, 0.5);
            ctx.fill();
            
            // Animate "unwrapping" the donut
            const unwrapAmount = progress;
            
            // Calculate the angle of unwrapping (partial circle)
            const unwrapAngle = Math.PI * 2 * (1 - unwrapAmount);
            
            // Hide the original donut as it unwraps
            if (unwrapAmount > 0) {
                ctx.globalAlpha = 1 - unwrapAmount;
                ctx.beginPath();
                ctx.arc(center.x, center.y, baseRadius + dr, 0, unwrapAngle);
                ctx.arc(center.x, center.y, baseRadius, unwrapAngle, 0, true);
                ctx.closePath();
                ctx.fillStyle = hexToRgba(colors.orange, 0.5);
                ctx.fill();
                ctx.globalAlpha = 1;
            }
            
            // Draw the unwrapped strip
            if (unwrapAmount > 0) {
                // Position for the unwrapped strip
                const stripY = center.y + baseRadius * 0.8;
                const stripStartX = center.x - (2 * Math.PI * baseRadius * unwrapAmount) / 2;
                const stripEndX = center.x + (2 * Math.PI * baseRadius * unwrapAmount) / 2;
                const stripHeight = dr;
                
                // Draw the strip
                ctx.beginPath();
                ctx.rect(stripStartX, stripY, stripEndX - stripStartX, stripHeight);
                ctx.fillStyle = hexToRgba(colors.orange, 0.5);
                ctx.fill();
                ctx.strokeStyle = colors.orange;
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Label the dimensions
                if (unwrapAmount > 0.7) {
                    ctx.globalAlpha = (unwrapAmount - 0.7) * 3.33;
                    
                    // Label width
                    drawText("Width = Circumference = 2πr", center.x, stripY - 15, colors.purple, 18, "center");
                    
                    // Label height
                    drawText("Height = dr", stripEndX + 15, stripY + stripHeight/2, colors.green, 18, "left");
                    
                    ctx.globalAlpha = 1;
                }
                
                // Draw unwrapping arrow
                if (unwrapAmount < 0.8) {
                    ctx.globalAlpha = 1 - unwrapAmount;
                    drawArrow(center.x, center.y - baseRadius/2, center.x, stripY - 20, colors.yellow, 2);
                    drawText("Unwrapping", center.x + 20, center.y - baseRadius/2, colors.yellow, 18, "left");
                    ctx.globalAlpha = 1;
                }
            }
            
            // Text content
            stageTitle.textContent = "Unwrapping the Donut into a Strip";
            explanation.innerHTML = "Imagine 'unwrapping' our donut ring and straightening it out into a thin strip.<br><br>The length of this strip equals the circumference of the circle (2πr). The height of the strip equals our small change in radius (dr).";
            
            // Show formula
            if (progress > 0.8) {
                formula.textContent = "Strip Area = Length × Height = 2πr × dr";
                formula.style.opacity = (progress - 0.8) * 5;
            } else {
                formula.style.opacity = 0;
            }
            
            // Show slider
            sliderContainer.style.opacity = 1;
        }
        
        function renderStep3(progress = 1) {
            clear();
            const center = getCenter();
            const baseRadius = getBaseRadius();
            
            // Fade out the circle/donut visual
            ctx.globalAlpha = Math.max(0, 1 - progress);
            fillCircle(center.x, center.y, baseRadius, colors.blue, 0.3);
            drawCircle(center.x, center.y, baseRadius, colors.blue, false, 2);
            drawCircle(center.x, center.y, baseRadius + dr, colors.orange, false, 2);
            
            // Donut
            ctx.beginPath();
            ctx.arc(center.x, center.y, baseRadius + dr, 0, Math.PI * 2);
            ctx.arc(center.x, center.y, baseRadius, 0, Math.PI * 2, true);
            ctx.closePath();
            ctx.fillStyle = hexToRgba(colors.orange, 0.5);
            ctx.fill();
            ctx.globalAlpha = 1;
            
            // Draw the fully unwrapped strip
            const stripY = center.y;
            const stripWidth = 2 * Math.PI * baseRadius;
            const stripStartX = center.x - stripWidth / 2;
            const stripEndX = center.x + stripWidth / 2;
            const stripHeight = dr;
            
            // Draw the strip
            ctx.beginPath();
            ctx.rect(stripStartX, stripY, stripWidth, stripHeight);
            ctx.fillStyle = hexToRgba(colors.orange, 0.5);
            ctx.fill();
            ctx.strokeStyle = colors.orange;
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Label dimensions
            drawText("Length = 2πr", center.x, stripY - 15, colors.purple, 18, "center");
            drawText("dr", stripEndX + 15, stripY + stripHeight/2, colors.green, 18, "left");
            
            // Highlight area calculation
            if (progress > 0.3) {
                ctx.globalAlpha = (progress - 0.3) * 1.5;
                
                // Area explanation
                const areaStartY = stripY + stripHeight + 40;
                drawText("Area of the Strip = Length × Height", center.x, areaStartY, colors.blue, 20, "center");
                drawText("= 2πr × dr", center.x, areaStartY + 30, colors.blue, 20, "center");
                
                // Visual highlight
                ctx.beginPath();
                ctx.rect(stripStartX, stripY, stripWidth, stripHeight);
                ctx.strokeStyle = colors.yellow;
                ctx.lineWidth = 3;
                ctx.stroke();
                
                ctx.globalAlpha = 1;
            }
            
            // Text content
            stageTitle.textContent = "The Area of Our Donut Ring";
            explanation.innerHTML = "The area of the donut ring equals the area of our unwrapped strip.<br><br>Simple geometry tells us that the area of a rectangle equals length × height. So the area of our strip (and therefore our donut) is:<br>2πr × dr";
            
            // Show formula
            if (progress > 0.5) {
                formula.textContent = "Donut Area = 2πr × dr";
                formula.style.opacity = Math.min(1, (progress - 0.5) * 2);
            } else {
                formula.style.opacity = 0;
            }
            
            // Show slider
            sliderContainer.style.opacity = 1;
        }
        
        function renderStep4(progress = 1) {
            clear();
            const center = getCenter();
            const baseRadius = getBaseRadius();
            
            // Show shrinking dr
            const drProgress = Math.max(0.1, 1 - progress * 0.8);
            const visualDr = dr * drProgress;
            
            // Original circle
            fillCircle(center.x, center.y, baseRadius, colors.blue, 0.3);
            drawCircle(center.x, center.y, baseRadius, colors.blue, false, 2);
            
            // Expanded circle
            drawCircle(center.x, center.y, baseRadius + visualDr, colors.orange, false, 2);
            
            // Donut
            ctx.beginPath();
            ctx.arc(center.x, center.y, baseRadius + visualDr, 0, Math.PI * 2);
            ctx.arc(center.x, center.y, baseRadius, 0, Math.PI * 2, true);
            ctx.closePath();
            ctx.fillStyle = hexToRgba(colors.orange, 0.5);
            ctx.fill();
            
            // Show dr getting smaller
            const drText = Math.max(1, Math.floor(dr * drProgress));
            drawText(`dr = ${drText}`, center.x + baseRadius + visualDr + 20, center.y, colors.orange, 20, "left");
            drawText("r", center.x + baseRadius/2, center.y - 15, colors.green);
            
            // Show instantaneous rate of change
            if (progress > 0.6) {
                ctx.globalAlpha = Math.min(1, (progress - 0.6) * 2.5);
                
                // Graph
                const graphX = center.x + baseRadius * 0.9;
                const graphY = center.y + baseRadius * 0.6;
                const graphSize = baseRadius * 0.7;
                
                // Axes
                drawLine(graphX - graphSize/2, graphY, graphX + graphSize/2, graphY, colors.white, 1);
                drawLine(graphX, graphY - graphSize/2, graphX, graphY + graphSize/2, colors.white, 1);
                
                // Labels
                drawText("r", graphX + graphSize/2, graphY + 20, colors.green, 16, "center");
                drawText("Area", graphX - 10, graphY - graphSize/2, colors.blue, 16, "right");
                
                // Area curve (r²)
                ctx.beginPath();
                ctx.moveTo(graphX - graphSize/2, graphY);
                
                for (let i = 0; i <= graphSize; i++) {
                    const x = i / graphSize - 0.5; // [-0.5, 0.5]
                    const y = -(x * x) * graphSize * 0.8; // Parabola
                    ctx.lineTo(graphX + i - graphSize/2, graphY + y);
                }
                
                ctx.strokeStyle = colors.blue;
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Tangent line at a point
                const touchX = graphX + graphSize * 0.3;
                const touchR = (touchX - (graphX - graphSize/2)) / graphSize - 0.5;
                const touchY = graphY - (touchR * touchR) * graphSize * 0.8;
                
                // Point on curve
                ctx.beginPath();
                ctx.arc(touchX, touchY, 4, 0, Math.PI * 2);
                ctx.fillStyle = colors.red;
                ctx.fill();
                
                // Tangent line
                const slope = -2 * touchR * graphSize * 0.8;
                ctx.beginPath();
                ctx.moveTo(touchX - 30, touchY - slope * (-30/graphSize));
                ctx.lineTo(touchX + 30, touchY - slope * (30/graphSize));
                ctx.strokeStyle = colors.red;
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Label slope
                drawText("Slope = 2πr", touchX + 35, touchY - 20, colors.red, 16, "left");
                
                ctx.globalAlpha = 1;
            }
            
            // Text content
            stageTitle.textContent = "The Circle's Rate of Area Change";
            explanation.innerHTML = "As our change in radius (dr) gets smaller and smaller, our approximation gets more and more accurate.<br><br>In the limit as dr approaches zero, we've found the <i>instantaneous rate of change</i> of area with respect to radius. This rate equals the circumference (2πr).";
            
            // Show formula
            formula.innerHTML = "Rate of Area Change = 2πr<br><small>(In calculus: dA/dr = 2πr)</small>";
            formula.style.opacity = Math.min(1, progress * 1.5);
            
            // Fade out slider
            sliderContainer.style.opacity = Math.max(0, 1 - progress);
        }
        
        // Render with transitions
        function render(step, transitionProgress = 1) {
            switch(step) {
                case 0: renderStep0(transitionProgress); break;
                case 1: renderStep1(transitionProgress); break;
                case 2: renderStep2(transitionProgress); break;
                case 3: renderStep3(transitionProgress); break;
                case 4: renderStep4(transitionProgress); break;
            }
        }
        
        // Handle transitions between steps
        function startTransition(targetStep) {
            if (isTransitioning) return;
            
            isTransitioning = true;
            const startStep = currentStep;
            transitionProgress = 0;
            
            function transition() {
                transitionProgress += 0.03;
                
                if (transitionProgress < 0.5) {
                    // First half: fade out current step
                    render(startStep, 1 - transitionProgress * 2);
                } else {
                    // Second half: fade in new step
                    currentStep = targetStep;
                    updateNavigation();
                    render(targetStep, (transitionProgress - 0.5) * 2);
                }
                
                if (transitionProgress >= 1) {
                    isTransitioning = false;
                    cancelAnimationFrame(animationFrameId);
                    animate(); // Resume normal animation
                    return;
                }
                
                requestAnimationFrame(transition);
            }
            
            cancelAnimationFrame(animationFrameId);
            requestAnimationFrame(transition);
        }
        
        // Animation loop
        function animate() {
            time += 0.02;
            if (!isTransitioning) {
                render(currentStep);
            }
            animationFrameId = requestAnimationFrame(animate);
        }
        
        // Initialize
        setupNavigation();
        animate();
