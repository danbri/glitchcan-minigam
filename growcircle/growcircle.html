<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Circle Growth Visualization</title>
    <style>
        :root {
            --thumb-size: 20px; /* Variable for animated slider thumb size */
        }
        body {
            margin: 0;
            padding: 0;
            background: #0f0f1f;
            color: white;
            font-family: sans-serif;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        
        #container {
            position: relative;
            width: min(900px, 95vw);
            height: min(600px, 95vh);
            border-radius: 12px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.3);
            overflow: hidden; /* Add this to contain the animation */
        }
        
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 12px;
        }
        
        #controls {
            position: absolute;
            bottom: 20px;
            left: 0;
            width: 100%;
            display: flex;
            justify-content: center;
            gap: 20px;
            z-index: 10;
        }
        
        button {
            background: #8d44ad;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s;
        }
        
        button:hover {
            background: #9b59b6;
            transform: translateY(-2px);
        }
        
        button:active {
            transform: translateY(1px);
        }
        
        #stageTitle {
            position: absolute;
            top: 20px;
            left: 0;
            width: 100%;
            text-align: center;
            font-size: min(24px, 5vw);
            font-weight: bold;
            transition: opacity 0.5s, transform 0.5s;
            z-index: 10;
            text-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
        
        #explanation {
            position: absolute;
            top: 60px;
            left: 50px;
            width: calc(100% - 100px);
            text-align: left;
            font-size: min(18px, 4vw);
            line-height: 1.5;
            transition: opacity 0.5s, transform 0.5s;
            z-index: 10;
            text-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
        
        #formula {
            position: absolute;
            bottom: 100px;
            left: 0;
            width: 100%;
            text-align: center;
            font-size: min(26px, 5vw);
            font-family: 'Times New Roman', serif;
            transition: opacity 0.5s;
            z-index: 10;
            opacity: 0;
        }
        
        #navigation {
            position: absolute;
            bottom: 70px;
            left: 0;
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            z-index: 10;
        }
        
        .navDot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            transition: all 0.3s;
            cursor: pointer;
        }
        
        .navDot.active {
            background: white;
            transform: scale(1.3);
        }
        
        #sliderContainer {
            position: absolute;
            bottom: 100px;
            left: 60px; /* Moved to bottom left */
            width: min(300px, 40%);
            text-align: left;
            z-index: 10;
            transition: opacity 0.5s;
        }
        
        @keyframes sliderWobble {
            0% { transform: translateX(0); }
            25% { transform: translateX(3px); }
            75% { transform: translateX(-3px); }
            100% { transform: translateX(0); }
        }
        
        .wobble {
            animation: sliderWobble 6s ease-in-out infinite;
        }
        
        #radiusSlider {
            width: 100%;
            margin-bottom: 10px;
            cursor: pointer;
            -webkit-appearance: none;
            height: 8px;
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.2);
        }
        
        #radiusSlider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: var(--thumb-size);
            height: var(--thumb-size);
            border-radius: 50%;
            background: #8d44ad;
            cursor: pointer;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.3), 0 0 15px rgba(141, 68, 173, 0.5);
            transition: all 0.2s ease;
        }
        
        #radiusSlider::-webkit-slider-thumb:hover {
            transform: scale(1.1);
            background: #9b59b6;
            box-shadow: 0 0 8px rgba(0, 0, 0, 0.4), 0 0 20px rgba(141, 68, 173, 0.7);
        }
        
        #sliderLabel {
            font-size: min(16px, 3.5vw);
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
            color: #e0e0e0;
            font-weight: 500;
        }
        
        #keyboardHint {
            position: absolute;
            bottom: 15px;
            left: 0;
            width: 100%;
            text-align: center;
            font-size: 14px;
            color: rgba(255, 255, 255, 0.6);
            z-index: 10;
        }
        
        #stepCounter {
            position: absolute;
            bottom: 60px;
            width: 100%;
            text-align: center;
            font-size: 16px;
            z-index: 10;
        }
        
        #progressBar {
            position: absolute;
            bottom: 55px;
            left: 50%;
            transform: translateX(-50%);
            width: min(300px, 60%);
            height: 4px;
            background-color: #555;
            border-radius: 2px;
            z-index: 10;
        }
        
        #progressIndicator {
            height: 100%;
            background-color: #8d44ad;
            border-radius: 2px;
            width: 0%;
        }
        
        /* New animations and visual elements */
        .highlight-pulse {
            animation: pulsate 1.5s ease-in-out infinite;
        }
        
        @keyframes pulsate {
            0% { opacity: 0.5; }
            50% { opacity: 1; }
            100% { opacity: 0.5; }
        }
        
        @keyframes unwind {
            0% { 
                transform: rotate(0deg); 
                border-radius: 50%;
            }
            100% { 
                transform: rotate(360deg);
                border-radius: 0;
            }
        }
        
        .highlight-circle {
            position: absolute;
            border-radius: 50%;
            pointer-events: none;
            box-shadow: 0 0 0 4px rgba(255, 255, 255, 0.7);
            transition: all 0.5s ease;
            opacity: 0;
            z-index: 20;
        }
        
        #transitionOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #0f0f1f;
            opacity: 0;
            z-index: 15;
            pointer-events: none;
            transition: opacity 0.4s ease;
        }
        
        #contextHint {
            position: absolute;
            bottom: 120px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 15px;
            border-radius: 5px;
            font-size: 16px;
            opacity: 0;
            transition: opacity 0.5s ease;
            z-index: 20;
            max-width: 80%;
            text-align: center;
        }
        
        #stepIndicator {
            position: absolute;
            display: flex;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            gap: 12px;
            z-index: 20;
        }
        
        .stepDot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .stepDot.active {
            background: white;
            transform: scale(1.2);
        }
        
        .stepDot:hover {
            background: rgba(255, 255, 255, 0.7);
        }
    </style>
</head>
<body>
    <div id="container">
        <canvas id="animationCanvas"></canvas>
        
        <div id="stageTitle">Growing Circles: Understanding Area Change</div>
        
        <div id="explanation">
            What happens to a circle's area when its radius grows slightly?
            Let's explore this visually, building intuition before any formulas.
        </div>
        
        <div id="formula"></div>
        
        <div id="sliderContainer" class="wobble">
            <input type="range" id="radiusSlider" min="1" max="40" value="20">
            <div id="sliderLabel">Change in radius (dr): 20 units</div>
        </div>
        
        <div id="stepCounter">Step 1 of 5</div>
        <div id="progressBar"><div id="progressIndicator"></div></div>
        
        <div id="stepIndicator">
            <div class="stepDot" data-step="0"></div>
            <div class="stepDot" data-step="1"></div>
            <div class="stepDot" data-step="2"></div>
            <div class="stepDot" data-step="3"></div>
            <div class="stepDot" data-step="4"></div>
            <div class="stepDot" data-step="5"></div>
            <div class="stepDot" data-step="6"></div>
        </div>
        
        <div id="controls">
            <button id="prevBtn">Previous</button>
            <button id="nextBtn">Next</button>
        </div>
        
        <div id="keyboardHint">Use Left/Right arrow keys to navigate</div>
        
        <div id="focusHighlight" class="highlight-circle"></div>
        <div id="contextHint"></div>
        <div id="transitionOverlay"></div>
    </div>

    <script>
        // Core elements
        const container = document.getElementById('container');
        const canvas = document.getElementById('animationCanvas');
        const ctx = canvas.getContext('2d');
        const stageTitle = document.getElementById('stageTitle');
        const explanation = document.getElementById('explanation');
        const formula = document.getElementById('formula');
        const stepCounter = document.getElementById('stepCounter');
        const progressIndicator = document.getElementById('progressIndicator');
        const prevBtn = document.getElementById('prevBtn');
        const nextBtn = document.getElementById('nextBtn');
        const radiusSlider = document.getElementById('radiusSlider');
        const sliderLabel = document.getElementById('sliderLabel');
        const focusHighlight = document.getElementById('focusHighlight');
        const contextHint = document.getElementById('contextHint');
        const transitionOverlay = document.getElementById('transitionOverlay');
        const stepDots = document.querySelectorAll('.stepDot');
        
        // State variables
        let currentStep = 0;
        const totalSteps = 7; // Updated with 2 new steps
        let animationFrameId = null;
        let time = 0;
        let dr = 20; // Initial change in radius - increased for better visibility
        
        // Set up progress tracking
        function updateProgress() {
            stepCounter.textContent = `Step ${currentStep + 1} of ${totalSteps}`;
            progressIndicator.style.width = `${(currentStep / (totalSteps - 1)) * 100}%`;
            
            // Update step dots
            stepDots.forEach(dot => {
                if (parseInt(dot.dataset.step) === currentStep) {
                    dot.classList.add('active');
                } else {
                    dot.classList.remove('active');
                }
            });
        }
        
        // Function to highlight areas of interest
        function highlightArea(x, y, size, duration = 2000) {
            focusHighlight.style.left = `${x}px`;
            focusHighlight.style.top = `${y}px`;
            focusHighlight.style.width = `${size}px`;
            focusHighlight.style.height = `${size}px`;
            focusHighlight.style.opacity = "1";
            
            setTimeout(() => {
                focusHighlight.style.opacity = "0";
            }, duration);
        }
        
        // Create a function for contextual hints
        function showHint(message, duration = 5000) {
            contextHint.textContent = message;
            contextHint.style.opacity = '1';
            
            setTimeout(() => {
                contextHint.style.opacity = '0';
            }, duration);
        }
        
        // Add step introduction feature with contextual hints
        function introduceStep() {
            const messages = [
                "Notice how the area changes when the radius grows",
                "See how the new area forms a ring around the original circle", 
                "Watch how the ring can be unwrapped into a rectangle",
                "The area of the rectangle equals the area of the ring",
                "Watch what happens as dr gets smaller and smaller",
                "Very small changes show the instantaneous rate of change",
                "The rate of area change equals the circumference"
            ];
            
            if (messages[currentStep]) {
                showHint(messages[currentStep]);
            }
        }
        
        // Colors
        const colors = {
            blue: '#3498db',
            purple: '#8e44ad',
            green: '#2ecc71',
            orange: '#e67e22',
            yellow: '#f1c40f',
            red: '#e74c3c',
            teal: '#1abc9c',
            white: '#ffffff',
            background: '#0f0f1f'
        };
        
        // Setup high-resolution canvas
        function setupCanvas() {
            const style = getComputedStyle(container);
            const width = parseInt(style.width);
            const height = parseInt(style.height);
            
            canvas.width = width;
            canvas.height = height;
            
            const dpr = window.devicePixelRatio || 1;
            canvas.width = width * dpr;
            canvas.height = height * dpr;
            ctx.scale(dpr, dpr);
            
            canvas.style.width = `${width}px`;
            canvas.style.height = `${height}px`;
        }
        
        window.addEventListener('load', setupCanvas);
        window.addEventListener('resize', setupCanvas);
        
        // Event listeners
        radiusSlider.addEventListener('input', function() {
            dr = parseInt(this.value);
            sliderLabel.textContent = `Change in radius (dr): ${dr} units`;
            render();
        });
        
        document.addEventListener('keydown', function(e) {
            if (e.key === 'ArrowRight' || e.key === ' ') {
                nextStep();
            } else if (e.key === 'ArrowLeft') {
                prevStep();
            }
        });
        
        prevBtn.addEventListener('click', prevStep);
        nextBtn.addEventListener('click', nextStep);
        
        // Helper functions
        function getCenter() {
            return {
                x: canvas.width / (2 * (window.devicePixelRatio || 1)),
                y: canvas.height / (2 * (window.devicePixelRatio || 1))
            };
        }
        
        function getBaseRadius() {
            const center = getCenter();
            return Math.min(center.x, center.y) * 0.4;
        }
        
        function clear() {
            const width = canvas.width / (window.devicePixelRatio || 1);
            const height = canvas.height / (window.devicePixelRatio || 1);
            
            ctx.fillStyle = colors.background;
            ctx.fillRect(0, 0, width, height);
            
            // Subtle grid
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
            ctx.lineWidth = 1;
            for (let x = 0; x < width; x += 40) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, height);
                ctx.stroke();
            }
            for (let y = 0; y < height; y += 40) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
            }
        }
        
        // Drawing functions
        function hexToRgba(hex, alpha = 1) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }
        
        function drawCircle(x, y, radius, color, fill = false, lineWidth = 2) {
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, Math.PI * 2);
            ctx.strokeStyle = color;
            ctx.lineWidth = lineWidth;
            ctx.stroke();
            if (fill) {
                ctx.fillStyle = color;
                ctx.fill();
            }
        }
        
        function fillCircle(x, y, radius, color, alpha = 1) {
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, Math.PI * 2);
            ctx.fillStyle = hexToRgba(color, alpha);
            ctx.fill();
        }
        
        function drawLine(x1, y1, x2, y2, color, lineWidth = 2, dashed = false) {
            ctx.beginPath();
            if (dashed) ctx.setLineDash([5, 3]);
            else ctx.setLineDash([]);
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.strokeStyle = color;
            ctx.lineWidth = lineWidth;
            ctx.stroke();
            ctx.setLineDash([]);
        }
        
        function drawText(text, x, y, color, size = 20, align = 'left') {
            ctx.fillStyle = color;
            ctx.font = `${size}px Arial`;
            ctx.textAlign = align;
            ctx.fillText(text, x, y);
        }
        
        function drawArrow(fromX, fromY, toX, toY, color, lineWidth = 2) {
            const headLength = 15;
            const angle = Math.atan2(toY - fromY, toX - fromX);
            
            // Line
            ctx.beginPath();
            ctx.moveTo(fromX, fromY);
            ctx.lineTo(toX, toY);
            ctx.strokeStyle = color;
            ctx.lineWidth = lineWidth;
            ctx.stroke();
            
            // Arrow head
            ctx.beginPath();
            ctx.moveTo(toX, toY);
            ctx.lineTo(toX - headLength * Math.cos(angle - Math.PI/6), 
                       toY - headLength * Math.sin(angle - Math.PI/6));
            ctx.lineTo(toX - headLength * Math.cos(angle + Math.PI/6), 
                       toY - headLength * Math.sin(angle + Math.PI/6));
            ctx.closePath();
            ctx.fillStyle = color;
            ctx.fill();
        }
        
        // Render steps with intuition-first approach
        function renderStep0() {
            clear();
            const center = getCenter();
            const baseRadius = getBaseRadius();
            
            // Animated growing circle
            const animPulse = (Math.sin(time) * 0.5 + 0.5);
            const pulseScale = 0.2;
            const pulseRadius = baseRadius * (1 + animPulse * pulseScale);
            
            // Circle with pulsing effect
            fillCircle(center.x, center.y, pulseRadius, colors.blue, 0.3);
            drawCircle(center.x, center.y, pulseRadius, colors.blue, false, 2);
            
            // Radius line
            drawLine(center.x, center.y, center.x + pulseRadius, center.y, colors.green, 2);
            
            // Radius label
            drawText("r", center.x + pulseRadius/2, center.y - 15, colors.green, 20, "center");
            
            // Text content
            stageTitle.textContent = "Watching a Circle Grow";
            explanation.innerHTML = "When a circle's radius changes, its area changes too.<br><br>Watch how the circle pulses as its radius grows and shrinks. What happens to the area?";
            
            // Hide formula initially
            formula.style.opacity = 0;
            toggleSlider(false);
        }
        
        function renderStep1() {
            clear();
            const center = getCenter();
            const baseRadius = getBaseRadius();
            
            // Original circle
            fillCircle(center.x, center.y, baseRadius, colors.blue, 0.3);
            drawCircle(center.x, center.y, baseRadius, colors.blue, false, 2);
            
            // Radius
            drawLine(center.x, center.y, center.x + baseRadius, center.y, colors.green, 2);
            drawText("r", center.x + baseRadius/2, center.y - 15, colors.green);
            
            // Expanded circle - with subtle pulse animation for emphasis
            const pulsingEffect = Math.sin(time * 2) * 0.5 + 0.5;
            const expandedRadius = baseRadius + dr;
            
            // Create a subtle glow around the expanded circle
            ctx.beginPath();
            ctx.arc(center.x, center.y, expandedRadius + 3 + pulsingEffect * 2, 0, Math.PI * 2);
            ctx.strokeStyle = hexToRgba(colors.orange, 0.3 * pulsingEffect);
            ctx.lineWidth = 3;
            ctx.stroke();
            
            // Draw the expanded circle
            drawCircle(center.x, center.y, expandedRadius, colors.orange, false, 2);
            
            // New radius
            const newRadiusX = center.x + baseRadius + dr;
            drawLine(center.x, center.y, newRadiusX, center.y, colors.orange, 2, true);
            
            drawText("r + dr", center.x + baseRadius + dr/2, center.y - 30, colors.orange);
            
            // Highlight the ring (donut) with fill - use pulsing alpha for emphasis
            const ringAlpha = 0.4 + 0.2 * pulsingEffect;
            ctx.beginPath();
            ctx.arc(center.x, center.y, expandedRadius, 0, Math.PI * 2);
            ctx.arc(center.x, center.y, baseRadius, 0, Math.PI * 2, true);
            ctx.closePath();
            ctx.fillStyle = hexToRgba(colors.orange, ringAlpha);
            ctx.fill();
            
            // Label the ring with arrow - animated
            const arrowBobbing = Math.sin(time * 3) * 3;
            drawArrow(
                center.x + baseRadius + 70, 
                center.y - 70 + arrowBobbing, 
                center.x + baseRadius + dr/2, 
                center.y - 40 + arrowBobbing/2, 
                colors.red, 2
            );
            drawText("New Area", center.x + baseRadius + 100, center.y - 80 + arrowBobbing, colors.red, 20, "center");
            
            // Text content
            stageTitle.textContent = "The 'Donut Ring' of New Area";
            explanation.innerHTML = "When a circle's radius increases by a small amount (dr), the area grows by adding a thin ring around the original circle.<br><br>This 'donut ring' is the key to understanding how circle area changes.";
            formula.style.opacity = 0;
            
            // Show slider with wobble effect
            toggleSlider(true, true);
            
            // Trigger visual highlighting of the donut ring periodically
            if (Math.abs(time % 8) < 0.05) {
                const containerRect = container.getBoundingClientRect();
                highlightArea(
                    containerRect.left + center.x - expandedRadius, 
                    containerRect.top + center.y - expandedRadius,
                    expandedRadius * 2,
                    1500
                );
            }
        }
        
        function renderStep2() {
            clear();
            const center = getCenter();
            const baseRadius = getBaseRadius();
            
            // Original circle
            fillCircle(center.x, center.y, baseRadius, colors.blue, 0.3);
            drawCircle(center.x, center.y, baseRadius, colors.blue, false, 2);
            
            // Expanded circle
            drawCircle(center.x, center.y, baseRadius + dr, colors.orange, false, 2);
            
            // Highlight the ring (donut)
            ctx.beginPath();
            ctx.arc(center.x, center.y, baseRadius + dr, 0, Math.PI * 2);
            ctx.arc(center.x, center.y, baseRadius, 0, Math.PI * 2, true);
            ctx.closePath();
            ctx.fillStyle = hexToRgba(colors.orange, 0.5);
            ctx.fill();
            
            // Position for the unwrapped strip
            const stripY = center.y + baseRadius * 0.8;
            const stripWidth = 2 * Math.PI * baseRadius; 
            const stripStartX = center.x - stripWidth / 2;
            const stripEndX = center.x + stripWidth / 2;
            const stripHeight = dr;
            
            // Create unwrapping animation
            let animProgress = (Math.sin(time * 1.5) + 1) / 2; // 0 to 1 value that oscillates
            
            // Draw imaginary segments unwrapping
            const segments = 12;
            const anglePer = Math.PI * 2 / segments;
            const segmentWidth = stripWidth / segments;
            
            for (let i = 0; i < segments; i++) {
                const startAngle = i * anglePer;
                const endAngle = (i + 1) * anglePer;
                
                // Calculate how "unwrapped" this segment is
                const unwrapFactor = Math.max(0, Math.min(1, (animProgress * segments * 1.2 - i)));
                
                // Draw segment in the circle if it's not fully unwrapped
                if (unwrapFactor < 1) {
                    ctx.beginPath();
                    ctx.arc(center.x, center.y, baseRadius + dr, startAngle, endAngle);
                    ctx.arc(center.x, center.y, baseRadius, endAngle, startAngle, true);
                    ctx.closePath();
                    ctx.fillStyle = hexToRgba(colors.yellow, 0.3 * (1 - unwrapFactor));
                    ctx.fill();
                }
                
                // Draw straightened segment if it's starting to unwrap
                const segX = stripStartX + i * segmentWidth;
                
                if (unwrapFactor > 0) {
                    ctx.beginPath();
                    ctx.rect(segX, stripY, segmentWidth, stripHeight);
                    ctx.fillStyle = hexToRgba(i % 2 === 0 ? colors.yellow : colors.orange, 0.5 * unwrapFactor);
                    ctx.fill();
                    
                    // Draw connection line for segments that are in the process of unwrapping
                    if (unwrapFactor > 0 && unwrapFactor < 1) {
                        const arcMidAngle = (startAngle + endAngle) / 2;
                        const arcX = center.x + Math.cos(arcMidAngle) * (baseRadius + dr/2);
                        const arcY = center.y + Math.sin(arcMidAngle) * (baseRadius + dr/2);
                        
                        ctx.beginPath();
                        ctx.moveTo(arcX, arcY);
                        ctx.lineTo(segX + segmentWidth/2, stripY + stripHeight/2);
                        ctx.strokeStyle = hexToRgba(colors.yellow, 0.4 * (1 - Math.abs(unwrapFactor - 0.5) * 2));
                        ctx.lineWidth = 1;
                        ctx.stroke();
                    }
                }
            }
            
            // Draw the completed strip outline
            ctx.beginPath();
            ctx.rect(stripStartX, stripY, stripWidth, stripHeight);
            ctx.strokeStyle = colors.orange;
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Label the dimensions
            // Label width
            drawText("Width = Circumference = 2πr", center.x, stripY - 15, colors.purple, 18, "center");
            
            // Label height
            drawText("Height = dr", stripEndX + 15, stripY + stripHeight/2, colors.green, 18, "left");
            
            // Draw unwrapping arrow - pulse with animation
            const arrowOpacity = 0.7 + 0.3 * Math.sin(time * 3);
            ctx.globalAlpha = arrowOpacity;
            drawArrow(center.x, center.y + 50, center.x, stripY - 20, colors.yellow, 2);
            drawText("Unwrapping", center.x + 20, center.y + 50, colors.yellow, 18, "left");
            ctx.globalAlpha = 1;
            
            // Text content
            stageTitle.textContent = "Unwrapping the Donut into a Strip";
            explanation.innerHTML = "Imagine 'unwrapping' our donut ring and straightening it out into a thin strip.<br><br>The length of this strip equals the circumference of the circle (2πr). The height of the strip equals our small change in radius (dr).";
            
            // Show formula
            formula.textContent = "Strip Area = Length × Height = 2πr × dr";
            formula.style.opacity = 1;
            
            // Show slider
            sliderContainer.style.opacity = 1;
            
            // Trigger visual highlighting for the unwrapping effect when this slide first appears
            if (Math.abs(time % 6) < 0.1) {
                const containerRect = container.getBoundingClientRect();
                highlightArea(
                    containerRect.left + center.x - baseRadius, 
                    containerRect.top + stripY - 20,
                    baseRadius * 2,
                    1500
                );
            }
        }
        
        function renderStep3() {
            clear();
            const center = getCenter();
            const baseRadius = getBaseRadius();
            
            // Position the strip higher on the screen to avoid being off-screen
            const stripY = center.y - baseRadius * 0.3; // Moved up more
            const stripWidth = 2 * Math.PI * baseRadius;
            const stripStartX = center.x - stripWidth / 2;
            const stripEndX = center.x + stripWidth / 2;
            const stripHeight = dr;
            
            // Show faded circle to remind where the strip came from - moved up significantly
            const fadeAmount = 0.15 + 0.05 * Math.sin(time * 1.5);
            const circleY = center.y + baseRadius * 0.3; // Moved up from 0.7
            
            ctx.beginPath();
            ctx.arc(center.x, circleY, baseRadius, 0, Math.PI * 2);
            ctx.strokeStyle = hexToRgba(colors.blue, fadeAmount);
            ctx.lineWidth = 1;
            ctx.stroke();
            
            ctx.beginPath();
            ctx.arc(center.x, circleY, baseRadius + dr, 0, Math.PI * 2);
            ctx.strokeStyle = hexToRgba(colors.orange, fadeAmount);
            ctx.lineWidth = 1;
            ctx.stroke();
            
            // Draw a subtle connection between the circle and strip
            ctx.beginPath();
            ctx.setLineDash([2, 4]);
            ctx.moveTo(center.x, circleY - baseRadius);
            ctx.lineTo(center.x, stripY + stripHeight);
            ctx.strokeStyle = hexToRgba(colors.yellow, 0.3);
            ctx.lineWidth = 1;
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Animate pieces moving from circle to the final strip
            const segments = 10;
            const anglePer = Math.PI * 2 / segments;
            const segmentWidth = stripWidth / segments;
            const slowAnimTime = time * 0.7; // Slower animation
            
            for (let i = 0; i < segments; i++) {
                const startAngle = i * anglePer;
                const endAngle = (i + 1) * anglePer;
                const segX = stripStartX + i * segmentWidth;
                
                // Oscillate the animation to continuously show motion
                const cyclePosition = ((slowAnimTime * 0.2) % 1);
                const animPhase = (i / segments + cyclePosition) % 1;
                
                // Calculate movement progress - positions pieces along the path from circle to strip
                const moveProgress = Math.max(0, Math.min(1, animPhase * 3));
                
                if (moveProgress < 1) {
                    // Get position on arc
                    const arcMidAngle = (startAngle + endAngle) / 2;
                    const arcX = center.x + Math.cos(arcMidAngle) * (baseRadius + dr/2);
                    const arcY = circleY + Math.sin(arcMidAngle) * (baseRadius + dr/2); // Using updated circle Y
                    
                    // Interpolate position from arc to final strip position
                    const currentX = arcX + (segX + segmentWidth/2 - arcX) * moveProgress;
                    const currentY = arcY + (stripY + stripHeight/2 - arcY) * moveProgress;
                    
                    // Draw fading segment
                    const opacity = 0.5 * (1 - moveProgress);
                    if (opacity > 0.05) {
                        // Draw a small segment that gets gradually straighter
                        ctx.beginPath();
                        const morphProgress = Math.min(1, moveProgress * 2);
                        const bendFactor = (1 - morphProgress) * 20;
                        
                        // Draw a curved rectangle morphing to a straight one
                        ctx.moveTo(currentX - segmentWidth/2, currentY - stripHeight/2);
                        ctx.quadraticCurveTo(
                            currentX, currentY - stripHeight/2 - bendFactor,
                            currentX + segmentWidth/2, currentY - stripHeight/2
                        );
                        ctx.lineTo(currentX + segmentWidth/2, currentY + stripHeight/2);
                        ctx.quadraticCurveTo(
                            currentX, currentY + stripHeight/2 + bendFactor,
                            currentX - segmentWidth/2, currentY + stripHeight/2
                        );
                        ctx.closePath();
                        
                        ctx.fillStyle = hexToRgba(i % 2 === 0 ? colors.yellow : colors.orange, opacity);
                        ctx.fill();
                    }
                }
            }
            
            // Draw the final strip
            ctx.beginPath();
            ctx.rect(stripStartX, stripY, stripWidth, stripHeight);
            ctx.fillStyle = hexToRgba(colors.orange, 0.5);
            ctx.fill();
            ctx.strokeStyle = colors.orange;
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Label dimensions with subtle animation
            const pulseText = 0.8 + 0.2 * Math.sin(time * 2);
            ctx.globalAlpha = pulseText;
            drawText("Length = 2πr", center.x, stripY - 15, colors.purple, 18, "center");
            drawText("dr", stripEndX + 15, stripY + stripHeight/2, colors.green, 18, "left");
            ctx.globalAlpha = 1;
            
            // Visual highlight on the strip that pulses
            const glowSize = 2 + Math.sin(time * 2) * 1;
            ctx.beginPath();
            ctx.rect(stripStartX, stripY, stripWidth, stripHeight);
            ctx.strokeStyle = colors.yellow;
            ctx.lineWidth = glowSize;
            ctx.stroke();
            
            // Area explanation - appears with a slight delay
            const areaStartY = stripY + stripHeight + 40;
            drawText("Area of the Strip = Length × Height", center.x, areaStartY, colors.blue, 20, "center");
            drawText("= 2πr × dr", center.x, areaStartY + 30, colors.blue, 20, "center");
            
            // Text content
            stageTitle.textContent = "The Area of Our Donut Ring";
            explanation.innerHTML = "The area of the donut ring equals the area of our unwrapped strip.<br><br>Simple geometry tells us that the area of a rectangle equals length × height. So the area of our strip (and therefore our donut) is:<br>2πr × dr";
            
            // Show formula
            formula.textContent = "Donut Area = 2πr × dr";
            formula.style.opacity = 1;
            
            // Show slider
            sliderContainer.style.opacity = 1;
            
            // Occasionally highlight the rectangle to emphasize its area
            if (Math.abs(time % 7) < 0.05) {
                const containerRect = container.getBoundingClientRect();
                const rectCenterX = containerRect.left + center.x;
                const rectCenterY = containerRect.top + stripY + stripHeight/2;
                highlightArea(
                    rectCenterX - stripWidth/2, 
                    rectCenterY - stripHeight/2,
                    stripWidth,
                    1500
                );
            }
        }
        
        function renderStep4() {
            clear();
            const center = getCenter();
            const baseRadius = getBaseRadius();
            
            // Animate dr shrinking
            const animPulse = (Math.sin(time * 0.7) * 0.5 + 0.5);
            const drProgress = 0.5 - animPulse * 0.3; // Smoothly varies between 0.2 and 0.5
            const visualDr = dr * drProgress;
            
            // Original circle
            fillCircle(center.x, center.y, baseRadius, colors.blue, 0.3);
            drawCircle(center.x, center.y, baseRadius, colors.blue, false, 2);
            
            // Expanded circle with animated size
            drawCircle(center.x, center.y, baseRadius + visualDr, colors.orange, false, 2);
            
            // Donut with animated size
            ctx.beginPath();
            ctx.arc(center.x, center.y, baseRadius + visualDr, 0, Math.PI * 2);
            ctx.arc(center.x, center.y, baseRadius, 0, Math.PI * 2, true);
            ctx.closePath();
            ctx.fillStyle = hexToRgba(colors.orange, 0.5);
            ctx.fill();
            
            // Show dr getting smaller - with animated value
            const drText = Math.max(1, Math.floor(dr * drProgress));
            drawText(`dr = ${drText}`, center.x + baseRadius + visualDr + 20, center.y, colors.orange, 20, "left");
            drawText("r", center.x + baseRadius/2, center.y - 15, colors.green);
            
            // Show corresponding rectangle
            const stripY = center.y + baseRadius * 0.5;
            const stripWidth = 2 * Math.PI * baseRadius;
            const stripStartX = center.x - stripWidth / 2;
            const stripHeight = visualDr; // Shrinking with dr
            
            // Draw the strip with animated height
            ctx.beginPath();
            ctx.rect(stripStartX, stripY, stripWidth, stripHeight);
            ctx.fillStyle = hexToRgba(colors.orange, 0.5);
            ctx.fill();
            ctx.strokeStyle = colors.orange;
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Draw an arrow showing the height shrinking
            const arrowStartY = stripY - 40;
            const arrowY = stripY - 15;
            drawArrow(center.x, arrowStartY, center.x, arrowY, colors.yellow, 2);
            drawText("dr getting smaller", center.x + 15, arrowStartY - 5, colors.yellow, 18, "left");
            
            // Text content
            stageTitle.textContent = "What Happens When dr Gets Smaller?";
            explanation.innerHTML = "Let's see what happens when we make dr smaller and smaller.<br><br>As dr gets smaller, our donut ring becomes thinner, but its formula stays the same: Area = 2πr × dr.<br><br>The smaller dr gets, the more precise our approximation becomes.";
            
            // Show formula
            formula.textContent = "Area of thin ring = 2πr × dr";
            formula.style.opacity = 1;
            
            // Hide slider
            sliderContainer.style.opacity = 0;
            
            // Occasionally highlight the shrinking dr
            if (Math.abs(time % 6) < 0.05) {
                const containerRect = container.getBoundingClientRect();
                highlightArea(
                    containerRect.left + center.x + baseRadius, 
                    containerRect.top + center.y - 10,
                    visualDr * 2,
                    1500
                );
            }
        }
        
        function renderStep5() {
            clear();
            const center = getCenter();
            const baseRadius = getBaseRadius();
            
            // Create an animation for the thin ring getting even thinner
            const animPulse = (Math.sin(time * 0.5) * 0.5 + 0.5);
            const drProgress = 0.15 - animPulse * 0.1; // Very small dr
            const visualDr = dr * drProgress;
            
            // Original circle
            fillCircle(center.x, center.y, baseRadius, colors.blue, 0.3);
            drawCircle(center.x, center.y, baseRadius, colors.blue, false, 2);
            
            // A very thin ring
            ctx.beginPath();
            ctx.arc(center.x, center.y, baseRadius + visualDr, 0, Math.PI * 2);
            ctx.arc(center.x, center.y, baseRadius, 0, Math.PI * 2, true);
            ctx.closePath();
            ctx.fillStyle = hexToRgba(colors.orange, 0.6);
            ctx.fill();
            
            // Draw an arrow pointing to the thin ring with explanatory text
            const ringArrowX = center.x + baseRadius * 0.7;
            const ringArrowY = center.y - baseRadius * 0.7;
            drawArrow(ringArrowX, ringArrowY, center.x + baseRadius, center.y, colors.red, 2);
            drawText("Very small dr", ringArrowX + 15, ringArrowY - 5, colors.red, 18, "left");
            
            // Draw the rate of change as the circumference of the circle
            ctx.beginPath();
            ctx.arc(center.x, center.y, baseRadius, 0, Math.PI * 2);
            ctx.setLineDash([5, 3]);
            ctx.strokeStyle = hexToRgba(colors.purple, 0.7 + 0.3 * animPulse);
            ctx.lineWidth = 3;
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Draw text explaining the circumference
            drawText("Circumference = 2πr", center.x, center.y - baseRadius - 25, colors.purple, 20, "center");
            
            // Text content
            stageTitle.textContent = "Rate of Change at a Point";
            explanation.innerHTML = "When we make dr extremely small (approaching zero), we're asking:<br><br>'At this exact radius, how quickly does the area change if we make a tiny increase in radius?'<br><br>This instantaneous rate of change equals the circumference of the circle (2πr).";
            
            // Show formula
            formula.innerHTML = "Rate of Area Change = 2πr<br><small>(This is the derivative of area with respect to radius)</small>";
            formula.style.opacity = 1;
            
            // Hide slider
            sliderContainer.style.opacity = 0;
        }
        
        function renderStep6() {
            clear();
            const center = getCenter();
            const baseRadius = getBaseRadius();
            
            // Draw a growing circle animation
            const animPulse = (Math.sin(time * 0.7) * 0.5 + 0.5);
            const pulseRadius = baseRadius * (1 - 0.3 * animPulse);
            
            // Draw the circle with animated radius
            fillCircle(center.x, center.y, pulseRadius, colors.blue, 0.3);
            drawCircle(center.x, center.y, pulseRadius, colors.blue, false, 2);
            
            // Draw pulsing circumference
            ctx.beginPath();
            ctx.arc(center.x, center.y, pulseRadius, 0, Math.PI * 2);
            ctx.setLineDash([5, 3]);
            ctx.strokeStyle = hexToRgba(colors.purple, 0.7 + 0.3 * animPulse);
            ctx.lineWidth = 3;
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Graph showing relationship
            const graphX = center.x + baseRadius * 0.9;
            const graphY = center.y + baseRadius * 0.3; // Moved higher
            const graphSize = baseRadius * 0.6;
            
            // Axes
            drawLine(graphX - graphSize/2, graphY, graphX + graphSize/2, graphY, colors.white, 1);
            drawLine(graphX, graphY - graphSize/2, graphX, graphY + graphSize/2, colors.white, 1);
            
            // Labels
            drawText("r", graphX + graphSize/2, graphY + 20, colors.green, 16, "center");
            drawText("Area", graphX - 10, graphY - graphSize/2, colors.blue, 16, "right");
            
            // Area curve (r²)
            ctx.beginPath();
            ctx.moveTo(graphX - graphSize/2, graphY);
            
            for (let i = 0; i <= graphSize; i++) {
                const x = i / graphSize - 0.5; // [-0.5, 0.5]
                const y = -(x * x) * graphSize * 0.8; // Parabola
                ctx.lineTo(graphX + i - graphSize/2, graphY + y);
            }
            
            ctx.strokeStyle = colors.blue;
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Animated dot moving along the curve
            const dotProgress = (animPulse * 0.8) + 0.1; // 0.1 to 0.9
            const dotX = graphX - graphSize/2 + graphSize * dotProgress;
            const xValue = dotProgress - 0.5; // -0.4 to 0.4
            const dotY = graphY - (xValue * xValue) * graphSize * 0.8;
            
            // Point on curve
            ctx.beginPath();
            ctx.arc(dotX, dotY, 4, 0, Math.PI * 2);
            ctx.fillStyle = colors.red;
            ctx.fill();
            
            // Tangent line at the point
            const slope = -2 * xValue * graphSize * 0.8;
            ctx.beginPath();
            ctx.moveTo(dotX - 20, dotY - slope * (-20/graphSize));
            ctx.lineTo(dotX + 20, dotY - slope * (20/graphSize));
            ctx.strokeStyle = colors.red;
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Draw a connection line between the circle and the graph
            ctx.beginPath();
            ctx.setLineDash([3, 3]);
            ctx.moveTo(center.x + pulseRadius, center.y);
            ctx.lineTo(dotX, dotY);
            ctx.strokeStyle = hexToRgba(colors.green, 0.4);
            ctx.lineWidth = 1;
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Label the relationship
            drawText("At any radius:", center.x, center.y + baseRadius * 0.7, colors.white, 20, "center");
            drawText("• Circle area = πr²", center.x, center.y + baseRadius * 0.7 + 30, colors.blue, 18, "center");
            drawText("• Rate of area change = 2πr", center.x, center.y + baseRadius * 0.7 + 60, colors.purple, 18, "center");
            drawText("• Rate = Circumference", center.x, center.y + baseRadius * 0.7 + 90, colors.red, 18, "center");
            
            // Text content
            stageTitle.textContent = "The Fundamental Relationship";
            explanation.innerHTML = "We've discovered something profound: at any radius, the rate at which a circle's area changes equals its circumference.<br><br>This relationship connects the circle's area (πr²) to its perimeter (2πr) in a beautiful way that we can understand visually, without needing complex math.";
            
            // Show formula
            formula.innerHTML = "Area = πr²<br>Rate of Change = 2πr";
            formula.style.opacity = 1;
            
            // Hide slider
            sliderContainer.style.opacity = 0;
        }
        
        // Navigation functions with smooth transitions
        function nextStep() {
            if (currentStep < totalSteps - 1) {
                // Transition effect
                transitionOverlay.style.opacity = "0.7";
                
                setTimeout(() => {
                    currentStep++;
                    updateProgress();
                    render();
                    
                    // Fade back in
                    setTimeout(() => {
                        transitionOverlay.style.opacity = "0";
                        // Show contextual hint for this step
                        setTimeout(introduceStep, 500);
                    }, 300);
                }, 400);
            }
        }
        
        function prevStep() {
            if (currentStep > 0) {
                // Transition effect
                transitionOverlay.style.opacity = "0.7";
                
                setTimeout(() => {
                    currentStep--;
                    updateProgress();
                    render();
                    
                    // Fade back in
                    setTimeout(() => {
                        transitionOverlay.style.opacity = "0";
                        // Show contextual hint for this step
                        setTimeout(introduceStep, 500);
                    }, 300);
                }, 400);
            }
        }
        
        // Function for consistent slider show/hide with animations
        function toggleSlider(show, wobble = true) {
            if (show) {
                sliderContainer.style.opacity = '1';
                if (wobble) {
                    sliderContainer.classList.add('wobble');
                } else {
                    sliderContainer.classList.remove('wobble');
                }
            } else {
                sliderContainer.style.opacity = '0';
                sliderContainer.classList.remove('wobble');
            }
        }
        
        // Render the current step
        function render() {
            switch(currentStep) {
                case 0: renderStep0(); break;
                case 1: renderStep1(); break;
                case 2: renderStep2(); break;
                case 3: renderStep3(); break;
                case 4: renderStep4(); break;
                case 5: renderStep5(); break;
                case 6: renderStep6(); break;
            }
        }
        
        // Animation loop - now animates for all steps except basic static ones
        function animate() {
            time += 0.02;
            
            // Animate subtle slider wobble on steps that use it
            if (sliderContainer.style.opacity !== '0') {
                // Animate the slider value slightly
                const sliderAnimation = (Math.sin(time * 0.5) * 0.5 + 0.5) * 0.1; // 0 to 0.1
                const baseValue = dr;
                
                // Only adjust visual appearance for hint, not actual value
                if (currentStep === 1 || currentStep === 2 || currentStep === 3) {
                    // Add subtle "breathing" animation to the thumb
                    const thumbSize = 20 + Math.sin(time) * 2;
                    document.documentElement.style.setProperty('--thumb-size', `${thumbSize}px`);
                }
            }
            
            // Animate all steps
            render();
            
            animationFrameId = requestAnimationFrame(animate);
        }
        
        // Set up the step dots for direct navigation
        stepDots.forEach(dot => {
            dot.addEventListener('click', () => {
                if (parseInt(dot.dataset.step) !== currentStep) {
                    // Transition effect
                    transitionOverlay.style.opacity = "0.7";
                    
                    setTimeout(() => {
                        currentStep = parseInt(dot.dataset.step);
                        updateProgress();
                        render();
                        
                        // Fade back in
                        setTimeout(() => {
                            transitionOverlay.style.opacity = "0";
                            // Show contextual hint for this step
                            setTimeout(introduceStep, 500);
                        }, 300);
                    }, 400);
                }
            });
        });
        
        // Initialize
        setupCanvas();
        updateProgress();
        render();
        animate();
        
        // Show the first hint after page load
        setTimeout(introduceStep, 1000);
    </script>
</body>
</html>