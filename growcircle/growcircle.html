<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Circle Growth Visualization</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #0f0f1f;
            color: white;
            font-family: sans-serif;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        
        #container {
            position: relative;
            width: min(900px, 95vw);
            height: min(600px, 95vh);
            border-radius: 12px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.3);
            overflow: hidden; /* Add this to contain the animation */
        }
        
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 12px;
        }
        
        #controls {
            position: absolute;
            bottom: 20px;
            left: 0;
            width: 100%;
            display: flex;
            justify-content: center;
            gap: 20px;
            z-index: 10;
        }
        
        button {
            background: #8d44ad;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s;
        }
        
        button:hover {
            background: #9b59b6;
            transform: translateY(-2px);
        }
        
        button:active {
            transform: translateY(1px);
        }
        
        #stageTitle {
            position: absolute;
            top: 20px;
            left: 0;
            width: 100%;
            text-align: center;
            font-size: min(24px, 5vw);
            font-weight: bold;
            transition: opacity 0.5s, transform 0.5s;
            z-index: 10;
            text-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
        
        #explanation {
            position: absolute;
            top: 60px;
            left: 50px;
            width: calc(100% - 100px);
            text-align: left;
            font-size: min(18px, 4vw);
            line-height: 1.5;
            transition: opacity 0.5s, transform 0.5s;
            z-index: 10;
            text-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
        
        #formula {
            position: absolute;
            bottom: 100px;
            left: 0;
            width: 100%;
            text-align: center;
            font-size: min(26px, 5vw);
            font-family: 'Times New Roman', serif;
            transition: opacity 0.5s;
            z-index: 10;
            opacity: 0;
        }
        
        #navigation {
            position: absolute;
            bottom: 70px;
            left: 0;
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            z-index: 10;
        }
        
        .navDot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            transition: all 0.3s;
            cursor: pointer;
        }
        
        .navDot.active {
            background: white;
            transform: scale(1.3);
        }
        
        #sliderContainer {
            position: absolute;
            bottom: 150px;
            left: 50%;
            transform: translateX(-50%);
            width: min(400px, 80%);
            text-align: center;
            z-index: 10;
            transition: opacity 0.5s;
        }
        
        #radiusSlider {
            width: 100%;
            margin-bottom: 10px;
            cursor: pointer;
            -webkit-appearance: none;
            height: 8px;
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.2);
        }
        
        #radiusSlider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #8d44ad;
            cursor: pointer;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
        }
        
        #radiusSlider::-webkit-slider-thumb:hover {
            transform: scale(1.1);
            background: #9b59b6;
        }
        
        #sliderLabel {
            font-size: min(16px, 3.5vw);
        }
        
        #keyboardHint {
            position: absolute;
            bottom: 15px;
            left: 0;
            width: 100%;
            text-align: center;
            font-size: 14px;
            color: rgba(255, 255, 255, 0.6);
            z-index: 10;
        }
        
        #stepCounter {
            position: absolute;
            bottom: 60px;
            width: 100%;
            text-align: center;
            font-size: 16px;
            z-index: 10;
        }
        
        #progressBar {
            position: absolute;
            bottom: 55px;
            left: 50%;
            transform: translateX(-50%);
            width: min(300px, 60%);
            height: 4px;
            background-color: #555;
            border-radius: 2px;
            z-index: 10;
        }
        
        #progressIndicator {
            height: 100%;
            background-color: #8d44ad;
            border-radius: 2px;
            width: 0%;
        }
        
        /* New animations and visual elements */
        .highlight-pulse {
            animation: pulsate 1.5s ease-in-out infinite;
        }
        
        @keyframes pulsate {
            0% { opacity: 0.5; }
            50% { opacity: 1; }
            100% { opacity: 0.5; }
        }
        
        @keyframes unwind {
            0% { 
                transform: rotate(0deg); 
                border-radius: 50%;
            }
            100% { 
                transform: rotate(360deg);
                border-radius: 0;
            }
        }
        
        .highlight-circle {
            position: absolute;
            border-radius: 50%;
            pointer-events: none;
            box-shadow: 0 0 0 4px rgba(255, 255, 255, 0.7);
            transition: all 0.5s ease;
            opacity: 0;
            z-index: 20;
        }
        
        #transitionOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #0f0f1f;
            opacity: 0;
            z-index: 15;
            pointer-events: none;
            transition: opacity 0.4s ease;
        }
        
        #contextHint {
            position: absolute;
            bottom: 120px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 15px;
            border-radius: 5px;
            font-size: 16px;
            opacity: 0;
            transition: opacity 0.5s ease;
            z-index: 20;
            max-width: 80%;
            text-align: center;
        }
        
        #stepIndicator {
            position: absolute;
            display: flex;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            gap: 12px;
            z-index: 20;
        }
        
        .stepDot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .stepDot.active {
            background: white;
            transform: scale(1.2);
        }
        
        .stepDot:hover {
            background: rgba(255, 255, 255, 0.7);
        }
    </style>
</head>
<body>
    <div id="container">
        <canvas id="animationCanvas"></canvas>
        
        <div id="stageTitle">Growing Circles: Understanding Area Change</div>
        
        <div id="explanation">
            What happens to a circle's area when its radius grows slightly?
            Let's explore this visually, building intuition before any formulas.
        </div>
        
        <div id="formula"></div>
        
        <div id="sliderContainer">
            <input type="range" id="radiusSlider" min="1" max="40" value="10">
            <div id="sliderLabel">Change in radius (dr): 10 units</div>
        </div>
        
        <div id="stepCounter">Step 1 of 5</div>
        <div id="progressBar"><div id="progressIndicator"></div></div>
        
        <div id="stepIndicator">
            <div class="stepDot" data-step="0"></div>
            <div class="stepDot" data-step="1"></div>
            <div class="stepDot" data-step="2"></div>
            <div class="stepDot" data-step="3"></div>
            <div class="stepDot" data-step="4"></div>
        </div>
        
        <div id="controls">
            <button id="prevBtn">Previous</button>
            <button id="nextBtn">Next</button>
        </div>
        
        <div id="keyboardHint">Use Left/Right arrow keys to navigate</div>
        
        <div id="focusHighlight" class="highlight-circle"></div>
        <div id="contextHint"></div>
        <div id="transitionOverlay"></div>
    </div>

    <script>
        // Core elements
        const container = document.getElementById('container');
        const canvas = document.getElementById('animationCanvas');
        const ctx = canvas.getContext('2d');
        const stageTitle = document.getElementById('stageTitle');
        const explanation = document.getElementById('explanation');
        const formula = document.getElementById('formula');
        const stepCounter = document.getElementById('stepCounter');
        const progressIndicator = document.getElementById('progressIndicator');
        const prevBtn = document.getElementById('prevBtn');
        const nextBtn = document.getElementById('nextBtn');
        const radiusSlider = document.getElementById('radiusSlider');
        const sliderLabel = document.getElementById('sliderLabel');
        const focusHighlight = document.getElementById('focusHighlight');
        const contextHint = document.getElementById('contextHint');
        const transitionOverlay = document.getElementById('transitionOverlay');
        const stepDots = document.querySelectorAll('.stepDot');
        
        // State variables
        let currentStep = 0;
        const totalSteps = 5;
        let animationFrameId = null;
        let time = 0;
        let dr = 10; // Initial change in radius
        
        // Set up progress tracking
        function updateProgress() {
            stepCounter.textContent = `Step ${currentStep + 1} of ${totalSteps}`;
            progressIndicator.style.width = `${(currentStep / (totalSteps - 1)) * 100}%`;
            
            // Update step dots
            stepDots.forEach(dot => {
                if (parseInt(dot.dataset.step) === currentStep) {
                    dot.classList.add('active');
                } else {
                    dot.classList.remove('active');
                }
            });
        }
        
        // Function to highlight areas of interest
        function highlightArea(x, y, size, duration = 2000) {
            focusHighlight.style.left = `${x}px`;
            focusHighlight.style.top = `${y}px`;
            focusHighlight.style.width = `${size}px`;
            focusHighlight.style.height = `${size}px`;
            focusHighlight.style.opacity = "1";
            
            setTimeout(() => {
                focusHighlight.style.opacity = "0";
            }, duration);
        }
        
        // Create a function for contextual hints
        function showHint(message, duration = 5000) {
            contextHint.textContent = message;
            contextHint.style.opacity = '1';
            
            setTimeout(() => {
                contextHint.style.opacity = '0';
            }, duration);
        }
        
        // Add step introduction feature with contextual hints
        function introduceStep() {
            const messages = [
                "Notice how the area changes when the radius grows",
                "See how the new area forms a ring around the original circle", 
                "Watch how the ring can be unwrapped into a rectangle",
                "The area of the rectangle equals the area of the ring",
                "As dr gets infinitely small, we get to the instantaneous rate of change"
            ];
            
            if (messages[currentStep]) {
                showHint(messages[currentStep]);
            }
        }
        
        // Colors
        const colors = {
            blue: '#3498db',
            purple: '#8e44ad',
            green: '#2ecc71',
            orange: '#e67e22',
            yellow: '#f1c40f',
            red: '#e74c3c',
            teal: '#1abc9c',
            white: '#ffffff',
            background: '#0f0f1f'
        };
        
        // Setup high-resolution canvas
        function setupCanvas() {
            const style = getComputedStyle(container);
            const width = parseInt(style.width);
            const height = parseInt(style.height);
            
            canvas.width = width;
            canvas.height = height;
            
            const dpr = window.devicePixelRatio || 1;
            canvas.width = width * dpr;
            canvas.height = height * dpr;
            ctx.scale(dpr, dpr);
            
            canvas.style.width = `${width}px`;
            canvas.style.height = `${height}px`;
        }
        
        window.addEventListener('load', setupCanvas);
        window.addEventListener('resize', setupCanvas);
        
        // Event listeners
        radiusSlider.addEventListener('input', function() {
            dr = parseInt(this.value);
            sliderLabel.textContent = `Change in radius (dr): ${dr} units`;
            render();
        });
        
        document.addEventListener('keydown', function(e) {
            if (e.key === 'ArrowRight' || e.key === ' ') {
                nextStep();
            } else if (e.key === 'ArrowLeft') {
                prevStep();
            }
        });
        
        prevBtn.addEventListener('click', prevStep);
        nextBtn.addEventListener('click', nextStep);
        
        // Helper functions
        function getCenter() {
            return {
                x: canvas.width / (2 * (window.devicePixelRatio || 1)),
                y: canvas.height / (2 * (window.devicePixelRatio || 1))
            };
        }
        
        function getBaseRadius() {
            const center = getCenter();
            return Math.min(center.x, center.y) * 0.4;
        }
        
        function clear() {
            const width = canvas.width / (window.devicePixelRatio || 1);
            const height = canvas.height / (window.devicePixelRatio || 1);
            
            ctx.fillStyle = colors.background;
            ctx.fillRect(0, 0, width, height);
            
            // Subtle grid
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
            ctx.lineWidth = 1;
            for (let x = 0; x < width; x += 40) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, height);
                ctx.stroke();
            }
            for (let y = 0; y < height; y += 40) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
            }
        }
        
        // Drawing functions
        function hexToRgba(hex, alpha = 1) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }
        
        function drawCircle(x, y, radius, color, fill = false, lineWidth = 2) {
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, Math.PI * 2);
            ctx.strokeStyle = color;
            ctx.lineWidth = lineWidth;
            ctx.stroke();
            if (fill) {
                ctx.fillStyle = color;
                ctx.fill();
            }
        }
        
        function fillCircle(x, y, radius, color, alpha = 1) {
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, Math.PI * 2);
            ctx.fillStyle = hexToRgba(color, alpha);
            ctx.fill();
        }
        
        function drawLine(x1, y1, x2, y2, color, lineWidth = 2, dashed = false) {
            ctx.beginPath();
            if (dashed) ctx.setLineDash([5, 3]);
            else ctx.setLineDash([]);
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.strokeStyle = color;
            ctx.lineWidth = lineWidth;
            ctx.stroke();
            ctx.setLineDash([]);
        }
        
        function drawText(text, x, y, color, size = 20, align = 'left') {
            ctx.fillStyle = color;
            ctx.font = `${size}px Arial`;
            ctx.textAlign = align;
            ctx.fillText(text, x, y);
        }
        
        function drawArrow(fromX, fromY, toX, toY, color, lineWidth = 2) {
            const headLength = 15;
            const angle = Math.atan2(toY - fromY, toX - fromX);
            
            // Line
            ctx.beginPath();
            ctx.moveTo(fromX, fromY);
            ctx.lineTo(toX, toY);
            ctx.strokeStyle = color;
            ctx.lineWidth = lineWidth;
            ctx.stroke();
            
            // Arrow head
            ctx.beginPath();
            ctx.moveTo(toX, toY);
            ctx.lineTo(toX - headLength * Math.cos(angle - Math.PI/6), 
                       toY - headLength * Math.sin(angle - Math.PI/6));
            ctx.lineTo(toX - headLength * Math.cos(angle + Math.PI/6), 
                       toY - headLength * Math.sin(angle + Math.PI/6));
            ctx.closePath();
            ctx.fillStyle = color;
            ctx.fill();
        }
        
        // Render steps with intuition-first approach
        function renderStep0() {
            clear();
            const center = getCenter();
            const baseRadius = getBaseRadius();
            
            // Animated growing circle
            const animPulse = (Math.sin(time) * 0.5 + 0.5);
            const pulseScale = 0.2;
            const pulseRadius = baseRadius * (1 + animPulse * pulseScale);
            
            // Circle with pulsing effect
            fillCircle(center.x, center.y, pulseRadius, colors.blue, 0.3);
            drawCircle(center.x, center.y, pulseRadius, colors.blue, false, 2);
            
            // Radius line
            drawLine(center.x, center.y, center.x + pulseRadius, center.y, colors.green, 2);
            
            // Radius label
            drawText("r", center.x + pulseRadius/2, center.y - 15, colors.green, 20, "center");
            
            // Text content
            stageTitle.textContent = "Watching a Circle Grow";
            explanation.innerHTML = "When a circle's radius changes, its area changes too.<br><br>Watch how the circle pulses as its radius grows and shrinks. What happens to the area?";
            
            // Hide formula initially
            formula.style.opacity = 0;
            sliderContainer.style.opacity = 0;
        }
        
        function renderStep1() {
            clear();
            const center = getCenter();
            const baseRadius = getBaseRadius();
            
            // Original circle
            fillCircle(center.x, center.y, baseRadius, colors.blue, 0.3);
            drawCircle(center.x, center.y, baseRadius, colors.blue, false, 2);
            
            // Radius
            drawLine(center.x, center.y, center.x + baseRadius, center.y, colors.green, 2);
            drawText("r", center.x + baseRadius/2, center.y - 15, colors.green);
            
            // Expanded circle - with subtle pulse animation for emphasis
            const pulsingEffect = Math.sin(time * 2) * 0.5 + 0.5;
            const expandedRadius = baseRadius + dr;
            
            // Create a subtle glow around the expanded circle
            ctx.beginPath();
            ctx.arc(center.x, center.y, expandedRadius + 3 + pulsingEffect * 2, 0, Math.PI * 2);
            ctx.strokeStyle = hexToRgba(colors.orange, 0.3 * pulsingEffect);
            ctx.lineWidth = 3;
            ctx.stroke();
            
            // Draw the expanded circle
            drawCircle(center.x, center.y, expandedRadius, colors.orange, false, 2);
            
            // New radius
            const newRadiusX = center.x + baseRadius + dr;
            drawLine(center.x, center.y, newRadiusX, center.y, colors.orange, 2, true);
            
            drawText("r + dr", center.x + baseRadius + dr/2, center.y - 30, colors.orange);
            
            // Highlight the ring (donut) with fill - use pulsing alpha for emphasis
            const ringAlpha = 0.4 + 0.2 * pulsingEffect;
            ctx.beginPath();
            ctx.arc(center.x, center.y, expandedRadius, 0, Math.PI * 2);
            ctx.arc(center.x, center.y, baseRadius, 0, Math.PI * 2, true);
            ctx.closePath();
            ctx.fillStyle = hexToRgba(colors.orange, ringAlpha);
            ctx.fill();
            
            // Label the ring with arrow - animated
            const arrowBobbing = Math.sin(time * 3) * 3;
            drawArrow(
                center.x + baseRadius + 70, 
                center.y - 70 + arrowBobbing, 
                center.x + baseRadius + dr/2, 
                center.y - 40 + arrowBobbing/2, 
                colors.red, 2
            );
            drawText("New Area", center.x + baseRadius + 100, center.y - 80 + arrowBobbing, colors.red, 20, "center");
            
            // Text content
            stageTitle.textContent = "The 'Donut Ring' of New Area";
            explanation.innerHTML = "When a circle's radius increases by a small amount (dr), the area grows by adding a thin ring around the original circle.<br><br>This 'donut ring' is the key to understanding how circle area changes.";
            formula.style.opacity = 0;
            
            // Show slider
            sliderContainer.style.opacity = 1;
            
            // Trigger visual highlighting of the donut ring periodically
            if (Math.abs(time % 8) < 0.05) {
                const containerRect = container.getBoundingClientRect();
                highlightArea(
                    containerRect.left + center.x - expandedRadius, 
                    containerRect.top + center.y - expandedRadius,
                    expandedRadius * 2,
                    1500
                );
            }
        }
        
        function renderStep2() {
            clear();
            const center = getCenter();
            const baseRadius = getBaseRadius();
            
            // Original circle
            fillCircle(center.x, center.y, baseRadius, colors.blue, 0.3);
            drawCircle(center.x, center.y, baseRadius, colors.blue, false, 2);
            
            // Expanded circle
            drawCircle(center.x, center.y, baseRadius + dr, colors.orange, false, 2);
            
            // Highlight the ring (donut)
            ctx.beginPath();
            ctx.arc(center.x, center.y, baseRadius + dr, 0, Math.PI * 2);
            ctx.arc(center.x, center.y, baseRadius, 0, Math.PI * 2, true);
            ctx.closePath();
            ctx.fillStyle = hexToRgba(colors.orange, 0.5);
            ctx.fill();
            
            // Position for the unwrapped strip
            const stripY = center.y + baseRadius * 0.8;
            const stripWidth = 2 * Math.PI * baseRadius; 
            const stripStartX = center.x - stripWidth / 2;
            const stripEndX = center.x + stripWidth / 2;
            const stripHeight = dr;
            
            // Create unwrapping animation
            let animProgress = (Math.sin(time * 1.5) + 1) / 2; // 0 to 1 value that oscillates
            
            // Draw imaginary segments unwrapping
            const segments = 12;
            const anglePer = Math.PI * 2 / segments;
            const segmentWidth = stripWidth / segments;
            
            for (let i = 0; i < segments; i++) {
                const startAngle = i * anglePer;
                const endAngle = (i + 1) * anglePer;
                
                // Calculate how "unwrapped" this segment is
                const unwrapFactor = Math.max(0, Math.min(1, (animProgress * segments * 1.2 - i)));
                
                // Draw segment in the circle if it's not fully unwrapped
                if (unwrapFactor < 1) {
                    ctx.beginPath();
                    ctx.arc(center.x, center.y, baseRadius + dr, startAngle, endAngle);
                    ctx.arc(center.x, center.y, baseRadius, endAngle, startAngle, true);
                    ctx.closePath();
                    ctx.fillStyle = hexToRgba(colors.yellow, 0.3 * (1 - unwrapFactor));
                    ctx.fill();
                }
                
                // Draw straightened segment if it's starting to unwrap
                const segX = stripStartX + i * segmentWidth;
                
                if (unwrapFactor > 0) {
                    ctx.beginPath();
                    ctx.rect(segX, stripY, segmentWidth, stripHeight);
                    ctx.fillStyle = hexToRgba(i % 2 === 0 ? colors.yellow : colors.orange, 0.5 * unwrapFactor);
                    ctx.fill();
                    
                    // Draw connection line for segments that are in the process of unwrapping
                    if (unwrapFactor > 0 && unwrapFactor < 1) {
                        const arcMidAngle = (startAngle + endAngle) / 2;
                        const arcX = center.x + Math.cos(arcMidAngle) * (baseRadius + dr/2);
                        const arcY = center.y + Math.sin(arcMidAngle) * (baseRadius + dr/2);
                        
                        ctx.beginPath();
                        ctx.moveTo(arcX, arcY);
                        ctx.lineTo(segX + segmentWidth/2, stripY + stripHeight/2);
                        ctx.strokeStyle = hexToRgba(colors.yellow, 0.4 * (1 - Math.abs(unwrapFactor - 0.5) * 2));
                        ctx.lineWidth = 1;
                        ctx.stroke();
                    }
                }
            }
            
            // Draw the completed strip outline
            ctx.beginPath();
            ctx.rect(stripStartX, stripY, stripWidth, stripHeight);
            ctx.strokeStyle = colors.orange;
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Label the dimensions
            // Label width
            drawText("Width = Circumference = 2πr", center.x, stripY - 15, colors.purple, 18, "center");
            
            // Label height
            drawText("Height = dr", stripEndX + 15, stripY + stripHeight/2, colors.green, 18, "left");
            
            // Draw unwrapping arrow - pulse with animation
            const arrowOpacity = 0.7 + 0.3 * Math.sin(time * 3);
            ctx.globalAlpha = arrowOpacity;
            drawArrow(center.x, center.y + 50, center.x, stripY - 20, colors.yellow, 2);
            drawText("Unwrapping", center.x + 20, center.y + 50, colors.yellow, 18, "left");
            ctx.globalAlpha = 1;
            
            // Text content
            stageTitle.textContent = "Unwrapping the Donut into a Strip";
            explanation.innerHTML = "Imagine 'unwrapping' our donut ring and straightening it out into a thin strip.<br><br>The length of this strip equals the circumference of the circle (2πr). The height of the strip equals our small change in radius (dr).";
            
            // Show formula
            formula.textContent = "Strip Area = Length × Height = 2πr × dr";
            formula.style.opacity = 1;
            
            // Show slider
            sliderContainer.style.opacity = 1;
            
            // Trigger visual highlighting for the unwrapping effect when this slide first appears
            if (Math.abs(time % 6) < 0.1) {
                const containerRect = container.getBoundingClientRect();
                highlightArea(
                    containerRect.left + center.x - baseRadius, 
                    containerRect.top + stripY - 20,
                    baseRadius * 2,
                    1500
                );
            }
        }
        
        function renderStep3() {
            clear();
            const center = getCenter();
            const baseRadius = getBaseRadius();
            
            // Draw the fully unwrapped strip
            const stripY = center.y;
            const stripWidth = 2 * Math.PI * baseRadius;
            const stripStartX = center.x - stripWidth / 2;
            const stripEndX = center.x + stripWidth / 2;
            const stripHeight = dr;
            
            // Draw the strip
            ctx.beginPath();
            ctx.rect(stripStartX, stripY, stripWidth, stripHeight);
            ctx.fillStyle = hexToRgba(colors.orange, 0.5);
            ctx.fill();
            ctx.strokeStyle = colors.orange;
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Label dimensions
            drawText("Length = 2πr", center.x, stripY - 15, colors.purple, 18, "center");
            drawText("dr", stripEndX + 15, stripY + stripHeight/2, colors.green, 18, "left");
            
            // Area explanation
            const areaStartY = stripY + stripHeight + 40;
            drawText("Area of the Strip = Length × Height", center.x, areaStartY, colors.blue, 20, "center");
            drawText("= 2πr × dr", center.x, areaStartY + 30, colors.blue, 20, "center");
            
            // Visual highlight
            ctx.beginPath();
            ctx.rect(stripStartX, stripY, stripWidth, stripHeight);
            ctx.strokeStyle = colors.yellow;
            ctx.lineWidth = 3;
            ctx.stroke();
            
            // Text content
            stageTitle.textContent = "The Area of Our Donut Ring";
            explanation.innerHTML = "The area of the donut ring equals the area of our unwrapped strip.<br><br>Simple geometry tells us that the area of a rectangle equals length × height. So the area of our strip (and therefore our donut) is:<br>2πr × dr";
            
            // Show formula
            formula.textContent = "Donut Area = 2πr × dr";
            formula.style.opacity = 1;
            
            // Show slider
            sliderContainer.style.opacity = 1;
        }
        
        function renderStep4() {
            clear();
            const center = getCenter();
            const baseRadius = getBaseRadius();
            
            // Show shrinking dr
            const drProgress = 0.2;
            const visualDr = dr * drProgress;
            
            // Original circle
            fillCircle(center.x, center.y, baseRadius, colors.blue, 0.3);
            drawCircle(center.x, center.y, baseRadius, colors.blue, false, 2);
            
            // Expanded circle
            drawCircle(center.x, center.y, baseRadius + visualDr, colors.orange, false, 2);
            
            // Donut
            ctx.beginPath();
            ctx.arc(center.x, center.y, baseRadius + visualDr, 0, Math.PI * 2);
            ctx.arc(center.x, center.y, baseRadius, 0, Math.PI * 2, true);
            ctx.closePath();
            ctx.fillStyle = hexToRgba(colors.orange, 0.5);
            ctx.fill();
            
            // Show dr getting smaller
            const drText = Math.max(1, Math.floor(dr * drProgress));
            drawText(`dr = ${drText}`, center.x + baseRadius + visualDr + 20, center.y, colors.orange, 20, "left");
            drawText("r", center.x + baseRadius/2, center.y - 15, colors.green);
            
            // Graph
            const graphX = center.x + baseRadius * 0.9;
            const graphY = center.y + baseRadius * 0.6;
            const graphSize = baseRadius * 0.7;
            
            // Axes
            drawLine(graphX - graphSize/2, graphY, graphX + graphSize/2, graphY, colors.white, 1);
            drawLine(graphX, graphY - graphSize/2, graphX, graphY + graphSize/2, colors.white, 1);
            
            // Labels
            drawText("r", graphX + graphSize/2, graphY + 20, colors.green, 16, "center");
            drawText("Area", graphX - 10, graphY - graphSize/2, colors.blue, 16, "right");
            
            // Area curve (r²)
            ctx.beginPath();
            ctx.moveTo(graphX - graphSize/2, graphY);
            
            for (let i = 0; i <= graphSize; i++) {
                const x = i / graphSize - 0.5; // [-0.5, 0.5]
                const y = -(x * x) * graphSize * 0.8; // Parabola
                ctx.lineTo(graphX + i - graphSize/2, graphY + y);
            }
            
            ctx.strokeStyle = colors.blue;
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Tangent line at a point
            const touchX = graphX + graphSize * 0.3;
            const touchR = (touchX - (graphX - graphSize/2)) / graphSize - 0.5;
            const touchY = graphY - (touchR * touchR) * graphSize * 0.8;
            
            // Point on curve
            ctx.beginPath();
            ctx.arc(touchX, touchY, 4, 0, Math.PI * 2);
            ctx.fillStyle = colors.red;
            ctx.fill();
            
            // Tangent line
            const slope = -2 * touchR * graphSize * 0.8;
            ctx.beginPath();
            ctx.moveTo(touchX - 30, touchY - slope * (-30/graphSize));
            ctx.lineTo(touchX + 30, touchY - slope * (30/graphSize));
            ctx.strokeStyle = colors.red;
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Label slope
            drawText("Slope = 2πr", touchX + 35, touchY - 20, colors.red, 16, "left");
            
            // Text content
            stageTitle.textContent = "The Circle's Rate of Area Change";
            explanation.innerHTML = "As our change in radius (dr) gets smaller and smaller, our approximation gets more and more accurate.<br><br>In the limit as dr approaches zero, we've found the <i>instantaneous rate of change</i> of area with respect to radius. This rate equals the circumference (2πr).";
            
            // Show formula
            formula.innerHTML = "Rate of Area Change = 2πr<br><small>(In calculus: dA/dr = 2πr)</small>";
            formula.style.opacity = 1;
            
            // Fade out slider
            sliderContainer.style.opacity = 0;
        }
        
        // Navigation functions with smooth transitions
        function nextStep() {
            if (currentStep < totalSteps - 1) {
                // Transition effect
                transitionOverlay.style.opacity = "0.7";
                
                setTimeout(() => {
                    currentStep++;
                    updateProgress();
                    render();
                    
                    // Fade back in
                    setTimeout(() => {
                        transitionOverlay.style.opacity = "0";
                        // Show contextual hint for this step
                        setTimeout(introduceStep, 500);
                    }, 300);
                }, 400);
            }
        }
        
        function prevStep() {
            if (currentStep > 0) {
                // Transition effect
                transitionOverlay.style.opacity = "0.7";
                
                setTimeout(() => {
                    currentStep--;
                    updateProgress();
                    render();
                    
                    // Fade back in
                    setTimeout(() => {
                        transitionOverlay.style.opacity = "0";
                        // Show contextual hint for this step
                        setTimeout(introduceStep, 500);
                    }, 300);
                }, 400);
            }
        }
        
        // Render the current step
        function render() {
            switch(currentStep) {
                case 0: renderStep0(); break;
                case 1: renderStep1(); break;
                case 2: renderStep2(); break;
                case 3: renderStep3(); break;
                case 4: renderStep4(); break;
            }
        }
        
        // Animation loop - now animates for steps 0, 2, and 4
        function animate() {
            time += 0.02;
            
            // Animate steps that have dynamic content
            if (currentStep === 0 || currentStep === 2 || currentStep === 4) {
                render();
            }
            
            animationFrameId = requestAnimationFrame(animate);
        }
        
        // Set up the step dots for direct navigation
        stepDots.forEach(dot => {
            dot.addEventListener('click', () => {
                if (parseInt(dot.dataset.step) !== currentStep) {
                    // Transition effect
                    transitionOverlay.style.opacity = "0.7";
                    
                    setTimeout(() => {
                        currentStep = parseInt(dot.dataset.step);
                        updateProgress();
                        render();
                        
                        // Fade back in
                        setTimeout(() => {
                            transitionOverlay.style.opacity = "0";
                            // Show contextual hint for this step
                            setTimeout(introduceStep, 500);
                        }, 300);
                    }, 400);
                }
            });
        });
        
        // Initialize
        setupCanvas();
        updateProgress();
        render();
        animate();
        
        // Show the first hint after page load
        setTimeout(introduceStep, 1000);
    </script>
</body>
</html>