<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Fluid Dynamics Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: none;
        }
        body {
            overflow: hidden;
            background-color: #000;
            width: 100vw;
            height: 100vh;
            position: fixed;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            touch-action: none;
        }
        #score {
            position: absolute;
            top: 20px;
            left: 0;
            width: 100%;
            text-align: center;
            color: #00ffaa;
            font-family: Arial, sans-serif;
            font-size: 24px;
            text-shadow: 0 0 10px rgba(0, 255, 170, 0.8);
            z-index: 10;
            pointer-events: none;
            transition: color 0.3s;
        }
        #score.negative {
            color: #ff3366;
            text-shadow: 0 0 10px rgba(255, 51, 102, 0.8);
        }
        #targets {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        .target {
            position: absolute;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }
        .target.good {
            border: 3px solid rgba(0, 255, 170, 0.8);
            box-shadow: 0 0 15px rgba(0, 255, 170, 0.7);
            animation: pulseGood 1.5s infinite alternate;
        }
        .target.bad {
            border: 3px solid rgba(255, 51, 102, 0.8);
            box-shadow: 0 0 15px rgba(255, 51, 102, 0.7);
            animation: pulseBad 1.5s infinite alternate;
        }
        
        @keyframes pulseGood {
            0% { box-shadow: 0 0 10px rgba(0, 255, 170, 0.7); }
            100% { box-shadow: 0 0 20px rgba(0, 255, 170, 0.9); }
        }
        
        @keyframes pulseBad {
            0% { box-shadow: 0 0 10px rgba(255, 51, 102, 0.7); }
            100% { box-shadow: 0 0 20px rgba(255, 51, 102, 0.9); }
        }
        
        #instructions {
            position: absolute;
            bottom: 20px;
            left: 0;
            width: 100%;
            text-align: center;
            color: #00ffaa;
            font-family: Arial, sans-serif;
            font-size: 16px;
            text-shadow: 0 0 8px rgba(0, 255, 170, 0.6);
            z-index: 10;
            pointer-events: none;
            padding: 0 20px;
        }
        
        #audio-toggle {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #00ffaa;
            color: #00ffaa;
            font-family: Arial, sans-serif;
            padding: 5px 10px;
            border-radius: 20px;
            z-index: 20;
            cursor: pointer;
        }
        
        /* Control Panel Styles */
        #control-panel-toggle {
            position: absolute;
            top: 70px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid #00ffaa;
            color: #00ffaa;
            font-family: Arial, sans-serif;
            padding: 5px 10px;
            border-radius: 20px;
            z-index: 21;
            cursor: pointer;
            font-size: 14px;
        }
        
        #control-panel {
            position: absolute;
            top: 110px;
            right: 20px;
            width: 280px;
            background: rgba(0, 0, 0, 0.85);
            border: 1px solid #00ffaa;
            border-radius: 10px;
            padding: 15px;
            color: white;
            font-family: Arial, sans-serif;
            font-size: 12px;
            z-index: 20;
            max-height: 80vh;
            overflow-y: auto;
            display: none;
            transform-origin: top right;
            transition: transform 0.3s, opacity 0.3s;
            transform: scale(0.95);
            opacity: 0;
        }
        
        #control-panel.visible {
            display: block;
            transform: scale(1);
            opacity: 1;
        }
        
        .control-section {
            margin-bottom: 15px;
            border-bottom: 1px solid rgba(0, 255, 170, 0.3);
            padding-bottom: 10px;
        }
        
        .control-section h3 {
            color: #00ffaa;
            margin: 0 0 10px 0;
            font-size: 14px;
        }
        
        .control-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 6px 0;
        }
        
        .control-label {
            flex: 1;
        }
        
        .control-input {
            flex: 1;
        }
        
        /* Sliders and inputs */
        .control-panel input[type="range"] {
            width: 100%;
            background: #333;
            height: 6px;
            -webkit-appearance: none;
            border-radius: 3px;
            outline: none;
        }
        
        .control-panel input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 12px;
            height: 12px;
            background: #00ffaa;
            border-radius: 50%;
            cursor: pointer;
        }
        
        .control-panel input[type="checkbox"] {
            -webkit-appearance: none;
            width: 30px;
            height: 16px;
            background: #333;
            border-radius: 10px;
            position: relative;
            outline: none;
            cursor: pointer;
        }
        
        .control-panel input[type="checkbox"]:checked {
            background: #00ffaa;
        }
        
        .control-panel input[type="checkbox"]:before {
            content: '';
            position: absolute;
            width: 14px;
            height: 14px;
            background: #ddd;
            border-radius: 50%;
            top: 1px;
            left: 1px;
            transition: 0.3s;
        }
        
        .control-panel input[type="checkbox"]:checked:before {
            left: 15px;
        }
        
        .parameter-value {
            display: inline-block;
            width: 30px;
            text-align: right;
            font-size: 11px;
            color: #ccc;
            margin-left: 8px;
        }
        
        /* Only show control panel on desktop */
        @media (max-width: 768px) {
            #control-panel-toggle {
                display: none;
            }
        }
    </style>
</head>
<body>
    <div id="score">Score: 0</div>
    <div id="targets"></div>
    <div id="instructions">
        On mobile: Use both thumbs to bend the fluid streams.<br>
        On desktop: Click and drag with your mouse or click directly on targets.<br>
        Catch green targets, but avoid red ones!
    </div>
    <button id="audio-toggle">üîä Click to Enable Audio</button>
    <button id="control-panel-toggle">‚öôÔ∏è Controls</button>
    <div id="control-panel" class="control-panel">
        <div class="control-section">
            <h3>Tendril Effects</h3>
            <div class="control-row">
                <label class="control-label">Enable Tendrils</label>
                <div class="control-input">
                    <input type="checkbox" id="enable-tendrils" checked>
                </div>
            </div>
            <div class="control-row">
                <label class="control-label">Thickness <span id="tendril-thickness-value" class="parameter-value">1.0</span></label>
                <div class="control-input">
                    <input type="range" id="tendril-thickness" min="0.1" max="2.0" step="0.1" value="1.0">
                </div>
            </div>
            <div class="control-row">
                <label class="control-label">Turbulence <span id="tendril-turbulence-value" class="parameter-value">1.0</span></label>
                <div class="control-input">
                    <input type="range" id="tendril-turbulence" min="0.1" max="2.0" step="0.1" value="1.0">
                </div>
            </div>
            <div class="control-row">
                <label class="control-label">Glow Intensity <span id="tendril-glow-value" class="parameter-value">1.0</span></label>
                <div class="control-input">
                    <input type="range" id="tendril-glow" min="0" max="2.0" step="0.1" value="1.0">
                </div>
            </div>
        </div>
        
        <div class="control-section">
            <h3>Fluid Dynamics</h3>
            <div class="control-row">
                <label class="control-label">Intensity <span id="fluid-intensity-value" class="parameter-value">1.0</span></label>
                <div class="control-input">
                    <input type="range" id="fluid-intensity" min="0.1" max="2.0" step="0.1" value="1.0">
                </div>
            </div>
            <div class="control-row">
                <label class="control-label">Background Effects</label>
                <div class="control-input">
                    <input type="checkbox" id="enable-background" checked>
                </div>
            </div>
        </div>
        
        <div class="control-section">
            <h3>Shockwave Effects</h3>
            <div class="control-row">
                <label class="control-label">Enable Shockwaves</label>
                <div class="control-input">
                    <input type="checkbox" id="enable-shockwaves" checked>
                </div>
            </div>
            <div class="control-row">
                <label class="control-label">Intensity <span id="shockwave-intensity-value" class="parameter-value">1.0</span></label>
                <div class="control-input">
                    <input type="range" id="shockwave-intensity" min="0" max="2.0" step="0.1" value="1.0">
                </div>
            </div>
        </div>
        
        <div class="control-section">
            <h3>Gameplay</h3>
            <div class="control-row">
                <label class="control-label">Target Generation Rate <span id="target-rate-value" class="parameter-value">1.0</span></label>
                <div class="control-input">
                    <input type="range" id="target-rate" min="0.2" max="2.0" step="0.1" value="1.0">
                </div>
            </div>
            <div class="control-row">
                <label class="control-label">Target Lifespan <span id="target-lifespan-value" class="parameter-value">5s</span></label>
                <div class="control-input">
                    <input type="range" id="target-lifespan" min="2" max="10" step="0.5" value="5">
                </div>
            </div>
        </div>
        
        <div class="control-section">
            <h3>Performance</h3>
            <div class="control-row">
                <label class="control-label">Quality Preset</label>
                <div class="control-input">
                    <select id="quality-preset">
                        <option value="high">High</option>
                        <option value="medium" selected>Medium</option>
                        <option value="low">Low</option>
                    </select>
                </div>
            </div>
            <div class="control-row">
                <label class="control-label">Fluid Iterations <span id="fluid-iterations-value" class="parameter-value">12</span></label>
                <div class="control-input">
                    <input type="range" id="fluid-iterations" min="4" max="16" step="1" value="12">
                </div>
            </div>
        </div>
    </div>
    <canvas id="canvas"></canvas>

    <script>
        /*
         * =============================================================================
         * THUMBWAR FLUID DYNAMICS GAME
         * =============================================================================
         * 
         * A WebGL-powered fluid dynamics game where players use touch or mouse 
         * to manipulate flowing streams of energy. Players must collect green targets
         * while avoiding red ones, creating beautiful visual effects through 
         * multi-touch interaction.
         * 
         * CORE ARCHITECTURE:
         * - WebGL fragment shader handles all visual effects (fluid dynamics, tendrils, shockwaves)
         * - JavaScript manages game logic, input handling, and WebGL uniform updates
         * - Real-time control panel allows tweaking of visual and gameplay parameters
         * - Multi-platform support: touch on mobile, mouse on desktop
         * 
         * VISUAL EFFECTS SYSTEMS:
         * 1. Fluid Dynamics: Iterative flow simulation with swirling patterns
         * 2. Tendril Effects: Organic energy beams connecting touch points
         * 3. Shockwave Effects: Expanding rings when targets are collected
         * 4. Background Energy: Subtle animated field providing atmosphere
         * 
         * GAMEPLAY MECHANICS:
         * - Score +10 for collecting green targets, -15 for red targets
         * - Bonus +1 every second when both thumbs/touches are active
         * - Penalty -3 when thumbs get too close together
         * - Tendril energy beams can also hit targets for +5/-5 points
         */

        // =============================================================================
        // GAME VARIABLES & CONSTANTS
        // =============================================================================
        
        // Core Game State
        let score = 0;                      // Player's current score
        const MAX_TARGETS = 4;              // Maximum number of targets on screen simultaneously
        let targetLifespan = 5000;          // How long targets remain active (milliseconds)
        let targets = [];                   // Array of active target objects
        let shockwaves = [];                // Array of expanding ring effects when targets collected
        let audioEnabled = true;            // Whether sound effects are enabled
        let lastScoreChange = 0;            // Timestamp of last score change (for UI animation)
        let scoreDirection = 1;             // Direction of last score change: 1=positive, -1=negative
        
        // Multi-Touch Game Rules & Mechanics
        let bothThumbsActive = false;       // True when player has 2+ touches active
        let thumbsClosePenaltyActive = false; // Prevents rapid-fire penalties when thumbs too close
        let lastActiveScoreTime = 0;        // Timestamp for last bonus point from active play
        
        // Tunable Gameplay Constants
        // These values control game balance and can be adjusted for difficulty
        let THUMBS_TOO_CLOSE_THRESHOLD = 0.2;      // Distance below which thumbs are "too close" (normalized 0-1)
        let BOTH_THUMBS_ACTIVE_SCORE_INTERVAL = 1000; // Milliseconds between bonus points for keeping both thumbs active
        
        // =============================================================================
        // VISUAL EFFECTS CONTROL SETTINGS
        // =============================================================================
        
        // Effect control variables - these settings are adjustable via the control panel
        // and directly affect how the WebGL shaders render visual effects
        let gameSettings = {
            // Tendril Effect Controls
            // Tendrils are the energy beams that connect the two touch points
            enableTendrils: true,           // Master switch for tendril visibility
            tendrilThickness: 1.0,          // Base thickness multiplier (0.1-2.0)
            tendrilTurbulence: 1.0,         // Amount of swirling/organic movement (0.1-2.0) 
            tendrilGlow: 1.0,               // Intensity of glow effect around tendrils (0-2.0)
            
            // Fluid Dynamics Controls
            // These affect the background flowing energy patterns
            fluidIntensity: 1.0,            // Overall strength of fluid simulation (0.1-2.0)
            enableBackground: true,         // Whether to show background energy field
            
            // Shockwave Effect Controls  
            // Shockwaves are expanding rings when targets are collected
            enableShockwaves: true,         // Master switch for shockwave effects
            shockwaveIntensity: 1.0,        // Strength of shockwave visual impact (0-2.0)
            
            // Gameplay Timing Controls
            targetGenerationRate: 1.0,      // How quickly new targets spawn (0.2-2.0)
            targetLifespan: 5.0,            // How long targets stay active in seconds (2-10)
            
            // Performance & Quality Controls
            qualityPreset: 'medium',        // Overall quality: 'low', 'medium', 'high'
            fluidIterations: 12             // Number of fluid simulation iterations per frame (4-16)
                                           // Higher = more complex patterns but slower performance
        };
        
        // =============================================================================
        // CONTROL PANEL SETUP & EVENT HANDLING
        // =============================================================================
        
        // The control panel provides real-time adjustment of visual effects and gameplay
        // parameters. All changes immediately update the gameSettings object which
        // is passed to WebGL shaders as uniforms each frame.
        
        // Control Panel Logic
        const controlPanelToggle = document.getElementById('control-panel-toggle');
        const controlPanel = document.getElementById('control-panel');
        
        // Toggle control panel visibility with smooth animation
        controlPanelToggle.addEventListener('click', () => {
            controlPanel.classList.toggle('visible');
        });
        
        // Setup control panel listeners
        // Each control immediately updates the corresponding gameSettings value
        // which is then passed to the shader as a uniform in the render loop
        function setupControlPanel() {
            // TENDRIL CONTROLS
            // These affect the organic energy beams connecting touch points
            
            // Master switch for tendril visibility
            document.getElementById('enable-tendrils').addEventListener('change', e => {
                gameSettings.enableTendrils = e.target.checked;
            });
            
            // Tendril thickness: affects base width of energy beams
            // Lower values = thinner, more delicate tendrils
            // Higher values = thicker, more prominent energy streams
            document.getElementById('tendril-thickness').addEventListener('input', e => {
                gameSettings.tendrilThickness = parseFloat(e.target.value);
                document.getElementById('tendril-thickness-value').textContent = e.target.value;
            });
            
            // Tendril turbulence: controls amount of swirling/organic movement
            // Lower values = straighter, more stable beams
            // Higher values = more chaotic, swirling patterns
            document.getElementById('tendril-turbulence').addEventListener('input', e => {
                gameSettings.tendrilTurbulence = parseFloat(e.target.value);
                document.getElementById('tendril-turbulence-value').textContent = e.target.value;
            });
            
            // Tendril glow: intensity of soft halo effect around energy beams
            // 0 = no glow, sharp edges
            // Higher values = more diffuse, magical appearance
            document.getElementById('tendril-glow').addEventListener('input', e => {
                gameSettings.tendrilGlow = parseFloat(e.target.value);
                document.getElementById('tendril-glow-value').textContent = e.target.value;
            });
            
            // FLUID DYNAMICS CONTROLS
            // These affect the background flowing energy patterns
            
            // Overall intensity of fluid simulation
            // Controls how prominent the swirling background effects are
            document.getElementById('fluid-intensity').addEventListener('input', e => {
                gameSettings.fluidIntensity = parseFloat(e.target.value);
                document.getElementById('fluid-intensity-value').textContent = e.target.value;
            });
            
            // Background energy field toggle
            // When disabled, only touch-triggered effects are visible
            document.getElementById('enable-background').addEventListener('change', e => {
                gameSettings.enableBackground = e.target.checked;
            });
            
            // SHOCKWAVE CONTROLS
            // Shockwaves are expanding ring effects when targets are collected
            
            // Master switch for shockwave visibility
            document.getElementById('enable-shockwaves').addEventListener('change', e => {
                gameSettings.enableShockwaves = e.target.checked;
            });
            
            // Shockwave intensity: controls visual impact of expanding rings
            // Lower values = subtle, gentle waves
            // Higher values = dramatic, screen-filling effects
            document.getElementById('shockwave-intensity').addEventListener('input', e => {
                gameSettings.shockwaveIntensity = parseFloat(e.target.value);
                document.getElementById('shockwave-intensity-value').textContent = e.target.value;
            });
            
            // GAMEPLAY CONTROLS
            // These affect timing and difficulty of the game
            
            // Target generation rate: how quickly new targets appear
            // Lower values = slower, easier gameplay
            // Higher values = faster, more challenging gameplay
            document.getElementById('target-rate').addEventListener('input', e => {
                gameSettings.targetGenerationRate = parseFloat(e.target.value);
                document.getElementById('target-rate-value').textContent = e.target.value;
            });
            
            // Target lifespan: how long targets remain active before disappearing
            // Shorter = more pressure, requires quick reactions
            // Longer = more relaxed, strategic gameplay
            document.getElementById('target-lifespan').addEventListener('input', e => {
                gameSettings.targetLifespan = parseFloat(e.target.value);
                targetLifespan = gameSettings.targetLifespan * 1000; // convert to milliseconds
                document.getElementById('target-lifespan-value').textContent = e.target.value + 's';
            });
            
            // PERFORMANCE CONTROLS
            // These balance visual quality vs. framerate
            
            // Quality preset: applies predefined settings for different performance levels
            document.getElementById('quality-preset').addEventListener('change', e => {
                gameSettings.qualityPreset = e.target.value;
                applyQualityPreset(e.target.value);
            });
            
            // Fluid iterations: number of simulation steps per frame
            // Lower = simpler patterns, better performance
            // Higher = more complex, detailed flow patterns
            document.getElementById('fluid-iterations').addEventListener('input', e => {
                gameSettings.fluidIterations = parseInt(e.target.value);
                document.getElementById('fluid-iterations-value').textContent = e.target.value;
            });
        }
        
        // =============================================================================
        // PERFORMANCE PRESET SYSTEM
        // =============================================================================
        
        // Apply performance presets that balance visual quality with framerate
        // Each preset adjusts the fluid simulation complexity
        function applyQualityPreset(preset) {
            const iterationsSlider = document.getElementById('fluid-iterations');
            
            switch(preset) {
                case 'high':
                    // Maximum visual quality: 15 fluid iterations per frame
                    // Best for powerful devices, may cause framerate drops on mobile
                    gameSettings.fluidIterations = 15;
                    iterationsSlider.value = 15;
                    document.getElementById('fluid-iterations-value').textContent = '15';
                    break;
                case 'medium':
                    // Balanced quality: 12 fluid iterations per frame  
                    // Good compromise for most devices
                    gameSettings.fluidIterations = 12;
                    iterationsSlider.value = 12;
                    document.getElementById('fluid-iterations-value').textContent = '12';
                    break;
                case 'low':
                    // Performance mode: 8 fluid iterations per frame
                    // Simpler patterns but smooth framerate on slower devices
                    gameSettings.fluidIterations = 8;
                    iterationsSlider.value = 8;
                    document.getElementById('fluid-iterations-value').textContent = '8';
                    break;
            }
        }
        
        // Initialize control panel event listeners
        setupControlPanel();
        
        // =============================================================================
        // AUDIO SYSTEM & SOUND EFFECTS
        // =============================================================================
        
        // Web Audio API setup for procedural sound generation
        // All sounds are synthesized in real-time for consistency across platforms
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        // Audio toggle button handling
        // Modern browsers require user interaction before playing audio
        const audioToggle = document.getElementById('audio-toggle');
        let audioInitialized = false;
        
        audioToggle.addEventListener('click', function() {
            // First click always enables audio (browser policy compliance)
            if (!audioInitialized) {
                audioEnabled = true;
                audioInitialized = true;
                this.textContent = 'üîä On';
                
                // Resume audio context if suspended by browser policy
                if (audioContext.state === 'suspended') {
                    audioContext.resume();
                }
                
                // Play a brief test tone to confirm audio is working
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                gain.gain.value = 0.2;
                osc.frequency.value = 440; // A4 note (standard tuning reference)
                osc.connect(gain);
                gain.connect(audioContext.destination);
                osc.start();
                osc.stop(audioContext.currentTime + 0.1);
                
                // Show user feedback that audio is now enabled
                const audioAlert = document.createElement('div');
                audioAlert.textContent = 'Audio enabled! üîä';
                audioAlert.style.position = 'absolute';
                audioAlert.style.top = '70px';
                audioAlert.style.left = '0';
                audioAlert.style.width = '100%';
                audioAlert.style.textAlign = 'center';
                audioAlert.style.color = '#00ffaa';
                audioAlert.style.fontFamily = 'Arial, sans-serif';
                audioAlert.style.fontSize = '18px';
                audioAlert.style.zIndex = '20';
                audioAlert.style.pointerEvents = 'none';
                document.body.appendChild(audioAlert);
                
                // Remove the alert after 2 seconds
                setTimeout(() => {
                    audioAlert.remove();
                }, 2000);
            } else {
                // After initialization, button toggles audio on/off
                audioEnabled = !audioEnabled;
                this.textContent = audioEnabled ? 'üîä On' : 'üîá Off';
            }
            
            // Resume audio context if it was suspended (browser policy)
            if (audioEnabled && audioContext.state === 'suspended') {
                audioContext.resume();
            }
        });
        
        // =============================================================================
        // PROCEDURAL SOUND GENERATION
        // =============================================================================
        
        // Creates a pleasant ascending arpeggio for positive events (collecting good targets)
        // Uses pure sine waves for a clean, magical sound
        function createCollectSound() {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            // Generate major arpeggio: A4 ‚Üí C#5 ‚Üí E5 (A major chord)
            // These frequencies create a harmonious, uplifting sound
            oscillator.type = 'sine';
            oscillator.frequency.setValueAtTime(440, audioContext.currentTime);        // A4 (440 Hz)
            oscillator.frequency.setValueAtTime(554.37, audioContext.currentTime + 0.1); // C#5
            oscillator.frequency.setValueAtTime(659.25, audioContext.currentTime + 0.2); // E5
            
            // Envelope: quick attack, moderate decay for musical phrasing
            gainNode.gain.setValueAtTime(0, audioContext.currentTime);
            gainNode.gain.linearRampToValueAtTime(0.3, audioContext.currentTime + 0.05);
            gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.3);
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.start();
            oscillator.stop(audioContext.currentTime + 0.3);
        }
        
        // Creates a harsh, descending sound for negative events (hitting bad targets)
        // Uses sawtooth wave and distortion for an unpleasant, warning-like effect
        function createBadSound() {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            const distortion = audioContext.createWaveShaper();
            
            // Create waveshaper distortion curve for harsh, aggressive sound
            function makeDistortionCurve(amount) {
                const k = typeof amount === 'number' ? amount : 50;
                const n_samples = 44100;
                const curve = new Float32Array(n_samples);
                for (let i = 0; i < n_samples; ++i) {
                    const x = i * 2 / n_samples - 1;
                    // Mathematical distortion function creates harsh harmonics
                    curve[i] = (3 + k) * x * 20 * (Math.PI / 180) / (Math.PI + k * Math.abs(x));
                }
                return curve;
            }
            
            distortion.curve = makeDistortionCurve(400); // Heavy distortion
            
            // Descending sawtooth: 300Hz ‚Üí 150Hz creates falling, unpleasant effect
            oscillator.type = 'sawtooth'; // Rich in harsh harmonics
            oscillator.frequency.setValueAtTime(300, audioContext.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(150, audioContext.currentTime + 0.3);
            
            // Longer envelope for more persistent warning effect
            gainNode.gain.setValueAtTime(0, audioContext.currentTime);
            gainNode.gain.linearRampToValueAtTime(0.3, audioContext.currentTime + 0.05);
            gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.4);
            
            oscillator.connect(distortion);
            distortion.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.start();
            oscillator.stop(audioContext.currentTime + 0.4);
        }
        
        // =============================================================================
        // HAPTIC FEEDBACK SYSTEM
        // =============================================================================
        
        // Provides tactile feedback on mobile devices through vibration patterns
        // Different patterns help distinguish between positive and negative events
        function vibrate(pattern) {
            if (navigator.vibrate) {
                navigator.vibrate(pattern);
            }
        }
        
        // =============================================================================
        // WEBGL SETUP & CANVAS MANAGEMENT
        // =============================================================================
        
        // Initialize WebGL context for hardware-accelerated graphics
        // All visual effects are rendered using GPU shaders for optimal performance
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
        
        if (!gl) {
            alert('WebGL not supported');
        }
        
        // Handle canvas resizing to maintain full-screen coverage
        // Called on window resize and initial setup
        function resize() {
            const displayWidth = canvas.clientWidth;
            const displayHeight = canvas.clientHeight;
            
            // Only update if size actually changed (performance optimization)
            if (canvas.width !== displayWidth || canvas.height !== displayHeight) {
                canvas.width = displayWidth;
                canvas.height = displayHeight;
                gl.viewport(0, 0, canvas.width, canvas.height);
            }
        }
        
        window.addEventListener('resize', resize);
        resize(); // Initial sizing
        
        // =============================================================================
        // WEBGL SHADERS
        // =============================================================================
        
        // Simple vertex shader: transforms screen coordinates for fragment shader
        // Uses a full-screen quad to cover the entire canvas
        const vertexShaderSource = `
            attribute vec2 a_position;
            void main() {
                gl_Position = vec4(a_position, 0, 1);
            }
        `;
        
        // FRAGMENT SHADER: Contains all visual effect algorithms
        // This is where the magic happens - fluid dynamics, tendrils, and shockwaves
        // are all computed in parallel on the GPU for each pixel
        const fragmentShaderSource = `
            precision highp float;
            
            // Core uniforms for rendering
            uniform vec2 u_resolution;       // Canvas size in pixels
            uniform float u_time;            // Current time for animations
            uniform vec2 u_touch1;           // First touch/mouse position (0-1 range)
            uniform vec2 u_touch2;           // Second touch position (0-1 range)
            
            // Target rendering uniforms (for game objectives)
            uniform vec2 u_targets[${MAX_TARGETS}];      // Target positions
            uniform float u_target_active[${MAX_TARGETS}]; // Whether each target is active
            uniform float u_target_type[${MAX_TARGETS}];   // 0 = good (green), 1 = bad (red)
            
            // Shockwave effect uniforms (expanding rings when targets collected)
            uniform float u_shockwave_active[${MAX_TARGETS}];   // Whether shockwave is active
            uniform vec2 u_shockwave_pos[${MAX_TARGETS}];       // Shockwave center position
            uniform float u_shockwave_start[${MAX_TARGETS}];    // Time when shockwave started
            uniform float u_shockwave_type[${MAX_TARGETS}];     // 0 = good, 1 = bad
            
            // Control panel uniforms (allow real-time effect adjustment)
            uniform float u_fluid_intensity;     // Overall fluid simulation strength
            uniform float u_enable_background;   // Whether to show background energy field
            uniform float u_enable_tendrils;     // Whether to show tendril effects
            uniform float u_tendril_thickness;   // Base thickness of energy beams
            uniform float u_tendril_turbulence;  // Amount of swirling motion
            uniform float u_tendril_glow;        // Intensity of glow effect
            uniform float u_enable_shockwaves;   // Whether to show shockwave effects
            uniform float u_shockwave_intensity; // Strength of shockwave visuals
            
            // =============================================================================
            // TENDRIL EFFECT ALGORITHM
            // =============================================================================
            
            // Creates organic, swirling energy beams between two points using layered sine waves
            // This function generates the complex mathematical patterns for tendril effects
            // Parameters:
            //   p: current pixel position being evaluated
            //   start: starting point of tendril
            //   end: ending point of tendril  
            //   time: current animation time
            //   thickness: base thickness of the tendril
            //   turbulence: amount of swirling/organic movement
            float swirlTendril(vec2 p, vec2 start, vec2 end, float time, float thickness, float turbulence) {
                // Calculate base vector and distance between start and end points
                vec2 direction = end - start;
                float distance = length(direction);
                direction = normalize(direction);
                
                // Calculate perpendicular vector for lateral displacement
                vec2 perpendicular = vec2(-direction.y, direction.x);
                
                // Project current pixel onto the line between start and end
                float t = clamp(dot(p - start, direction) / distance, 0.0, 1.0);
                vec2 projection = start + direction * t * distance;
                
                // LAYERED SINE WAVE SYSTEM for organic flow patterns
                // Each layer adds different frequency components to create complex, natural-looking curves
                
                float swirl = 0.0;
                
                // LAYER 1: Base Flow - Large, slow undulations forming the primary shape
                // Low frequency (2 cycles along tendril) with slow time evolution
                float baseFlow = sin(t * 3.14159 * 2.0 + time * 0.7) * 0.04 * turbulence;
                
                // LAYER 2: Medium Ripples - Mid-frequency oscillations adding character
                // 5 cycles along tendril with faster time changes for secondary motion
                float mediumRipples = sin(t * 3.14159 * 5.0 + time * 1.2) * 0.025 * turbulence;
                
                // LAYER 3: Micro-Movement - High frequency details for fine texture
                // 12 cycles with rapid time evolution for "electrical" appearance
                float microMovement = sin(t * 3.14159 * 12.0 + time * 2.5) * 0.01 * turbulence;
                
                // LAYER 4: Detail Noise - Very high frequency for surface texture
                // 25 cycles creating fine-grain detail at pixel level
                float detailNoise = sin(t * 3.14159 * 25.0 + time * 4.0) * 0.005 * turbulence;
                
                // LAYER 5: Spiral Component - Creates helical twisting motion
                // Combines sine and cosine for circular motion around main axis
                float spiral = sin(t * 3.14159 * 3.0 + time * 0.5) * cos(t * 3.14159 * 2.0 + time * 0.3) * 0.02 * turbulence;
                
                // TEMPORAL VARIATION: Makes the entire tendril shape evolve over time
                // These create slow morphing of the overall tendril structure
                float timeWave1 = sin(time * 0.3) * 0.01;           // Very slow global shift
                float timeWave2 = cos(time * 0.5 + t) * 0.01;       // Position-dependent time variation
                
                // ENDPOINT EFFECTS: Creates more natural connection at start/end points
                // Reduces oscillation near endpoints for smoother attachment
                float endpointEffect = (1.0 - pow(abs(2.0 * t - 1.0), 0.5)) * 0.01;
                
                // COMBINE ALL LAYERS: Weighted sum creates complex, organic patterns
                // Each layer contributes different frequency components like harmonic overtones
                swirl = baseFlow + mediumRipples + microMovement + detailNoise + spiral + timeWave1 + timeWave2 + endpointEffect;
                
                // GLOBAL PULSING: Makes entire tendril breathe/pulse subtly
                // Creates impression of living energy flowing through the beam
                float tendrilPulse = 0.9 + 0.1 * sin(time * 0.8 + t * 2.0);
                swirl *= tendrilPulse;
                
                // DYNAMIC THICKNESS: Varies width along tendril length
                // Creates more interesting, organic shapes rather than uniform thickness
                float thicknessVariation = 0.8 + 0.2 * sin(t * 8.0 + time * 1.5);
                float effectiveThickness = thickness * thicknessVariation;
                
                // TAPER EFFECT: Makes tendril thinner toward middle for stretched appearance
                // sin(t * œÄ) creates 0 at endpoints, 1 at center, giving natural taper
                effectiveThickness *= 0.7 + 0.3 * sin(t * 3.14159);
                
                // APPLY DISPLACEMENT: Move pixels perpendicular to main tendril axis
                vec2 offset = perpendicular * swirl;
                
                // SECONDARY AXIS DISPLACEMENT: Adds motion along the tendril direction
                // Creates more complex 3D-like motion in 2D space
                vec2 secondary = vec2(direction.x, direction.y);
                offset += secondary * sin(t * 3.14159 * 4.0 + time * 0.9) * 0.01;
                
                // DISTANCE CALCULATION: How far is current pixel from the displaced path?
                float distortedDistance = length(p - (projection + offset));
                
                // SMOOTH FALLOFF: Creates soft edges using smoothstep function
                // Inner edge = effectiveThickness * 0.2 (full intensity)
                // Outer edge = effectiveThickness (zero intensity)
                return smoothstep(effectiveThickness, effectiveThickness * 0.2, distortedDistance);
            }
            
            // =============================================================================
            // FLUID DYNAMICS ALGORITHM
            // =============================================================================
            
            // Main fluid simulation function creating swirling energy patterns
            // Uses iterative flow calculations to simulate complex fluid behavior
            vec4 fluidEffect(vec2 uv, float time, vec2 touch1, vec2 touch2) {
                vec4 o = vec4(0.01);  // Accumulator for flow calculations
                vec2 r = u_resolution;
                vec2 p = (gl_FragCoord.xy * 2.0 - r) / r.y;  // Normalized pixel coordinates
                
                // Start with pure black background
                vec4 backgroundColor = vec4(0.0, 0.0, 0.0, 1.0);
                
                // TOUCH INFLUENCE CALCULATION
                // Calculate distance from current pixel to each touch point
                float t1 = length(p - touch1) * 1.1;  // Touch 1 influence radius
                float t2 = length(p - touch2) * 1.1;  // Touch 2 influence radius
                
                // DYNAMIC FLOW VECTORS
                // Create time-varying flow directions for chaotic swirling motion
                // These vectors control the direction of energy flow around touch points
                vec2 flowVec1 = vec2(
                    sin(time * 0.7) * 0.4 + sin(time * 1.5) * 0.3,    // X component with dual frequencies
                    cos(time * 0.5) * 0.4 + cos(time * 1.7) * 0.3     // Y component, different frequencies
                );
                vec2 flowVec2 = vec2(
                    sin(time * 0.5 + 2.0) * 0.4 + sin(time * 1.3) * 0.3,  // Offset phase for variety
                    cos(time * 0.6 + 1.0) * 0.4 + cos(time * 1.9) * 0.3
                );
                
                // ENERGY TRAIL SYSTEM
                // Create multiple trailing points for each touch to simulate flowing energy streams
                // Each trail point has different offset and intensity for layered effect
                vec2 trailPos1 = touch1 + flowVec1;
                vec2 trailPos2 = touch2 + flowVec2;
                
                // Generate multiple trail distances with different intensities
                // This creates the illusion of energy flowing away from touch points
                float t1a = length(p - (touch1 + flowVec1 * 0.3)) * 1.3;  // Close trail
                float t1b = length(p - (touch1 + flowVec1 * 0.6)) * 1.4;  // Medium trail  
                float t1c = length(p - (touch1 + flowVec1 * 0.9)) * 1.5;  // Far trail
                float t1d = length(p - (touch1 + flowVec1 * 1.2)) * 1.6;  // Distant trail
                float t1e = length(p - (touch1 + flowVec1 * 1.5)) * 1.7;  // Very distant
                float t1f = length(p - (touch1 + vec2(sin(time*2.3), cos(time*2.1)) * 0.7)) * 1.5; // Chaotic trail
                
                // Same trail system for second touch point
                float t2a = length(p - (touch2 + flowVec2 * 0.3)) * 1.3;
                float t2b = length(p - (touch2 + flowVec2 * 0.6)) * 1.4;
                float t2c = length(p - (touch2 + flowVec2 * 0.9)) * 1.5;
                float t2d = length(p - (touch2 + flowVec2 * 1.2)) * 1.6;
                float t2e = length(p - (touch2 + flowVec2 * 1.5)) * 1.7;
                float t2f = length(p - (touch2 + vec2(cos(time*2.5), sin(time*1.9)) * 0.7)) * 1.5;
                
                // COMBINED TOUCH INFLUENCE
                // Find minimum distance to any trail point = strongest influence
                float touchEffect = min(
                    min(min(min(t1, t1a), min(t1b, t1c)), min(min(t1d, t1e), t1f)),
                    min(min(min(t2, t2a), min(t2b, t2c)), min(min(t2d, t2e), t2f))
                );
                touchEffect = clamp(touchEffect, 0.06, 1.0); // Prevent extreme values
                
                // FLUID VECTOR FIELD CALCULATION
                // This is the core of the fluid simulation - creates flowing patterns
                vec2 l = vec2(0.0);  // Initialize length accumulator
                vec2 v = p * (1.0 - (l += abs(0.7 - dot(p, p)))) / (max(0.05, touchEffect * 0.1));
                
                // CURL/VORTICITY FIELD
                // Creates swirling motion by adding rotational components to flow
                vec2 curl = vec2(
                    sin(p.y * 5.0 + time) * cos(p.x * 4.0 - time * 0.7) + sin(p.y * 8.0 - time * 1.3) * 0.3,
                    cos(p.x * 5.0 - time) * sin(p.y * 4.0 + time * 0.7) + cos(p.x * 8.0 + time * 1.3) * 0.3
                ) * 0.25;
                
                v += curl; // Add rotational motion to base flow
                
                // TURBULENCE INJECTION
                // Add fine-scale chaotic motion for visual complexity
                v.x += 0.2 * sin(v.y * 4.0 + time * 0.9) * cos(v.x * 3.0);
                v.y += 0.2 * cos(v.x * 4.0 - time * 0.8) * sin(v.y * 3.0);
                
                // ITERATIVE FLOW SIMULATION
                // This loop performs the actual fluid dynamics calculation
                // Each iteration adds more complexity and detail to the flow patterns
                for(float i = 0.0; i < 12.0; i++) { // Fixed loop for WebGL 1.0 compatibility
                    float ii = i + 1.0;
                    
                    // DYNAMIC OFFSET CALCULATION
                    // Creates time-varying flow patterns with different scales
                    vec2 offset = vec2(
                        sin(time * 0.4 + ii * 0.2 + sin(time)) * 0.6,
                        cos(time * 0.3 + ii * 0.2 + cos(time)) * 0.6
                    );
                    
                    // WARPING FUNCTION
                    // Creates fire-like, organic movement patterns
                    vec2 warp = vec2(
                        sin(v.x * 2.0 + time * 0.6) * 0.3 + sin(v.x * 5.0 - time * 0.3) * 0.1,
                        cos(v.y * 2.0 + time * 0.5) * 0.3 + cos(v.y * 5.0 - time * 0.2) * 0.1
                    );
                    
                    // ITERATIVE UPDATE
                    // Core fluid equation: each iteration builds upon the previous
                    v += cos(v.yx * ii * 0.7 + offset + time * 0.8) / (ii * 0.4) + warp + 0.6;
                    
                    // INTENSITY MODULATION
                    // Creates flickering, flame-like effects with multiple frequencies
                    float flicker = 0.8 + sin(time * 5.0 + ii) * 0.2 + sin(time * 9.0 + ii * 0.7) * 0.1;
                    o += (sin(v.xyyx * 1.8 + time * 0.4) + 1.0) * abs(v.x - v.y) * 0.3 * flicker;
                }
                
                // =============================================================================
                // COLOR MAPPING & VISUAL RENDERING
                // =============================================================================
                
                // INTENSITY CALCULATION
                // Convert flow simulation output to visual intensity
                float intensity = clamp(o.x + o.y + o.z + o.w, 0.1, 4.0);
                float factor = exp(-1.8 * l.x) / intensity * 2.0;
                
                // PROCEDURAL TEXTURE NOISE
                // High-frequency noise patterns add detail to touch point cores
                float noise1 = sin(p.x * 30.0 + time) * sin(p.y * 30.0 + time * 1.2) * 0.5 + 0.5;
                float noise2 = sin(p.x * 20.0 - time * 1.3) * sin(p.y * 20.0 + time) * 0.5 + 0.5;
                
                // AURORA-STYLE BACKGROUND COLORS
                // Creates northern lights effect from fluid simulation data
                // Uses flow vectors to modulate RGB channels for organic color variation
                vec4 auroraColor = vec4(
                    0.5 * (1.0 + sin(v.x * 3.0 + time * 0.4 + noise1 * 0.5)),  // Red: flow-dependent
                    0.8 * (1.0 + sin(v.y * 2.0 + time * 0.5 + noise2 * 0.7)),  // Green: dominant channel
                    0.7 * (1.0 + sin(v.x * v.y + time * 0.6 + noise1 * noise2)), // Blue: interaction-based
                    1.0
                );
                
                // DYNAMIC TOUCH POINT COLORS
                // Each touch point gets unique, time-varying colors for visual distinction
                vec4 core1Color = vec4(
                    0.1 + 0.4 * sin(time * 2.0),           // Pulsing red component
                    0.9 + 0.3 * sin(time * 2.5 + 2.0),     // Dominant green with phase offset
                    0.6 + 0.4 * sin(time * 3.0 + 4.0),     // Pulsing blue component
                    1.0
                );
                
                vec4 core2Color = vec4(
                    0.2 + 0.4 * sin(time * 2.2 + 1.0),     // Red with different frequency
                    0.3 + 0.3 * sin(time * 2.7 + 3.0),     // Moderate green
                    0.9 + 0.3 * sin(time * 3.2 + 5.0),     // Dominant blue with phase offset
                    1.0
                );
                
                // DISTANCE-BASED INTENSITY CALCULATION
                // Creates smooth falloff from touch points using power functions
                // Higher powers = sharper falloff, more concentrated energy
                float coreFactor1 = 4.0 * pow(1.0 - min(1.0, t1 * 0.8), 5.0);  // Sharp core
                float coreFactor2 = 4.0 * pow(1.0 - min(1.0, t2 * 0.8), 5.0);
                
                // TRAIL INTENSITY FACTORS
                // Each trail point has decreasing intensity for layered flow effect
                float trailFactor1 = 3.0 * pow(1.0 - min(1.0, t1 * 0.9), 4.0);      // Primary trail
                float trailFactor1a = 2.5 * pow(1.0 - min(1.0, t1a * 0.9), 4.0) * 0.7; // Secondary trails
                float trailFactor1b = 2.0 * pow(1.0 - min(1.0, t1b * 0.9), 4.0) * 0.5; // with decreasing
                float trailFactor1c = 1.5 * pow(1.0 - min(1.0, t1c * 0.9), 4.0) * 0.4; // intensity
                float trailFactor1d = 1.2 * pow(1.0 - min(1.0, t1d * 0.9), 4.0) * 0.3;
                float trailFactor1e = 1.0 * pow(1.0 - min(1.0, t1e * 0.9), 4.0) * 0.2;
                float trailFactor1f = 2.0 * pow(1.0 - min(1.0, t1f * 0.9), 4.0) * 0.6; // Chaotic trail
                
                // Same intensity system for second touch point
                float trailFactor2 = 3.0 * pow(1.0 - min(1.0, t2 * 0.9), 4.0);
                float trailFactor2a = 2.5 * pow(1.0 - min(1.0, t2a * 0.9), 4.0) * 0.7;
                float trailFactor2b = 2.0 * pow(1.0 - min(1.0, t2b * 0.9), 4.0) * 0.5;
                float trailFactor2c = 1.5 * pow(1.0 - min(1.0, t2c * 0.9), 4.0) * 0.4;
                float trailFactor2d = 1.2 * pow(1.0 - min(1.0, t2d * 0.9), 4.0) * 0.3;
                float trailFactor2e = 1.0 * pow(1.0 - min(1.0, t2e * 0.9), 4.0) * 0.2;
                float trailFactor2f = 2.0 * pow(1.0 - min(1.0, t2f * 0.9), 4.0) * 0.6;
                
                // TOUCH POINT CORE RENDERING
                // Mix base colors with dynamic colors using noise for texture
                vec4 coreTouch1 = mix(
                    vec4(0.0, 0.9, 0.5, 1.0),  // Base green-cyan
                    core1Color,                 // Dynamic pulsing color
                    noise1                      // Noise modulation for texture
                ) * coreFactor1;
                
                vec4 coreTouch2 = mix(
                    vec4(0.1, 0.3, 0.9, 1.0),  // Base blue
                    core2Color,                 // Dynamic pulsing color
                    noise2                      // Noise modulation for texture
                ) * coreFactor2;
                
                // TRAIL COLOR SYSTEM
                // Creates layered energy streams with different colors for each touch
                // Touch 1: Green/cyan energy streams
                vec4 touch1Color = vec4(0.0, 1.0, 0.6, 1.0) * trailFactor1;
                vec4 touch1ColorA = vec4(0.0, 0.95, 0.55, 1.0) * trailFactor1a;
                vec4 touch1ColorB = vec4(0.0, 0.9, 0.5, 1.0) * trailFactor1b;
                vec4 touch1ColorC = vec4(0.0, 0.85, 0.45, 1.0) * trailFactor1c;
                vec4 touch1ColorD = vec4(0.0, 0.8, 0.4, 1.0) * trailFactor1d;
                vec4 touch1ColorE = vec4(0.0, 0.75, 0.35, 1.0) * trailFactor1e;
                vec4 touch1ColorF = mix(vec4(0.3, 1.0, 0.6, 1.0), vec4(0.1, 0.8, 0.4, 1.0), noise1) * trailFactor1f;
                
                // Touch 2: Blue energy streams  
                vec4 touch2Color = vec4(0.1, 0.4, 1.0, 1.0) * trailFactor2;
                vec4 touch2ColorA = vec4(0.1, 0.38, 0.95, 1.0) * trailFactor2a;
                vec4 touch2ColorB = vec4(0.1, 0.36, 0.9, 1.0) * trailFactor2b;
                vec4 touch2ColorC = vec4(0.1, 0.34, 0.85, 1.0) * trailFactor2c;
                vec4 touch2ColorD = vec4(0.1, 0.32, 0.8, 1.0) * trailFactor2d;
                vec4 touch2ColorE = vec4(0.1, 0.3, 0.75, 1.0) * trailFactor2e;
                vec4 touch2ColorF = mix(vec4(0.2, 0.5, 1.0, 1.0), vec4(0.0, 0.3, 0.8, 1.0), noise2) * trailFactor2f;
                
                // COMBINED EFFECT ASSEMBLY
                // Add all color components together for additive blending effect
                vec4 combinedTrailColor = coreTouch1 + touch1Color + touch1ColorA + touch1ColorB + touch1ColorC + 
                                        touch1ColorD + touch1ColorE + touch1ColorF +
                                        coreTouch2 + touch2Color + touch2ColorA + touch2ColorB + touch2ColorC + 
                                        touch2ColorD + touch2ColorE + touch2ColorF;
                
                // ACTIVITY CALCULATION
                // Measure total energy for blending between background and active effects
                float activity = clamp(length(combinedTrailColor), 0.0, 1.0);
                
                // FINAL COLOR COMPOSITION
                // Blend aurora background with touch effects based on activity level
                vec4 fluidColor = mix(backgroundColor, auroraColor * factor * 3.0, clamp(intensity * 0.5, 0.0, 1.0));
                fluidColor = mix(fluidColor, combinedTrailColor, 0.9); // Strong emphasis on touch effects
                
                // BACKGROUND ENERGY FIELD
                // Adds subtle animated patterns even when no touch input is active
                float backgroundEnergy = 0.0;
                if (u_enable_background > 0.5) {
                    // Grid-based energy pattern with time animation
                    backgroundEnergy = 0.12 * (0.5 + 0.5 * sin(p.x * 8.0 + time) * sin(p.y * 8.0 + time * 0.7));
                    // Cross-term for more complex patterns
                    backgroundEnergy += 0.08 * sin(p.x * p.y * 5.0 + time * 0.5);
                }
                
                // =============================================================================
                // TENDRIL EFFECT RENDERING
                // =============================================================================
                
                // Create lightning/tendril effect between the two touch points
                // Only render if touch points are sufficiently far apart and tendrils enabled
                float touchDistance = length(touch1 - touch2);
                vec4 lightningColor = vec4(0.0);
                
                if (touchDistance > 0.15 && u_enable_tendrils > 0.5) {
                    // Apply control panel thickness and turbulence settings
                    float baseThickness = 0.01 * u_tendril_thickness; 
                    float baseTurbulence = 1.0 * u_tendril_turbulence;
                    
                    // MULTI-LAYER TENDRIL SYSTEM
                    // Creates complex, organic energy beams using multiple tendril layers
                    
                    // Primary tendril - main energy beam with fast movement
                    float tendrilIntensity1 = swirlTendril(p, touch1, touch2, time, baseThickness, baseTurbulence);
                    
                    // Secondary tendril - offset in time for different swirl pattern
                    float tendrilIntensity2 = swirlTendril(p, touch1, touch2, time + 4.27, baseThickness * 0.8, baseTurbulence * 0.8);
                    
                    // Tertiary tendril - slower movement for depth
                    float tendrilIntensity3 = swirlTendril(p, touch1, touch2, time * 0.7, baseThickness * 0.5, baseTurbulence * 1.2);
                    
                    // Micro-tendrils - very thin details for organic appearance
                    float microTendril1 = swirlTendril(p, touch1, touch2, time * 1.3 + 2.8, baseThickness * 0.3, baseTurbulence * 1.5);
                    float microTendril2 = swirlTendril(p, touch1, touch2, time * 0.9 - 3.6, baseThickness * 0.25, baseTurbulence * 1.7);
                    
                    // TENDRIL COLOR SYSTEM
                    // Each layer gets different colors for visual depth and complexity
                    
                    // Primary tendril: hot orange-red core like flame center
                    vec4 primaryTendril = vec4(0.9, 0.3, 0.05, 1.0) * tendrilIntensity1;
                    
                    // Secondary tendril: bright yellow-orange like flame edge
                    vec4 secondaryTendril = vec4(1.0, 0.5, 0.05, 1.0) * tendrilIntensity2;
                    
                    // Tertiary tendril: deep red for visual depth
                    vec4 tertiaryTendril = vec4(0.7, 0.1, 0.05, 1.0) * tendrilIntensity3;
                    
                    // Micro-tendrils: subtle purple/blue accents for contrast
                    vec4 microTendrilColor1 = vec4(0.3, 0.1, 0.5, 1.0) * microTendril1 * 0.5;
                    vec4 microTendrilColor2 = vec4(0.1, 0.05, 0.3, 1.0) * microTendril2 * 0.4;
                    
                    // TEMPORAL COLOR MODULATION
                    // Makes colors shift over time for living energy effect
                    float colorShift = sin(time * 1.5) * 0.3 + 0.7;           // Slow color variation
                    float intensityPulse = 0.7 + 0.3 * pow(sin(time * 2.3) * 0.5 + 0.5, 2.0); // Energy pulsing
                    
                    // COMBINE ALL TENDRIL LAYERS
                    // Additive blending creates intense, layered energy beam
                    lightningColor = primaryTendril * intensityPulse + 
                                    secondaryTendril * colorShift +
                                    tertiaryTendril * (0.6 + 0.4 * sin(time * 1.1)) +
                                    microTendrilColor1 + microTendrilColor2;
                    
                    // TENDRIL GLOW EFFECT
                    // Add soft halo around tendril based on control panel glow setting
                    float glowThickness = 0.05 * u_tendril_glow;
                    float glowIntensity = swirlTendril(p, touch1, touch2, time * 0.8, glowThickness, baseTurbulence * 0.5) * 0.3;
                    lightningColor += vec4(0.5, 0.1, 0.05, 0.7) * glowIntensity * u_tendril_glow;
                }
                
                // FINAL COLOR COMPOSITION
                // Layer all effects: background energy ‚Üí fluid effects ‚Üí tendril beams
                vec4 finalColor = mix(
                    mix(backgroundColor, auroraColor * 0.4, backgroundEnergy),  // Background + energy field
                    fluidColor,                                                // Add fluid effects
                    clamp(activity * 4.0, 0.0, 1.0)                          // Based on touch activity
                );
                
                // Add tendril effects on top (additive)
                finalColor += lightningColor;
                
                return finalColor;
            }
            
            // =============================================================================
            // MAIN SHADER FUNCTION & TARGET RENDERING
            // =============================================================================
            
            void main() {
                // COORDINATE TRANSFORMATION
                // Convert touch positions from 0-1 range to -1 to 1 range for shader math
                vec2 touch1 = u_touch1 * 2.0 - 1.0;
                vec2 touch2 = u_touch2 * 2.0 - 1.0;
                touch1.y *= -1.0; // Flip Y coordinate (canvas Y is inverted)
                touch2.y *= -1.0;
                
                // FLUID EFFECTS RENDERING
                // Generate all fluid dynamics, color effects, and tendrils
                vec4 color = fluidEffect(gl_FragCoord.xy / u_resolution, u_time, touch1, touch2);
                
                // GAME TARGET HIGHLIGHTING
                // Add visual effects for game targets (goals to collect)
                vec2 normalizedPos = gl_FragCoord.xy / u_resolution * 2.0 - 1.0;
                
                // Process each potential target
                for (int i = 0; i < ${MAX_TARGETS}; i++) {
                    if (u_target_active[i] > 0.5) {
                        vec2 targetPos = u_targets[i] * 2.0 - 1.0;
                        targetPos.y *= -1.0;
                        float dist = length(normalizedPos - targetPos);
                        
                        // Only highlight pixels near targets
                        if (dist < 0.1) {
                            // DYNAMIC TARGET PULSING
                            // Creates animated glow effect around targets
                            float pulse = sin(u_time * 8.0) * 0.2 + 0.8;
                            float glow = (0.1 - dist) / 0.1 * pulse;
                            
                            // GOOD TARGET: Green glow with sparkle effects
                            if (u_target_type[i] < 0.5) {
                                vec4 glowColor = vec4(0.0, 1.0, 0.5, 1.0);
                                // Add sparkle effect for extra visual appeal
                                glowColor += vec4(0.2) * pow(sin(u_time * 10.0 + dist * 50.0), 10.0);
                                color = mix(color, glowColor, glow * 0.8 + 0.3 * sin(u_time * 6.0));
                            } 
                            // BAD TARGET: Red glow with warning pulse effects
                            else {
                                vec4 glowColor = vec4(1.0, 0.2, 0.3, 1.0);
                                // Add intense warning pulse effect
                                glowColor += vec4(0.3, 0.0, 0.0, 0.0) * pow(sin(u_time * 15.0), 4.0);
                                color = mix(color, glowColor, glow * 0.8 + 0.3 * sin(u_time * 6.0));
                            }
                        }
                    }
                }
                
                // =============================================================================
                // SHOCKWAVE EFFECTS SYSTEM
                // =============================================================================
                
                // Add expanding ring effects when targets are collected (if enabled)
                if (u_enable_shockwaves > 0.5) {
                    for (int i = 0; i < ${MAX_TARGETS}; i++) {
                        if (u_shockwave_active[i] > 0.5) {
                            vec2 shockwavePos = u_shockwave_pos[i] * 2.0 - 1.0;
                            shockwavePos.y *= -1.0;
                            
                            float timeSinceStart = u_time - u_shockwave_start[i];
                            
                            // Shockwaves last for 1 second
                            if (timeSinceStart < 1.0) {
                                // WAVE EXPANSION CALCULATION
                                float waveRadius = timeSinceStart * 0.6;           // Expansion speed
                                float dist = length(normalizedPos - shockwavePos);
                                float thickness = 0.03 * (1.0 - timeSinceStart);   // Wave gets thinner over time
                                
                                // RING GENERATION
                                // Creates sharp ring edge using smoothstep function
                                float waveFront = smoothstep(0.0, thickness, abs(dist - waveRadius));
                                waveFront = 1.0 - waveFront;
                                
                                // SHOCKWAVE COLOR APPLICATION
                                // Apply color based on target type (good=green, bad=red)
                                if (waveFront > 0.05) {
                                    if (u_shockwave_type[i] < 0.5) {
                                        // GOOD TARGET SHOCKWAVE: Green expanding ring
                                        vec4 waveColor = vec4(0.0, 1.0, 0.5, 1.0) * (1.0 - timeSinceStart) * 0.7 * u_shockwave_intensity;
                                        color += waveColor * waveFront;
                                    } else {
                                        // BAD TARGET SHOCKWAVE: Red expanding ring  
                                        vec4 waveColor = vec4(1.0, 0.2, 0.3, 1.0) * (1.0 - timeSinceStart) * 0.7 * u_shockwave_intensity;
                                        color += waveColor * waveFront;
                                    }
                                    
                                    // INTERIOR DISTORTION EFFECT
                                    // Add visual distortion inside the shockwave ring
                                    if (dist < waveRadius) {
                                        float distortionFactor = 0.05 * (1.0 - dist/waveRadius) * (1.0 - timeSinceStart) * u_shockwave_intensity;
                                        color.rgb += sin(color.gbr * 10.0 + u_time * 5.0) * distortionFactor;
                                    }
                                }
                            }
                        }
                    }
                }
                
                // OUTPUT FINAL PIXEL COLOR
                gl_FragColor = color;
            }
        `;
        
        // =============================================================================
        // WEBGL SHADER COMPILATION & PROGRAM SETUP
        // =============================================================================
        
        // Create and compile individual shaders with error checking
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            
            // Check for compilation errors and provide useful debug info
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compilation error:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            
            return shader;
        }
        
        // Link vertex and fragment shaders into a complete WebGL program
        function createProgram(gl, vertexShader, fragmentShader) {
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            
            // Check for linking errors
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Program linking error:', gl.getProgramInfoLog(program));
                return null;
            }
            
            return program;
        }
        
        // Compile shaders and create the main WebGL program
        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
        const program = createProgram(gl, vertexShader, fragmentShader);
        
        // =============================================================================
        // VERTEX BUFFER SETUP
        // =============================================================================
        
        // Create a full-screen quad using two triangles
        // This covers the entire canvas so the fragment shader runs on every pixel
        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
            -1, -1,  // Bottom-left
            1, -1,   // Bottom-right
            -1, 1,   // Top-left
            -1, 1,   // Top-left (triangle 2)
            1, -1,   // Bottom-right (triangle 2)
            1, 1     // Top-right (triangle 2)
        ]), gl.STATIC_DRAW);
        
        // =============================================================================
        // UNIFORM LOCATION BINDING
        // =============================================================================
        
        // Get locations for core rendering uniforms
        const resolutionUniformLocation = gl.getUniformLocation(program, 'u_resolution');
        const timeUniformLocation = gl.getUniformLocation(program, 'u_time');
        const touch1UniformLocation = gl.getUniformLocation(program, 'u_touch1');
        const touch2UniformLocation = gl.getUniformLocation(program, 'u_touch2');
        
        // Get uniform locations for target rendering system
        const targetLocations = [];
        const targetActiveLocations = [];
        const targetTypeLocations = [];
        for (let i = 0; i < MAX_TARGETS; i++) {
            targetLocations.push(gl.getUniformLocation(program, `u_targets[${i}]`));
            targetActiveLocations.push(gl.getUniformLocation(program, `u_target_active[${i}]`));
            targetTypeLocations.push(gl.getUniformLocation(program, `u_target_type[${i}]`));
        }
        
        // Get uniform locations for shockwave effect system
        const shockwaveActiveLocations = [];
        const shockwavePosLocations = [];
        const shockwaveStartLocations = [];
        const shockwaveTypeLocations = [];
        for (let i = 0; i < MAX_TARGETS; i++) {
            shockwaveActiveLocations.push(gl.getUniformLocation(program, `u_shockwave_active[${i}]`));
            shockwavePosLocations.push(gl.getUniformLocation(program, `u_shockwave_pos[${i}]`));
            shockwaveStartLocations.push(gl.getUniformLocation(program, `u_shockwave_start[${i}]`));
            shockwaveTypeLocations.push(gl.getUniformLocation(program, `u_shockwave_type[${i}]`));
        }
        
        // =============================================================================
        // INPUT HANDLING SYSTEM
        // =============================================================================
        
        // Touch/mouse position tracking (normalized 0-1 coordinates)
        let touch1 = { x: 0.25, y: 0.5 };  // Default positions for visual interest
        let touch2 = { x: 0.75, y: 0.5 };  // when no input is active
        let isMouseDown = false;            // Desktop mouse interaction state
        
        // MULTI-TOUCH INPUT HANDLER
        // Processes touch events for mobile devices with dual-thumb gameplay
        function handleTouches(e) {
            e.preventDefault(); // Prevent scrolling and other default touch behaviors
            
            // GAME RULE: Track if both thumbs are actively being used
            // This affects scoring bonuses and penalties
            bothThumbsActive = (e.touches.length >= 2);
            
            // FIRST TOUCH: Always present, controls primary touch point
            if (e.touches.length >= 1) {
                touch1.x = e.touches[0].clientX / canvas.width;
                touch1.y = e.touches[0].clientY / canvas.height;
            }
            
            // SECOND TOUCH: Creates dual-thumb gameplay when present
            if (e.touches.length >= 2) {
                touch2.x = e.touches[1].clientX / canvas.width;
                touch2.y = e.touches[1].clientY / canvas.height;
                
                // Initialize bonus score timer when both thumbs first become active
                if (lastActiveScoreTime === 0) {
                    lastActiveScoreTime = Date.now();
                }
            }
            
            // Check if touch points are hitting any targets
            checkTargets();
        }
        
        // MOUSE INPUT HANDLER (Desktop Support)
        // Simulates dual-touch behavior using single mouse cursor
        function handleMouseMove(e) {
            if (!isMouseDown) return; // Only respond during active drag
            
            // PRIMARY TOUCH: Follows mouse cursor directly
            touch1.x = e.clientX / canvas.width;
            touch1.y = e.clientY / canvas.height;
            
            // SECONDARY TOUCH: Mirror position for interesting visual effect
            // Creates symmetric tendril and fluid patterns
            touch2.x = 1 - touch1.x;
            touch2.y = 1 - touch1.y;
            
            // Check for target collection during mouse interaction
            checkTargets();
        }
        
        // MOUSE DOWN HANDLER
        // Initiates mouse-based gameplay and sets up dual-touch simulation
        function handleMouseDown(e) {
            isMouseDown = true;
            
            // GAME RULE: Mouse interaction counts as "both thumbs active"
            bothThumbsActive = true;
            if (lastActiveScoreTime === 0) {
                lastActiveScoreTime = Date.now();
            }
            
            // Set initial positions for both simulated touch points
            touch1.x = e.clientX / canvas.width;
            touch1.y = e.clientY / canvas.height;
            
            // Create mirrored second touch point
            touch2.x = 1 - touch1.x;
            touch2.y = 1 - touch1.y;
            
            // Check for immediate target collection on click
            checkTargets();
        }
        
        // MOUSE UP HANDLER  
        // Ends mouse interaction and resets game state
        function handleMouseUp() {
            isMouseDown = false;
            bothThumbsActive = false;
        }
        
        // DIRECT TARGET CLICKING (Desktop Accessibility)
        // Allows desktop users to click directly on targets for easier gameplay
        function handleClick(e) {
            const mouseX = e.clientX / canvas.width;
            const mouseY = e.clientY / canvas.height;
            
            // Check if click hit any active targets
            targets.forEach(target => {
                if (target.collected) return; // Skip already collected targets
                
                // Calculate distance from click to target center
                const dist = Math.hypot(
                    target.x - mouseX,
                    target.y - mouseY
                );
                
                // Same collection radius as touch-based collection
                if (dist < 0.08) {
                    collectTarget(target);
                }
            });
        }
        
        // EVENT LISTENER REGISTRATION
        // Set up all input event handlers
        
        // Touch events for mobile devices
        canvas.addEventListener('touchstart', handleTouches);
        canvas.addEventListener('touchmove', handleTouches);
        
        // Mouse events for desktop interaction
        canvas.addEventListener('mousedown', handleMouseDown);
        canvas.addEventListener('mousemove', handleMouseMove);
        canvas.addEventListener('mouseup', handleMouseUp);
        canvas.addEventListener('mouseleave', handleMouseUp);  // Handle mouse leaving canvas
        canvas.addEventListener('click', handleClick);
        
        // =============================================================================
        // SCORING SYSTEM & FEEDBACK
        // =============================================================================
        
        // Updates player score and provides multi-modal feedback
        // Combines visual, audio, and haptic feedback for game events
        function updateScore(points) {
            score += points;
            document.getElementById('score').textContent = `Score: ${score}`;
            
            // VISUAL FEEDBACK: Update score display styling
            const scoreElement = document.getElementById('score');
            scoreElement.classList.remove('negative');
            
            if (points > 0) {
                // POSITIVE SCORE CHANGE: Green target collected
                scoreDirection = 1;
                
                // AUDIO FEEDBACK: Pleasant ascending arpeggio
                if (audioEnabled) {
                    createCollectSound();
                }
                // HAPTIC FEEDBACK: Brief vibration confirmation
                vibrate(50);
            } else {
                // NEGATIVE SCORE CHANGE: Red target hit or penalty
                scoreDirection = -1;
                scoreElement.classList.add('negative'); // Red text color
                
                // AUDIO FEEDBACK: Harsh, descending warning sound
                if (audioEnabled) {
                    createBadSound();
                }
                // HAPTIC FEEDBACK: More intense vibration pattern for warning
                vibrate([50, 50, 100]);
            }
            
            // Track timing for score change animations
            lastScoreChange = Date.now();
            
            // VISUAL CLEANUP: Remove negative styling after brief display
            setTimeout(() => {
                scoreElement.classList.remove('negative');
            }, 500);
        }
        
        // =============================================================================
        // TARGET GENERATION & MANAGEMENT
        // =============================================================================
        
        // Creates new targets at random positions with random type (good/bad)
        function createTarget() {
            // CAPACITY CHECK: Don't exceed maximum simultaneous targets
            if (targets.length >= MAX_TARGETS) return;
            
            // TARGET TYPE SELECTION: 30% chance for penalty targets, 70% for reward targets
            const isBad = Math.random() < 0.3;
            
            // TARGET OBJECT CREATION
            const target = {
                x: Math.random() * 0.8 + 0.1,  // Random X: 0.1 to 0.9 (avoid screen edges)
                y: Math.random() * 0.8 + 0.1,  // Random Y: 0.1 to 0.9 (avoid screen edges)
                createdAt: Date.now(),          // Birth timestamp for lifespan tracking
                collected: false,               // Collection state flag
                isBad: isBad,                  // Target type: true=penalty, false=reward
                element: document.createElement('div') // DOM element for visual representation
            };
            
            // DOM ELEMENT SETUP: Style and position the visual target
            target.element.className = isBad ? 'target bad' : 'target good';
            target.element.style.left = `${target.x * 100}%`;
            target.element.style.top = `${target.y * 100}%`;
            document.getElementById('targets').appendChild(target.element);
            
            // Add to active targets list
            targets.push(target);
        }
        
        // TARGET CLEANUP: Remove target from both DOM and game state
        function removeTarget(target) {
            target.element.remove(); // Remove DOM element
            targets = targets.filter(t => t !== target); // Remove from array
        }
        
        // TARGET LIFECYCLE MANAGEMENT
        // Handles target expiration and spawning of new targets
        function updateTargets() {
            const now = Date.now();
            
            // EXPIRATION CHECK: Remove targets that have exceeded their lifespan
            targets.forEach(target => {
                if (now - target.createdAt > targetLifespan && !target.collected) {
                    removeTarget(target);
                }
            });
            
            // SPAWNING LOGIC: Create new targets based on control panel rate setting
            // Probability-based spawning: 1% base chance per frame, scaled by rate multiplier
            if (targets.length < MAX_TARGETS && Math.random() < (0.01 * gameSettings.targetGenerationRate)) {
                createTarget();
            }
        }
        
        // =============================================================================
        // SHOCKWAVE EFFECT SYSTEM
        // =============================================================================
        
        // Creates expanding ring effect when targets are collected
        function createShockwave(x, y, isGood) {
            // SLOT ALLOCATION: Find available shockwave slot (reuse system for performance)
            let index = -1;
            for (let i = 0; i < MAX_TARGETS; i++) {
                if (!shockwaves[i] || !shockwaves[i].active) {
                    index = i;
                    break;
                }
            }
            
            // If all slots occupied, skip shockwave (should be rare)
            if (index === -1) return;
            
            // SHOCKWAVE CREATION: Set up expanding ring effect
            shockwaves[index] = {
                active: true,
                x: x,                           // Center position X
                y: y,                           // Center position Y
                startTime: Date.now() / 1000,   // Start time in seconds (for shader)
                isGood: isGood                  // Type affects color: green=good, red=bad
            };
        }
        
        // =============================================================================
        // COLLISION DETECTION & TARGET COLLECTION
        // =============================================================================
        
        // Checks if either touch point is close enough to collect targets
        function checkTargets() {
            targets.forEach(target => {
                if (target.collected) return; // Skip already collected targets
                
                // DISTANCE CALCULATION: Check both touch points
                const distToTouch1 = Math.hypot(
                    target.x - touch1.x,
                    target.y - touch1.y
                );
                
                const distToTouch2 = Math.hypot(
                    target.x - touch2.x,
                    target.y - touch2.y
                );
                
                // COLLECTION THRESHOLD: 0.08 normalized distance (about 8% of screen)
                if (distToTouch1 < 0.08 || distToTouch2 < 0.08) {
                    collectTarget(target);
                }
            });
        }
        
        // TARGET COLLECTION HANDLER
        // Processes target collection with scoring, effects, and cleanup
        function collectTarget(target) {
            if (target.collected) return; // Prevent double-collection
            
            target.collected = true;
            
            // VISUAL EFFECT: Create shockwave at collection point
            createShockwave(target.x, target.y, !target.isBad);
            
            if (target.isBad) {
                // BAD TARGET COLLECTION: Penalty feedback
                target.element.style.border = '4px solid rgba(255, 51, 102, 1.0)';
                target.element.style.boxShadow = '0 0 25px rgba(255, 51, 102, 1.0)';
                updateScore(-15); // Heavy penalty: -15 points
            } else {
                // GOOD TARGET COLLECTION: Reward feedback
                target.element.style.border = '4px solid rgba(0, 255, 170, 1.0)';
                target.element.style.boxShadow = '0 0 25px rgba(0, 255, 170, 1.0)';
                updateScore(10); // Standard reward: +10 points
            }
            
            // COLLECTION ANIMATION: Scale up and stop CSS animations
            target.element.style.animation = 'none';
            target.element.style.transform = 'translate(-50%, -50%) scale(1.2)';
            
            // CLEANUP: Remove target after brief display of collection effect
            setTimeout(() => {
                removeTarget(target);
            }, 500);
        }
        
        // =============================================================================
        // ADVANCED GAME MECHANICS
        // =============================================================================
        
        // Animation timing for main game loop
        let startTime = Date.now();
        
        // TENDRIL-TARGET COLLISION DETECTION
        // Checks if energy beams between touch points intersect with targets
        function checkTendrilTargetIntersection() {
            // FEATURE GATE: Only check if tendrils are enabled via control panel
            if (!gameSettings.enableTendrils) return;
            
            // DISTANCE REQUIREMENT: Only create tendrils when touch points are far enough apart
            let touchDistance = Math.hypot(
                touch1.x - touch2.x,
                touch1.y - touch2.y
            );
            
            if (touchDistance < 0.15) return; // Same threshold as shader
            
            // PATH SAMPLING APPROACH
            // Since tendril path is complex (from shader), we approximate using linear sampling
            const numSamples = 10;
            
            targets.forEach(target => {
                if (target.collected) return;
                
                let hit = false;
                
                // SAMPLE POINTS along straight line between touch points
                for (let i = 0; i <= numSamples; i++) {
                    const t = i / numSamples; // 0 to 1 along the line
                    
                    // LINEAR INTERPOLATION between touch points
                    const x = touch1.x + (touch2.x - touch1.x) * t;
                    const y = touch1.y + (touch2.y - touch1.y) * t;
                    
                    // TURBULENCE SIMULATION: Add swirl approximation
                    // This tries to match the shader's complex tendril curves
                    const time = Date.now() / 1000;
                    const offset = 0.05 * gameSettings.tendrilTurbulence * Math.sin(t * 6 + time * 2);
                    
                    // COLLISION CHECK: Distance from target to sampled point
                    const dist = Math.hypot(
                        target.x - (x + offset),
                        target.y - y
                    );
                    
                    // HIT DETECTION: Use control panel thickness setting + target radius
                    const thickness = 0.05 * gameSettings.tendrilThickness;
                    
                    if (dist < thickness + 0.03) { // 0.03 = approximate target hit radius
                        hit = true;
                        break;
                    }
                }
                
                if (hit) {
                    // TENDRIL HIT: Apply scoring based on target type
                    if (target.isBad) {
                        updateScore(-5); // Moderate penalty for tendril hitting bad target
                    } else {
                        updateScore(5);  // Moderate reward for tendril hitting good target  
                    }
                    collectTarget(target);
                }
            });
        }
        
        // PROXIMITY PENALTY SYSTEM
        // Prevents players from cheating by keeping thumbs too close together
        function checkThumbsDistance() {
            if (!bothThumbsActive) return; // Only applies when both thumbs are down
            
            const touchDistance = Math.hypot(
                touch1.x - touch2.x,
                touch1.y - touch2.y
            );
            
            // PENALTY APPLICATION: One-time penalty when thumbs get too close
            if (touchDistance < THUMBS_TOO_CLOSE_THRESHOLD && !thumbsClosePenaltyActive) {
                thumbsClosePenaltyActive = true;
                updateScore(-3); // Penalty for poor technique
                
                // ENHANCED FEEDBACK: Stronger vibration for rule violation
                if (navigator.vibrate) {
                    navigator.vibrate([50, 50, 50]); // Triple pulse for warning
                }
                
                // COOLDOWN PERIOD: Prevent rapid-fire penalties
                setTimeout(() => {
                    thumbsClosePenaltyActive = false;
                }, 1000);
            }
        }
        
        // ACTIVE PLAY BONUS SYSTEM
        // Rewards players for maintaining dual-thumb engagement
        function checkActiveThumbsBonus() {
            const now = Date.now();
            
            // BONUS CONDITIONS: Both thumbs active + sufficient time elapsed
            if (bothThumbsActive && now - lastActiveScoreTime > BOTH_THUMBS_ACTIVE_SCORE_INTERVAL) {
                updateScore(1); // Small continuous bonus for active engagement
                lastActiveScoreTime = now;
            }
        }
        
        // =============================================================================
        // MAIN RENDER LOOP & WEBGL RENDERING
        // =============================================================================
        
        // Primary rendering function called every frame via requestAnimationFrame
        function render() {
            // FRAME SETUP: Handle resize and target lifecycle
            resize();           // Update canvas size if window changed
            updateTargets();    // Handle target expiration and spawning
            
            // GAME RULE ENFORCEMENT: Apply all gameplay mechanics
            checkTendrilTargetIntersection(); // Tendril-target collisions
            checkThumbsDistance();            // Proximity penalties  
            checkActiveThumbsBonus();         // Engagement bonuses
            
            // TIME CALCULATION: Convert to seconds for shader consistency
            const currentTime = (Date.now() - startTime) / 1000;
            
            // WEBGL RENDERING SETUP
            gl.clearColor(0, 0, 0, 1);        // Pure black background
            gl.clear(gl.COLOR_BUFFER_BIT);     // Clear previous frame
            gl.useProgram(program);            // Activate shader program
            
            // CORE UNIFORMS: Basic rendering parameters
            gl.uniform2f(resolutionUniformLocation, canvas.width, canvas.height);
            gl.uniform1f(timeUniformLocation, currentTime);
            gl.uniform2f(touch1UniformLocation, touch1.x, touch1.y);
            gl.uniform2f(touch2UniformLocation, touch2.x, touch2.y);
            
            // CONTROL PANEL UNIFORMS: Pass user settings to shaders
            gl.uniform1f(gl.getUniformLocation(program, 'u_fluid_intensity'), gameSettings.fluidIntensity);
            gl.uniform1f(gl.getUniformLocation(program, 'u_enable_background'), gameSettings.enableBackground ? 1.0 : 0.0);
            gl.uniform1f(gl.getUniformLocation(program, 'u_enable_tendrils'), gameSettings.enableTendrils ? 1.0 : 0.0);
            gl.uniform1f(gl.getUniformLocation(program, 'u_tendril_thickness'), gameSettings.tendrilThickness);
            gl.uniform1f(gl.getUniformLocation(program, 'u_tendril_turbulence'), gameSettings.tendrilTurbulence);
            gl.uniform1f(gl.getUniformLocation(program, 'u_tendril_glow'), gameSettings.tendrilGlow);
            gl.uniform1f(gl.getUniformLocation(program, 'u_enable_shockwaves'), gameSettings.enableShockwaves ? 1.0 : 0.0);
            gl.uniform1f(gl.getUniformLocation(program, 'u_shockwave_intensity'), gameSettings.shockwaveIntensity);
            
            // TARGET UNIFORMS: Send target data to shaders for highlighting
            for (let i = 0; i < MAX_TARGETS; i++) {
                if (i < targets.length && !targets[i].collected) {
                    // ACTIVE TARGET: Send position and type data
                    gl.uniform2f(targetLocations[i], targets[i].x, targets[i].y);
                    gl.uniform1f(targetActiveLocations[i], 1.0);
                    gl.uniform1f(targetTypeLocations[i], targets[i].isBad ? 1.0 : 0.0);
                } else {
                    // INACTIVE SLOT: Clear data to prevent rendering artifacts
                    gl.uniform2f(targetLocations[i], 0, 0);
                    gl.uniform1f(targetActiveLocations[i], 0.0);
                    gl.uniform1f(targetTypeLocations[i], 0.0);
                }
            }
            
            // SHOCKWAVE UNIFORMS: Send expanding ring effect data
            for (let i = 0; i < MAX_TARGETS; i++) {
                if (shockwaves[i] && shockwaves[i].active) {
                    const timeSinceStart = currentTime - shockwaves[i].startTime;
                    
                    // LIFETIME CHECK: Deactivate expired shockwaves (1 second duration)
                    if (timeSinceStart > 1.0) {
                        shockwaves[i].active = false;
                        gl.uniform1f(shockwaveActiveLocations[i], 0.0);
                    } else {
                        // ACTIVE SHOCKWAVE: Send all data to shader
                        gl.uniform1f(shockwaveActiveLocations[i], 1.0);
                        gl.uniform2f(shockwavePosLocations[i], shockwaves[i].x, shockwaves[i].y);
                        gl.uniform1f(shockwaveStartLocations[i], shockwaves[i].startTime);
                        gl.uniform1f(shockwaveTypeLocations[i], shockwaves[i].isGood ? 0.0 : 1.0);
                    }
                } else {
                    // INACTIVE SHOCKWAVE: Clear data
                    gl.uniform1f(shockwaveActiveLocations[i], 0.0);
                }
            }
            
            // VERTEX DATA SETUP: Configure full-screen quad for fragment shader
            const positionAttributeLocation = gl.getAttribLocation(program, 'a_position');
            gl.enableVertexAttribArray(positionAttributeLocation);
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);
            
            // FINAL RENDER: Draw full-screen quad (triggers fragment shader on every pixel)
            gl.drawArrays(gl.TRIANGLES, 0, 6);
            
            // FRAME COMPLETION: Schedule next frame
            requestAnimationFrame(render);
        }
        
        // =============================================================================
        // GAME INITIALIZATION & STARTUP
        // =============================================================================
        
        // Additional audio enablement handler for browser policy compliance
        function enableAudio() {
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
            
            // AUDIO TEST: Confirm audio system is working
            if (audioEnabled) {
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                gain.gain.value = 0.2;  
                osc.frequency.value = 440; // A4 reference tone
                osc.connect(gain);
                gain.connect(audioContext.destination);
                osc.start();
                osc.stop(audioContext.currentTime + 0.1);
            }
            
            // CLEANUP: Remove one-time event listeners
            document.removeEventListener('click', enableAudio);
            document.removeEventListener('touchstart', enableAudio);
            
            // USER FEEDBACK: Show audio enabled confirmation
            const audioAlert = document.createElement('div');
            audioAlert.textContent = 'Audio enabled! üîä';
            audioAlert.style.position = 'absolute';
            audioAlert.style.top = '70px';
            audioAlert.style.left = '0';
            audioAlert.style.width = '100%';
            audioAlert.style.textAlign = 'center';
            audioAlert.style.color = '#00ffaa';
            audioAlert.style.fontFamily = 'Arial, sans-serif';
            audioAlert.style.fontSize = '18px';
            audioAlert.style.zIndex = '20';
            audioAlert.style.pointerEvents = 'none';
            document.body.appendChild(audioAlert);
            
            // CLEANUP: Remove notification after display
            setTimeout(() => {
                audioAlert.remove();
            }, 2000);
        }
        
        // BROWSER POLICY COMPLIANCE: Wait for user interaction before enabling audio
        document.addEventListener('click', enableAudio);
        document.addEventListener('touchstart', enableAudio);
        
        // GAME STARTUP: Create initial content and begin render loop
        createTarget();  // Spawn first target
        render();       // Begin main game loop
    </script>
</body>
</html>