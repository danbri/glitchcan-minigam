<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Fluid Dynamics Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: none;
        }
        body {
            overflow: hidden;
            background-color: #000;
            width: 100vw;
            height: 100vh;
            position: fixed;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            touch-action: none;
        }
        #score {
            position: absolute;
            top: 20px;
            left: 0;
            width: 100%;
            text-align: center;
            color: #00ffaa;
            font-family: Arial, sans-serif;
            font-size: 24px;
            text-shadow: 0 0 10px rgba(0, 255, 170, 0.8);
            z-index: 10;
            pointer-events: none;
            transition: color 0.3s;
        }
        #score.negative {
            color: #ff3366;
            text-shadow: 0 0 10px rgba(255, 51, 102, 0.8);
        }
        #targets {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        .target {
            position: absolute;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }
        .target.good {
            border: 3px solid rgba(0, 255, 170, 0.8);
            box-shadow: 0 0 15px rgba(0, 255, 170, 0.7);
            animation: pulseGood 1.5s infinite alternate;
        }
        .target.bad {
            border: 3px solid rgba(255, 51, 102, 0.8);
            box-shadow: 0 0 15px rgba(255, 51, 102, 0.7);
            animation: pulseBad 1.5s infinite alternate;
        }
        
        @keyframes pulseGood {
            0% { box-shadow: 0 0 10px rgba(0, 255, 170, 0.7); }
            100% { box-shadow: 0 0 20px rgba(0, 255, 170, 0.9); }
        }
        
        @keyframes pulseBad {
            0% { box-shadow: 0 0 10px rgba(255, 51, 102, 0.7); }
            100% { box-shadow: 0 0 20px rgba(255, 51, 102, 0.9); }
        }
        
        #instructions {
            position: absolute;
            bottom: 20px;
            left: 0;
            width: 100%;
            text-align: center;
            color: #00ffaa;
            font-family: Arial, sans-serif;
            font-size: 16px;
            text-shadow: 0 0 8px rgba(0, 255, 170, 0.6);
            z-index: 10;
            pointer-events: none;
            padding: 0 20px;
        }
        
        #audio-toggle {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #00ffaa;
            color: #00ffaa;
            font-family: Arial, sans-serif;
            padding: 5px 10px;
            border-radius: 20px;
            z-index: 20;
            cursor: pointer;
        }
        
        /* Control Panel Styles */
        #control-panel-toggle {
            position: absolute;
            top: 70px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid #00ffaa;
            color: #00ffaa;
            font-family: Arial, sans-serif;
            padding: 5px 10px;
            border-radius: 20px;
            z-index: 21;
            cursor: pointer;
            font-size: 14px;
        }
        
        #control-panel {
            position: absolute;
            top: 110px;
            right: 20px;
            width: 280px;
            background: rgba(0, 0, 0, 0.85);
            border: 1px solid #00ffaa;
            border-radius: 10px;
            padding: 15px;
            color: white;
            font-family: Arial, sans-serif;
            font-size: 12px;
            z-index: 20;
            max-height: 80vh;
            overflow-y: auto;
            display: none;
            transform-origin: top right;
            transition: transform 0.3s, opacity 0.3s;
            transform: scale(0.95);
            opacity: 0;
        }
        
        #control-panel.visible {
            display: block;
            transform: scale(1);
            opacity: 1;
        }
        
        .control-section {
            margin-bottom: 15px;
            border-bottom: 1px solid rgba(0, 255, 170, 0.3);
            padding-bottom: 10px;
        }
        
        .control-section h3 {
            color: #00ffaa;
            margin: 0 0 10px 0;
            font-size: 14px;
        }
        
        .control-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 6px 0;
        }
        
        .control-label {
            flex: 1;
        }
        
        .control-input {
            flex: 1;
        }
        
        /* Sliders and inputs */
        .control-panel input[type="range"] {
            width: 100%;
            background: #333;
            height: 6px;
            -webkit-appearance: none;
            border-radius: 3px;
            outline: none;
        }
        
        .control-panel input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 12px;
            height: 12px;
            background: #00ffaa;
            border-radius: 50%;
            cursor: pointer;
        }
        
        .control-panel input[type="checkbox"] {
            -webkit-appearance: none;
            width: 30px;
            height: 16px;
            background: #333;
            border-radius: 10px;
            position: relative;
            outline: none;
            cursor: pointer;
        }
        
        .control-panel input[type="checkbox"]:checked {
            background: #00ffaa;
        }
        
        .control-panel input[type="checkbox"]:before {
            content: '';
            position: absolute;
            width: 14px;
            height: 14px;
            background: #ddd;
            border-radius: 50%;
            top: 1px;
            left: 1px;
            transition: 0.3s;
        }
        
        .control-panel input[type="checkbox"]:checked:before {
            left: 15px;
        }
        
        .parameter-value {
            display: inline-block;
            width: 30px;
            text-align: right;
            font-size: 11px;
            color: #ccc;
            margin-left: 8px;
        }
        
        /* Only show control panel on desktop */
        @media (max-width: 768px) {
            #control-panel-toggle {
                display: none;
            }
        }
    </style>
</head>
<body>
    <div id="score">Score: 0</div>
    <div id="targets"></div>
    <div id="instructions">
        On mobile: Use both thumbs to bend the fluid streams.<br>
        On desktop: Click and drag with your mouse or click directly on targets.<br>
        Catch green targets, but avoid red ones!
    </div>
    <button id="audio-toggle">üîä Click to Enable Audio</button>
    <button id="control-panel-toggle">‚öôÔ∏è Controls</button>
    <div id="control-panel" class="control-panel">
        <div class="control-section">
            <h3>Tendril Effects</h3>
            <div class="control-row">
                <label class="control-label">Enable Tendrils</label>
                <div class="control-input">
                    <input type="checkbox" id="enable-tendrils" checked>
                </div>
            </div>
            <div class="control-row">
                <label class="control-label">Thickness <span id="tendril-thickness-value" class="parameter-value">1.0</span></label>
                <div class="control-input">
                    <input type="range" id="tendril-thickness" min="0.1" max="2.0" step="0.1" value="1.0">
                </div>
            </div>
            <div class="control-row">
                <label class="control-label">Turbulence <span id="tendril-turbulence-value" class="parameter-value">1.0</span></label>
                <div class="control-input">
                    <input type="range" id="tendril-turbulence" min="0.1" max="2.0" step="0.1" value="1.0">
                </div>
            </div>
            <div class="control-row">
                <label class="control-label">Glow Intensity <span id="tendril-glow-value" class="parameter-value">1.0</span></label>
                <div class="control-input">
                    <input type="range" id="tendril-glow" min="0" max="2.0" step="0.1" value="1.0">
                </div>
            </div>
        </div>
        
        <div class="control-section">
            <h3>Fluid Dynamics</h3>
            <div class="control-row">
                <label class="control-label">Intensity <span id="fluid-intensity-value" class="parameter-value">1.0</span></label>
                <div class="control-input">
                    <input type="range" id="fluid-intensity" min="0.1" max="2.0" step="0.1" value="1.0">
                </div>
            </div>
            <div class="control-row">
                <label class="control-label">Background Effects</label>
                <div class="control-input">
                    <input type="checkbox" id="enable-background" checked>
                </div>
            </div>
        </div>
        
        <div class="control-section">
            <h3>Shockwave Effects</h3>
            <div class="control-row">
                <label class="control-label">Enable Shockwaves</label>
                <div class="control-input">
                    <input type="checkbox" id="enable-shockwaves" checked>
                </div>
            </div>
            <div class="control-row">
                <label class="control-label">Intensity <span id="shockwave-intensity-value" class="parameter-value">1.0</span></label>
                <div class="control-input">
                    <input type="range" id="shockwave-intensity" min="0" max="2.0" step="0.1" value="1.0">
                </div>
            </div>
        </div>
        
        <div class="control-section">
            <h3>Gameplay</h3>
            <div class="control-row">
                <label class="control-label">Target Generation Rate <span id="target-rate-value" class="parameter-value">1.0</span></label>
                <div class="control-input">
                    <input type="range" id="target-rate" min="0.2" max="2.0" step="0.1" value="1.0">
                </div>
            </div>
            <div class="control-row">
                <label class="control-label">Target Lifespan <span id="target-lifespan-value" class="parameter-value">5s</span></label>
                <div class="control-input">
                    <input type="range" id="target-lifespan" min="2" max="10" step="0.5" value="5">
                </div>
            </div>
        </div>
        
        <div class="control-section">
            <h3>Performance</h3>
            <div class="control-row">
                <label class="control-label">Quality Preset</label>
                <div class="control-input">
                    <select id="quality-preset">
                        <option value="high">High</option>
                        <option value="medium" selected>Medium</option>
                        <option value="low">Low</option>
                    </select>
                </div>
            </div>
            <div class="control-row">
                <label class="control-label">Fluid Iterations <span id="fluid-iterations-value" class="parameter-value">12</span></label>
                <div class="control-input">
                    <input type="range" id="fluid-iterations" min="4" max="16" step="1" value="12">
                </div>
            </div>
        </div>
    </div>
    <canvas id="canvas"></canvas>

    <script>
        /**
         * THUMBWAR FLUID DYNAMICS GAME
         * ============================
         * 
         * This game features advanced WebGL fluid dynamics, tendril effects, and interactive
         * gameplay where players use touch or mouse input to create flowing energy streams.
         * 
         * Key Features:
         * - Real-time fluid dynamics simulation using WebGL fragment shaders
         * - Organic tendril/lightning effects between two input points
         * - Shockwave effects when targets are collected
         * - Multi-layered particle systems with complex mathematical patterns
         * - Audio feedback system using Web Audio API
         * - Haptic feedback for mobile devices
         * - Real-time control panel for adjusting all visual parameters
         * 
         * Technical Architecture:
         * - WebGL 1.0 fragment shader performs all visual computations
         * - JavaScript handles game logic, user input, and parameter management
         * - Canvas-based rendering with full-screen viewport
         * - Event-driven target generation and collection system
         */

        // =============================================================================
        // CORE GAME VARIABLES
        // =============================================================================
        
        // Game state variables
        let score = 0;                    // Current player score
        const MAX_TARGETS = 4;            // Maximum simultaneous targets (good + bad)
        let targetLifespan = 5000;        // Target duration in milliseconds (configurable via UI)
        let targets = [];                 // Array of active target objects
        let shockwaves = [];              // Array of active shockwave effects
        let audioEnabled = true;          // Global audio on/off state
        let lastScoreChange = 0;          // Timestamp of last score change (for UI animation)
        let scoreDirection = 1;           // Score change direction: 1=positive, -1=negative
        
        // =============================================================================
        // GAMEPLAY MECHANICS VARIABLES
        // =============================================================================
        
        // Touch/mouse interaction state
        let bothThumbsActive = false;               // True when both touch points are active
        let thumbsClosePenaltyActive = false;       // Debounce flag to prevent spam penalties
        let lastActiveScoreTime = 0;               // Timestamp for bonus score timing
        
        // Gameplay balance constants
        let THUMBS_TOO_CLOSE_THRESHOLD = 0.2;      // Normalized distance below which thumbs are "too close" (0-1 range)
        let BOTH_THUMBS_ACTIVE_SCORE_INTERVAL = 1000; // Milliseconds between bonus points for keeping both thumbs active
        
        // =============================================================================
        // VISUAL EFFECTS CONTROL SYSTEM
        // =============================================================================
        
        // Global settings object - all visual parameters are controlled through this
        // These values are modified in real-time by the control panel UI
        let gameSettings = {
            // Tendril/lightning effects between touch points
            enableTendrils: true,          // Master on/off switch for tendril rendering
            tendrilThickness: 1.0,         // Base thickness multiplier (0.1-2.0)
            tendrilTurbulence: 1.0,        // Swirl intensity and organic movement (0.1-2.0)
            tendrilGlow: 1.0,              // Glow halo intensity around tendrils (0-2.0)
            
            // Background fluid dynamics simulation
            fluidIntensity: 1.0,           // Overall fluid simulation strength (0.1-2.0)
            enableBackground: true,        // Background energy field on/off
            
            // Shockwave effects when targets are collected
            enableShockwaves: true,        // Master shockwave on/off switch
            shockwaveIntensity: 1.0,       // Shockwave visual strength and distortion (0-2.0)
            
            // Gameplay balance
            targetGenerationRate: 1.0,     // Target spawn frequency multiplier (0.2-2.0)
            targetLifespan: 5.0,           // Target duration in seconds (2-10)
            
            // Performance optimization
            qualityPreset: 'medium',       // Performance preset: 'low', 'medium', 'high'
            fluidIterations: 12            // Shader iteration count - higher = more detail but slower (4-16)
        };
        
        // =============================================================================
        // CONTROL PANEL USER INTERFACE
        // =============================================================================
        
        /**
         * The control panel allows real-time adjustment of all visual and gameplay parameters.
         * Changes are immediately reflected in the shader uniforms and game logic.
         * Only visible on desktop (hidden on mobile for screen space).
         */
        
        // Control panel DOM elements and event handling
        const controlPanelToggle = document.getElementById('control-panel-toggle');
        const controlPanel = document.getElementById('control-panel');
        
        // Toggle control panel visibility
        controlPanelToggle.addEventListener('click', () => {
            controlPanel.classList.toggle('visible');
        });
        
        /**
         * Initialize all control panel event listeners
         * Each slider/checkbox immediately updates the gameSettings object
         * and triggers real-time changes in the rendering system
         */
        function setupControlPanel() {
            // Tendril controls
            document.getElementById('enable-tendrils').addEventListener('change', e => {
                gameSettings.enableTendrils = e.target.checked;
            });
            
            document.getElementById('tendril-thickness').addEventListener('input', e => {
                gameSettings.tendrilThickness = parseFloat(e.target.value);
                document.getElementById('tendril-thickness-value').textContent = e.target.value;
            });
            
            document.getElementById('tendril-turbulence').addEventListener('input', e => {
                gameSettings.tendrilTurbulence = parseFloat(e.target.value);
                document.getElementById('tendril-turbulence-value').textContent = e.target.value;
            });
            
            document.getElementById('tendril-glow').addEventListener('input', e => {
                gameSettings.tendrilGlow = parseFloat(e.target.value);
                document.getElementById('tendril-glow-value').textContent = e.target.value;
            });
            
            // Fluid dynamics
            document.getElementById('fluid-intensity').addEventListener('input', e => {
                gameSettings.fluidIntensity = parseFloat(e.target.value);
                document.getElementById('fluid-intensity-value').textContent = e.target.value;
            });
            
            document.getElementById('enable-background').addEventListener('change', e => {
                gameSettings.enableBackground = e.target.checked;
            });
            
            // Shockwaves
            document.getElementById('enable-shockwaves').addEventListener('change', e => {
                gameSettings.enableShockwaves = e.target.checked;
            });
            
            document.getElementById('shockwave-intensity').addEventListener('input', e => {
                gameSettings.shockwaveIntensity = parseFloat(e.target.value);
                document.getElementById('shockwave-intensity-value').textContent = e.target.value;
            });
            
            // Gameplay
            document.getElementById('target-rate').addEventListener('input', e => {
                gameSettings.targetGenerationRate = parseFloat(e.target.value);
                document.getElementById('target-rate-value').textContent = e.target.value;
            });
            
            document.getElementById('target-lifespan').addEventListener('input', e => {
                gameSettings.targetLifespan = parseFloat(e.target.value);
                targetLifespan = gameSettings.targetLifespan * 1000; // convert to ms
                document.getElementById('target-lifespan-value').textContent = e.target.value + 's';
            });
            
            // Performance
            document.getElementById('quality-preset').addEventListener('change', e => {
                gameSettings.qualityPreset = e.target.value;
                applyQualityPreset(e.target.value);
            });
            
            document.getElementById('fluid-iterations').addEventListener('input', e => {
                gameSettings.fluidIterations = parseInt(e.target.value);
                document.getElementById('fluid-iterations-value').textContent = e.target.value;
            });
        }
        
        /**
         * Apply performance presets by adjusting shader iteration count
         * Higher iterations = more detailed fluid simulation but lower FPS
         * 
         * Low (8 iterations): Fastest, good for mobile/weak hardware
         * Medium (12 iterations): Balanced quality/performance
         * High (15 iterations): Best visual quality, requires good hardware
         */
        function applyQualityPreset(preset) {
            const iterationsSlider = document.getElementById('fluid-iterations');
            
            switch(preset) {
                case 'high':
                    gameSettings.fluidIterations = 15;
                    iterationsSlider.value = 15;
                    document.getElementById('fluid-iterations-value').textContent = '15';
                    break;
                case 'medium':
                    gameSettings.fluidIterations = 12;
                    iterationsSlider.value = 12;
                    document.getElementById('fluid-iterations-value').textContent = '12';
                    break;
                case 'low':
                    gameSettings.fluidIterations = 8;
                    iterationsSlider.value = 8;
                    document.getElementById('fluid-iterations-value').textContent = '8';
                    break;
            }
        }
        
        // Initialize control panel
        setupControlPanel();
        
        // =============================================================================
        // AUDIO SYSTEM - WEB AUDIO API
        // =============================================================================
        
        /**
         * Audio system provides:
         * - Positive feedback sounds for collecting good targets (major arpeggio)
         * - Negative feedback sounds for bad targets (distorted descending tones)
         * - Test tones for audio initialization
         * - Respects browser autoplay policies (requires user interaction)
         */
        
        // Initialize Web Audio context
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        // Audio toggle
        const audioToggle = document.getElementById('audio-toggle');
        let audioInitialized = false;
        
        audioToggle.addEventListener('click', function() {
            // First click always enables audio
            if (!audioInitialized) {
                audioEnabled = true;
                audioInitialized = true;
                this.textContent = 'üîä On';
                
                // Play test tone on first click
                if (audioContext.state === 'suspended') {
                    audioContext.resume();
                }
                
                // Play a clear, audible test tone
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                gain.gain.value = 0.2;
                osc.frequency.value = 440; // A4 note
                osc.connect(gain);
                gain.connect(audioContext.destination);
                osc.start();
                osc.stop(audioContext.currentTime + 0.1);
                
                // Alert that audio is now active
                const audioAlert = document.createElement('div');
                audioAlert.textContent = 'Audio enabled! üîä';
                audioAlert.style.position = 'absolute';
                audioAlert.style.top = '70px';
                audioAlert.style.left = '0';
                audioAlert.style.width = '100%';
                audioAlert.style.textAlign = 'center';
                audioAlert.style.color = '#00ffaa';
                audioAlert.style.fontFamily = 'Arial, sans-serif';
                audioAlert.style.fontSize = '18px';
                audioAlert.style.zIndex = '20';
                audioAlert.style.pointerEvents = 'none';
                document.body.appendChild(audioAlert);
                
                // Remove the alert after 2 seconds
                setTimeout(() => {
                    audioAlert.remove();
                }, 2000);
            } else {
                // Toggle audio on/off after first initialization
                audioEnabled = !audioEnabled;
                this.textContent = audioEnabled ? 'üîä On' : 'üîá Off';
            }
            
            // Resume audio context if it was suspended (browser policy)
            if (audioEnabled && audioContext.state === 'suspended') {
                audioContext.resume();
            }
        });
        
        /**
         * Create positive collection sound effect
         * Plays a major arpeggio (A4 -> C#5 -> E5) with sine wave
         * Duration: 300ms with smooth attack/release envelope
         */
        function createCollectSound() {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            // Good sound: Major arpeggio
            oscillator.type = 'sine';
            oscillator.frequency.setValueAtTime(440, audioContext.currentTime); // A4
            oscillator.frequency.setValueAtTime(554.37, audioContext.currentTime + 0.1); // C#5
            oscillator.frequency.setValueAtTime(659.25, audioContext.currentTime + 0.2); // E5
            
            gainNode.gain.setValueAtTime(0, audioContext.currentTime);
            gainNode.gain.linearRampToValueAtTime(0.3, audioContext.currentTime + 0.05);
            gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.3);
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.start();
            oscillator.stop(audioContext.currentTime + 0.3);
        }
        
        /**
         * Create negative penalty sound effect
         * Plays distorted sawtooth wave with descending frequency
         * Includes wave shaping distortion for harsh, warning-like sound
         * Duration: 400ms with exponential frequency ramp down
         */
        function createBadSound() {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            const distortion = audioContext.createWaveShaper();
            
            // Bad sound: Distorted descending frequencies
            function makeDistortionCurve(amount) {
                const k = typeof amount === 'number' ? amount : 50;
                const n_samples = 44100;
                const curve = new Float32Array(n_samples);
                for (let i = 0; i < n_samples; ++i) {
                    const x = i * 2 / n_samples - 1;
                    curve[i] = (3 + k) * x * 20 * (Math.PI / 180) / (Math.PI + k * Math.abs(x));
                }
                return curve;
            }
            
            distortion.curve = makeDistortionCurve(400);
            
            oscillator.type = 'sawtooth';
            oscillator.frequency.setValueAtTime(300, audioContext.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(150, audioContext.currentTime + 0.3);
            
            gainNode.gain.setValueAtTime(0, audioContext.currentTime);
            gainNode.gain.linearRampToValueAtTime(0.3, audioContext.currentTime + 0.05);
            gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.4);
            
            oscillator.connect(distortion);
            distortion.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.start();
            oscillator.stop(audioContext.currentTime + 0.4);
        }
        
        /**
         * Haptic feedback using Vibration API
         * Provides tactile feedback for mobile users when available
         * Pattern can be single duration or array [on, off, on, off...]
         */
        function vibrate(pattern) {
            if (navigator.vibrate) {
                navigator.vibrate(pattern);
            }
        }
        
        // =============================================================================
        // WEBGL RENDERING SETUP
        // =============================================================================
        
        /**
         * WebGL initialization and canvas management
         * Sets up the rendering context and handles viewport updates
         */
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
        
        if (!gl) {
            alert('WebGL not supported');
        }
        
        /**
         * Canvas resize handler - maintains proper aspect ratio
         * Updates WebGL viewport when browser window changes size
         * Called automatically on window resize events
         */
        function resize() {
            const displayWidth = canvas.clientWidth;
            const displayHeight = canvas.clientHeight;
            
            if (canvas.width !== displayWidth || canvas.height !== displayHeight) {
                canvas.width = displayWidth;
                canvas.height = displayHeight;
                gl.viewport(0, 0, canvas.width, canvas.height);
            }
        }
        
        window.addEventListener('resize', resize);
        resize();
        
        // =============================================================================
        // WEBGL SHADER PROGRAMS
        // =============================================================================
        
        /**
         * VERTEX SHADER
         * Simple passthrough vertex shader that covers the full screen
         * All visual computation happens in the fragment shader
         */
        
        // Vertex shader - renders full-screen quad
        const vertexShaderSource = `
            // Input: normalized device coordinates (-1 to 1)
            attribute vec2 a_position;
            void main() {
                // Pass through position directly - creates full-screen quad
                gl_Position = vec4(a_position, 0, 1);
            }
        `;
        
        /**
         * FRAGMENT SHADER - MAIN VISUAL EFFECTS ENGINE
         * =============================================
         * 
         * This fragment shader is responsible for all visual effects:
         * 1. Multi-layered fluid dynamics simulation
         * 2. Organic tendril/lightning effects between touch points
         * 3. Target highlighting with pulsing glows
         * 4. Expanding shockwave effects
         * 5. Background energy fields
         * 
         * The shader uses mathematical functions to create organic, flowing patterns
         * that respond to user input in real-time.
         */
        const fragmentShaderSource = `
            precision highp float;
            
            // ===== CORE UNIFORMS =====
            uniform vec2 u_resolution;           // Screen resolution in pixels
            uniform float u_time;                // Elapsed time in seconds for animation
            uniform vec2 u_touch1;               // First touch/mouse position (0-1 normalized)
            uniform vec2 u_touch2;               // Second touch position (0-1 normalized)
            
            // ===== TARGET SYSTEM UNIFORMS =====
            uniform vec2 u_targets[${MAX_TARGETS}];           // Target positions (0-1 normalized)
            uniform float u_target_active[${MAX_TARGETS}];    // Target active state (0.0 or 1.0)
            uniform float u_target_type[${MAX_TARGETS}];      // Target type: 0.0=good, 1.0=bad
            
            // ===== SHOCKWAVE EFFECT UNIFORMS =====
            uniform float u_shockwave_active[${MAX_TARGETS}]; // Shockwave active state
            uniform vec2 u_shockwave_pos[${MAX_TARGETS}];     // Shockwave center positions
            uniform float u_shockwave_start[${MAX_TARGETS}];  // Shockwave start time
            uniform float u_shockwave_type[${MAX_TARGETS}];   // Shockwave type: 0.0=good, 1.0=bad
            
            // ===== CONTROL PANEL UNIFORMS =====
            // These allow real-time adjustment of all visual parameters
            uniform float u_fluid_intensity;     // Overall fluid simulation strength
            uniform float u_enable_background;   // Background energy field toggle
            uniform float u_enable_tendrils;     // Tendril effect toggle
            uniform float u_tendril_thickness;   // Tendril base thickness multiplier
            uniform float u_tendril_turbulence;  // Tendril swirl/organic movement intensity
            uniform float u_tendril_glow;        // Tendril glow halo intensity
            uniform float u_enable_shockwaves;   // Shockwave effect toggle
            uniform float u_shockwave_intensity; // Shockwave visual intensity
            
            /**
             * TENDRIL EFFECT ALGORITHM
             * ========================
             * 
             * Creates organic, swirling tendril/lightning effects between two points.
             * Uses multiple layers of sine waves with different frequencies to create
             * natural-looking, flowing patterns that change over time.
             * 
             * Parameters:
             * - p: Current pixel position
             * - start: Tendril start point
             * - end: Tendril end point  
             * - time: Animation time for movement
             * - thickness: Base thickness of tendril
             * - turbulence: Intensity of swirls and organic movement
             * 
             * Returns: Float intensity value (0.0-1.0) for tendril visibility at this pixel
             */
            float swirlTendril(vec2 p, vec2 start, vec2 end, float time, float thickness, float turbulence) {
                // Calculate base geometry for tendril path
                vec2 direction = end - start;            // Vector from start to end point
                float distance = length(direction);      // Total tendril length
                direction = normalize(direction);        // Unit direction vector
                
                // Perpendicular vector for creating swirl effects
                vec2 perpendicular = vec2(-direction.y, direction.x);
                
                // Project current pixel onto the straight line between start/end
                float t = clamp(dot(p - start, direction) / distance, 0.0, 1.0); // Parameter along line (0-1)
                vec2 projection = start + direction * t * distance;              // Closest point on straight line
                
                // ===== MULTI-LAYERED ORGANIC FLOW GENERATION =====
                // Creates natural-looking movement by combining multiple sine waves
                // with different frequencies, amplitudes, and phases
                
                float swirl = 0.0; // Accumulated swirl offset
                
                // Layer 1: Base flow - large, slow undulations that define overall shape
                float baseFlow = sin(t * 3.14159 * 2.0 + time * 0.7) * 0.04 * turbulence;
                
                // Layer 2: Medium ripples - secondary movement for more organic feel
                float mediumRipples = sin(t * 3.14159 * 5.0 + time * 1.2) * 0.025 * turbulence;
                
                // Layer 3: Micro-movement - small, rapid oscillations for fine detail
                float microMovement = sin(t * 3.14159 * 12.0 + time * 2.5) * 0.01 * turbulence;
                
                // Layer 4: Detail noise - very fine oscillations for texture
                float detailNoise = sin(t * 3.14159 * 25.0 + time * 4.0) * 0.005 * turbulence;
                
                // Layer 5: Spiral effect - combination of sine and cosine for rotational movement
                float spiral = sin(t * 3.14159 * 3.0 + time * 0.5) * cos(t * 3.14159 * 2.0 + time * 0.3) * 0.02 * turbulence;
                
                // Time-based variation - global shape changes over time
                float timeWave1 = sin(time * 0.3) * 0.01;        // Slow global drift
                float timeWave2 = cos(time * 0.5 + t) * 0.01;     // Position-dependent drift
                
                // Endpoint effect - natural tapering/connection at start/end points
                float endpointEffect = (1.0 - pow(abs(2.0 * t - 1.0), 0.5)) * 0.01;
                
                // ===== COMBINE ALL MOVEMENT LAYERS =====
                // Weight each layer to create complex, organic motion
                swirl = baseFlow + mediumRipples + microMovement + detailNoise + spiral + 
                       timeWave1 + timeWave2 + endpointEffect;
                
                // ===== TEMPORAL SCALING =====
                // Makes the entire tendril pulse/breathe slightly over time
                float tendrilPulse = 0.9 + 0.1 * sin(time * 0.8 + t * 2.0);
                swirl *= tendrilPulse;
                
                // ===== DYNAMIC THICKNESS VARIATION =====
                // Varies thickness along tendril length for more natural appearance
                float thicknessVariation = 0.8 + 0.2 * sin(t * 8.0 + time * 1.5);
                float effectiveThickness = thickness * thicknessVariation;
                
                // Taper effect - thinner at midpoint for stretched/flowing look
                effectiveThickness *= 0.7 + 0.3 * sin(t * 3.14159);
                
                // ===== APPLY SWIRL TO CREATE CURVED PATH =====
                // Offset the straight line by the calculated swirl amount
                vec2 offset = perpendicular * swirl;
                
                // Add secondary movement component for even more complex paths
                vec2 secondary = vec2(direction.x, direction.y); // Parallel to main direction
                offset += secondary * sin(t * 3.14159 * 4.0 + time * 0.9) * 0.01;
                
                // ===== DISTANCE CALCULATION =====
                // Calculate distance from current pixel to the curved tendril path
                float distortedDistance = length(p - (projection + offset));
                
                // ===== SMOOTH FALLOFF =====
                // Create smooth intensity falloff from center of tendril to edges
                // Uses smoothstep for anti-aliased edges
                return smoothstep(effectiveThickness, effectiveThickness * 0.2, distortedDistance);
            }
            
            /**
             * MAIN FLUID DYNAMICS SIMULATION
             * ===============================
             * 
             * Creates the swirling, flowing background effects that respond to touch input.
             * Uses iterative mathematical transformations to create complex fluid-like patterns.
             * 
             * Algorithm Overview:
             * 1. Create multiple trail points following each touch with temporal offsets
             * 2. Generate vector fields using trigonometric functions for swirling motion
             * 3. Apply iterative transformations to create turbulent, flame-like patterns
             * 4. Color mapping using aurora-like gradients
             * 5. Layer multiple effects for depth and complexity
             * 
             * Parameters:
             * - uv: Screen UV coordinates
             * - time: Animation time
             * - touch1/touch2: Normalized touch positions
             * 
             * Returns: RGBA color for this pixel
             */
            vec4 fluidEffect(vec2 uv, float time, vec2 touch1, vec2 touch2) {
                // ===== INITIALIZATION =====
                vec4 o = vec4(0.01);                     // Accumulator for fluid effects
                vec2 r = u_resolution;                   // Screen resolution
                vec2 p = (gl_FragCoord.xy * 2.0 - r) / r.y; // Normalized coordinates (-1 to 1)
                
                // Start with pure black background
                vec4 backgroundColor = vec4(0.0, 0.0, 0.0, 1.0);
                
                // ===== TOUCH INFLUENCE CALCULATION =====
                // Calculate base distance from each touch point
                float t1 = length(p - touch1) * 1.1;    // Distance to first touch
                float t2 = length(p - touch2) * 1.1;    // Distance to second touch
                
                // ===== DYNAMIC FLOW VECTORS =====
                // Create time-varying vectors that make touch points "flow" and leave trails
                // Uses multiple sine/cosine waves for chaotic, organic movement
                vec2 flowVec1 = vec2(
                    sin(time * 0.7) * 0.4 + sin(time * 1.5) * 0.3,  // X component with dual frequencies
                    cos(time * 0.5) * 0.4 + cos(time * 1.7) * 0.3   // Y component with different phases
                );
                vec2 flowVec2 = vec2(
                    sin(time * 0.5 + 2.0) * 0.4 + sin(time * 1.3) * 0.3, // Offset phase for variety
                    cos(time * 0.6 + 1.0) * 0.4 + cos(time * 1.9) * 0.3  // Different frequencies
                );
                
                // ===== TRAIL SYSTEM =====
                // Each touch point creates multiple trailing "ghost" positions
                // This creates the flowing, streamer-like effects
                vec2 trailPos1 = touch1 + flowVec1;     // Primary trail for touch 1
                vec2 trailPos2 = touch2 + flowVec2;     // Primary trail for touch 2
                
                // ===== MULTIPLE TRAIL POINTS =====
                // Create additional trail points at different temporal offsets
                // Each has slightly different distance scaling for varied intensity
                float t1a = length(p - (touch1 + flowVec1 * 0.3)) * 1.3;  // Short trail
                float t1b = length(p - (touch1 + flowVec1 * 0.6)) * 1.4;  // Medium trail
                float t1c = length(p - (touch1 + flowVec1 * 0.9)) * 1.5;  // Longer trail
                float t1d = length(p - (touch1 + flowVec1 * 1.2)) * 1.6;  // Extended trail
                float t1e = length(p - (touch1 + flowVec1 * 1.5)) * 1.7;  // Longest trail
                float t1f = length(p - (touch1 + vec2(sin(time*2.3), cos(time*2.1)) * 0.7)) * 1.5; // Chaotic side trail
                
                // Same trail system for second touch point
                float t2a = length(p - (touch2 + flowVec2 * 0.3)) * 1.3;  // Touch 2 short trail
                float t2b = length(p - (touch2 + flowVec2 * 0.6)) * 1.4;  // Touch 2 medium trail
                float t2c = length(p - (touch2 + flowVec2 * 0.9)) * 1.5;  // Touch 2 longer trail
                float t2d = length(p - (touch2 + flowVec2 * 1.2)) * 1.6;  // Touch 2 extended trail
                float t2e = length(p - (touch2 + flowVec2 * 1.5)) * 1.7;  // Touch 2 longest trail
                float t2f = length(p - (touch2 + vec2(cos(time*2.5), sin(time*1.9)) * 0.7)) * 1.5; // Touch 2 chaotic trail
                
                // ===== COMBINED TOUCH INFLUENCE =====
                // Find the minimum distance to any trail point (closest = strongest effect)
                float touchEffect = min(
                    min(min(min(t1, t1a), min(t1b, t1c)), min(min(t1d, t1e), t1f)),    // All touch 1 trails
                    min(min(min(t2, t2a), min(t2b, t2c)), min(min(t2d, t2e), t2f))     // All touch 2 trails
                );
                // Clamp to prevent division by zero and control intensity range
                touchEffect = clamp(touchEffect, 0.06, 1.0);
                
                // ===== FLUID DYNAMICS VECTOR FIELD =====
                // Create the base flow field that will be iteratively transformed
                vec2 l = vec2(0.0);                     // Accumulator for flow effects
                // Base vector field influenced by touch proximity
                vec2 v = p * (1.0 - (l += abs(0.7 - dot(p, p)))) / (max(0.05, touchEffect * 0.1));
                
                // ===== VORTICITY FIELD =====
                // Add rotational motion using curl-like vector field
                // Creates the characteristic swirling patterns
                vec2 curl = vec2(
                    sin(p.y * 5.0 + time) * cos(p.x * 4.0 - time * 0.7) + sin(p.y * 8.0 - time * 1.3) * 0.3,
                    cos(p.x * 5.0 - time) * sin(p.y * 4.0 + time * 0.7) + cos(p.x * 8.0 + time * 1.3) * 0.3
                ) * 0.25;
                
                v += curl; // Combine base field with rotational component
                
                // ===== TURBULENT NOISE =====
                // Add fractal-like noise to create more complex, chaotic flow
                v.x += 0.2 * sin(v.y * 4.0 + time * 0.9) * cos(v.x * 3.0);  // X-component turbulence
                v.y += 0.2 * cos(v.x * 4.0 - time * 0.8) * sin(v.y * 3.0);  // Y-component turbulence
                
                // ===== ITERATIVE FLOW TRANSFORMATION =====
                // This is the heart of the fluid simulation - repeatedly transform the vector field
                // to create complex, organic patterns. More iterations = more detail but slower performance
                // WebGL 1.0 requires compile-time constant loop bounds
                for(float i = 0.0; i < 12.0; i++) { // Iteration count matches gameSettings.fluidIterations
                    float ii = i + 1.0;  // Current iteration (1-based for mathematical operations)
                    
                    // ===== TEMPORAL FLOW OFFSETS =====
                    // Create time-varying offsets that change the flow pattern each iteration
                    vec2 offset = vec2(
                        sin(time * 0.4 + ii * 0.2 + sin(time)) * 0.6,     // X offset with nested sine
                        cos(time * 0.3 + ii * 0.2 + cos(time)) * 0.6      // Y offset with nested cosine
                    );
                    
                    // ===== SPATIAL WARPING =====
                    // Create fire-like movement by warping based on current vector field position
                    vec2 warp = vec2(
                        sin(v.x * 2.0 + time * 0.6) * 0.3 + sin(v.x * 5.0 - time * 0.3) * 0.1,  // Multi-frequency X warp
                        cos(v.y * 2.0 + time * 0.5) * 0.3 + cos(v.y * 5.0 - time * 0.2) * 0.1   // Multi-frequency Y warp
                    );
                    
                    // ===== MAIN ITERATION TRANSFORMATION =====
                    // This is where the magic happens - creates the snake-like, flowing patterns
                    // Each iteration adds complexity and detail to the flow
                    v += cos(v.yx * ii * 0.7 + offset + time * 0.8) / (ii * 0.4) + warp + 0.6;
                    
                    // ===== FLAME-LIKE FLICKERING =====
                    // Add temporal variation to create organic, flame-like intensity changes
                    float flicker = 0.8 + sin(time * 5.0 + ii) * 0.2 + sin(time * 9.0 + ii * 0.7) * 0.1;
                    
                    // ===== ACCUMULATE COLOR INTENSITY =====
                    // Build up the final color by accumulating transformed vector field values
                    o += (sin(v.xyyx * 1.8 + time * 0.4) + 1.0) * abs(v.x - v.y) * 0.3 * flicker;
                }
                
                // ===== COLOR INTENSITY CALCULATION =====
                // Convert accumulated flow values into color intensity
                float intensity = clamp(o.x + o.y + o.z + o.w, 0.1, 4.0);  // Sum all color components
                float factor = exp(-1.8 * l.x) / intensity * 2.0;          // Exponential falloff for dramatic contrast
                
                // ===== TEXTURE NOISE GENERATION =====
                // Add fine-grain texture noise for detailed visual richness at touch points
                float noise1 = sin(p.x * 30.0 + time) * sin(p.y * 30.0 + time * 1.2) * 0.5 + 0.5;  // High-freq noise 1
                float noise2 = sin(p.x * 20.0 - time * 1.3) * sin(p.y * 20.0 + time) * 0.5 + 0.5;   // High-freq noise 2
                
                // ===== AURORA COLOR GENERATION =====
                // Create dynamic, shifting colors reminiscent of northern lights
                // Uses the transformed vector field to drive color variation
                vec4 auroraColor = vec4(
                    0.5 * (1.0 + sin(v.x * 3.0 + time * 0.4 + noise1 * 0.5)),      // Red channel - varies with X flow
                    0.8 * (1.0 + sin(v.y * 2.0 + time * 0.5 + noise2 * 0.7)),      // Green channel - varies with Y flow  
                    0.7 * (1.0 + sin(v.x * v.y + time * 0.6 + noise1 * noise2)),   // Blue channel - XY interaction
                    1.0
                );
                
                // ===== DYNAMIC CORE COLORS =====
                // Each touch point has its own pulsing color signature
                // These colors change over time to create organic, living feel
                vec4 core1Color = vec4(
                    0.1 + 0.4 * sin(time * 2.0),           // Red: slow pulsing
                    0.9 + 0.3 * sin(time * 2.5 + 2.0),     // Green: dominant with phase offset
                    0.6 + 0.4 * sin(time * 3.0 + 4.0),     // Blue: faster pulsing with different phase
                    1.0
                );
                
                vec4 core2Color = vec4(
                    0.2 + 0.4 * sin(time * 2.2 + 1.0),     // Red: slightly different frequency + phase
                    0.3 + 0.3 * sin(time * 2.7 + 3.0),     // Green: lower intensity than touch 1
                    0.9 + 0.3 * sin(time * 3.2 + 5.0),     // Blue: dominant for touch 2
                    1.0
                );
                
                // ===== TOUCH POINT INTENSITY CALCULATION =====
                // Calculate how close we are to each touch point and convert to color intensity
                // Uses power function for sharp falloff - creates bright cores with soft edges
                float coreFactor1 = 4.0 * pow(1.0 - min(1.0, t1 * 0.8), 5.0);  // Touch 1 core intensity
                float coreFactor2 = 4.0 * pow(1.0 - min(1.0, t2 * 0.8), 5.0);  // Touch 2 core intensity
                
                // ===== TRAIL INTENSITY FACTORS =====
                // Calculate intensity for each trail point - creates the flowing streamer effect
                // Each trail point has decreasing intensity and size for natural falloff
                float trailFactor1 = 3.0 * pow(1.0 - min(1.0, t1 * 0.9), 4.0);        // Primary trail
                float trailFactor1a = 2.5 * pow(1.0 - min(1.0, t1a * 0.9), 4.0) * 0.7;  // Secondary trail (70%)
                float trailFactor1b = 2.0 * pow(1.0 - min(1.0, t1b * 0.9), 4.0) * 0.5;  // Tertiary trail (50%)
                float trailFactor1c = 1.5 * pow(1.0 - min(1.0, t1c * 0.9), 4.0) * 0.4;  // Quaternary trail (40%)
                float trailFactor1d = 1.2 * pow(1.0 - min(1.0, t1d * 0.9), 4.0) * 0.3;  // Extended trail (30%)
                float trailFactor1e = 1.0 * pow(1.0 - min(1.0, t1e * 0.9), 4.0) * 0.2;  // Longest trail (20%)
                float trailFactor1f = 2.0 * pow(1.0 - min(1.0, t1f * 0.9), 4.0) * 0.6;  // Chaotic side trail (60%)
                
                // Same intensity calculations for touch point 2 trail system
                float trailFactor2 = 3.0 * pow(1.0 - min(1.0, t2 * 0.9), 4.0);        // Touch 2 primary trail
                float trailFactor2a = 2.5 * pow(1.0 - min(1.0, t2a * 0.9), 4.0) * 0.7;  // Touch 2 secondary (70%)
                float trailFactor2b = 2.0 * pow(1.0 - min(1.0, t2b * 0.9), 4.0) * 0.5;  // Touch 2 tertiary (50%)
                float trailFactor2c = 1.5 * pow(1.0 - min(1.0, t2c * 0.9), 4.0) * 0.4;  // Touch 2 quaternary (40%)
                float trailFactor2d = 1.2 * pow(1.0 - min(1.0, t2d * 0.9), 4.0) * 0.3;  // Touch 2 extended (30%)
                float trailFactor2e = 1.0 * pow(1.0 - min(1.0, t2e * 0.9), 4.0) * 0.2;  // Touch 2 longest (20%)
                float trailFactor2f = 2.0 * pow(1.0 - min(1.0, t2f * 0.9), 4.0) * 0.6;  // Touch 2 chaotic (60%)
                
                // ===== TEXTURED CORE COLORS =====
                // Blend base colors with dynamic core colors using texture noise
                // Creates detailed, organic texture at the center of each touch point
                vec4 coreTouch1 = mix(
                    vec4(0.0, 0.9, 0.5, 1.0),  // Base green-cyan color for touch 1
                    core1Color,                 // Dynamic pulsing color
                    noise1                      // Texture noise for detail
                ) * coreFactor1;                // Apply distance-based intensity
                
                vec4 coreTouch2 = mix(
                    vec4(0.1, 0.3, 0.9, 1.0),  // Base blue color for touch 2
                    core2Color,                 // Dynamic pulsing color
                    noise2                      // Different texture noise
                ) * coreFactor2;                // Apply distance-based intensity
                
                // ===== TOUCH 1 TRAIL COLORS (Green Magic Theme) =====
                // Each trail segment has slightly different color and intensity for natural gradient
                vec4 touch1Color = vec4(0.0, 1.0, 0.6, 1.0) * trailFactor1;           // Bright green primary
                vec4 touch1ColorA = vec4(0.0, 0.95, 0.55, 1.0) * trailFactor1a;       // Slightly dimmer green
                vec4 touch1ColorB = vec4(0.0, 0.9, 0.5, 1.0) * trailFactor1b;         // Medium green
                vec4 touch1ColorC = vec4(0.0, 0.85, 0.45, 1.0) * trailFactor1c;       // Darker green
                vec4 touch1ColorD = vec4(0.0, 0.8, 0.4, 1.0) * trailFactor1d;         // Even darker green
                vec4 touch1ColorE = vec4(0.0, 0.75, 0.35, 1.0) * trailFactor1e;       // Darkest green
                vec4 touch1ColorF = mix(vec4(0.3, 1.0, 0.6, 1.0), vec4(0.1, 0.8, 0.4, 1.0), noise1) * trailFactor1f; // Chaotic trail with noise
                
                // ===== TOUCH 2 TRAIL COLORS (Blue Magic Theme) =====
                // Complementary blue theme for second touch point
                vec4 touch2Color = vec4(0.1, 0.4, 1.0, 1.0) * trailFactor2;           // Bright blue primary
                vec4 touch2ColorA = vec4(0.1, 0.38, 0.95, 1.0) * trailFactor2a;       // Slightly dimmer blue
                vec4 touch2ColorB = vec4(0.1, 0.36, 0.9, 1.0) * trailFactor2b;        // Medium blue
                vec4 touch2ColorC = vec4(0.1, 0.34, 0.85, 1.0) * trailFactor2c;       // Darker blue
                vec4 touch2ColorD = vec4(0.1, 0.32, 0.8, 1.0) * trailFactor2d;        // Even darker blue
                vec4 touch2ColorE = vec4(0.1, 0.3, 0.75, 1.0) * trailFactor2e;        // Darkest blue
                vec4 touch2ColorF = mix(vec4(0.2, 0.5, 1.0, 1.0), vec4(0.0, 0.3, 0.8, 1.0), noise2) * trailFactor2f; // Chaotic trail with noise
                
                // ===== COMBINE ALL TRAIL EFFECTS =====
                // Sum all trail colors to create the final flowing effect
                // This creates the smoky, streamer-like trails behind each touch point
                vec4 combinedTrailColor = coreTouch1 + touch1Color + touch1ColorA + touch1ColorB + touch1ColorC + 
                                        touch1ColorD + touch1ColorE + touch1ColorF +              // Touch 1 trails
                                        coreTouch2 + touch2Color + touch2ColorA + touch2ColorB + touch2ColorC + 
                                        touch2ColorD + touch2ColorE + touch2ColorF;               // Touch 2 trails
                
                // ===== ACTIVITY DETECTION =====
                // Measure how much visual activity is happening at this pixel
                // Used to blend between background and active effects
                float activity = clamp(length(combinedTrailColor), 0.0, 1.0);
                
                // ===== FINAL FLUID COLOR COMPOSITION =====
                // Layer the background aurora effect with the dynamic trail effects
                vec4 fluidColor = mix(backgroundColor, auroraColor * factor * 3.0, clamp(intensity * 0.5, 0.0, 1.0));
                fluidColor = mix(fluidColor, combinedTrailColor, 0.9);  // Heavy bias toward trail colors
                
                // ===== BACKGROUND ENERGY FIELD =====
                // Add subtle background patterns when enabled via control panel
                // Creates ambient energy feel even when not actively touching
                float backgroundEnergy = 0.0;
                if (u_enable_background > 0.5) {
                    // Primary background pattern - grid-like energy field
                    backgroundEnergy = 0.12 * (0.5 + 0.5 * sin(p.x * 8.0 + time) * sin(p.y * 8.0 + time * 0.7));
                    // Secondary pattern - adds complexity and prevents repetition
                    backgroundEnergy += 0.08 * sin(p.x * p.y * 5.0 + time * 0.5);
                }
                
                // ===== TENDRIL/LIGHTNING EFFECTS =====
                // Create organic lightning/tendril connections between touch points
                // Only active when touch points are sufficiently separated and effect is enabled
                float touchDistance = length(touch1 - touch2);  // Distance between touch points
                vec4 lightningColor = vec4(0.0);                // Initialize tendril color
                
                // Minimum distance threshold prevents tendrils when points are too close
                if (touchDistance > 0.15 && u_enable_tendrils > 0.5) {
                    // ===== TENDRIL PARAMETER SETUP =====
                    // Apply user-controlled settings from the control panel
                    float baseThickness = 0.01 * u_tendril_thickness;   // Base tendril width
                    float baseTurbulence = 1.0 * u_tendril_turbulence;  // Swirl/organic movement intensity
                    
                    // ===== MULTI-LAYERED TENDRIL SYSTEM =====
                    // Create multiple tendril layers with different properties for organic complexity
                    
                    // ===== PRIMARY TENDRIL =====
                    // Main tendril - bright, medium thickness, normal speed
                    float tendrilIntensity1 = swirlTendril(p, touch1, touch2, time, baseThickness, baseTurbulence);
                    
                    // ===== SECONDARY TENDRIL =====
                    // Offset in time for different swirl pattern, slightly thinner
                    float tendrilIntensity2 = swirlTendril(p, touch1, touch2, time + 4.27, baseThickness * 0.8, baseTurbulence * 0.8);
                    
                    // ===== TERTIARY TENDRIL =====
                    // Slower movement, thinner, higher turbulence for detail
                    float tendrilIntensity3 = swirlTendril(p, touch1, touch2, time * 0.7, baseThickness * 0.5, baseTurbulence * 1.2);
                    
                    // ===== MICRO-TENDRILS =====
                    // Very thin tendrils for organic complexity and detail
                    float microTendril1 = swirlTendril(p, touch1, touch2, time * 1.3 + 2.8, baseThickness * 0.3, baseTurbulence * 1.5);
                    float microTendril2 = swirlTendril(p, touch1, touch2, time * 0.9 - 3.6, baseThickness * 0.25, baseTurbulence * 1.7);
                    
                    // ===== TENDRIL COLOR SYSTEM =====
                    // Each tendril layer has its own color signature for visual depth
                    
                    // Primary tendril - orange-red core (hottest part of "flame")
                    vec4 primaryTendril = vec4(0.9, 0.3, 0.05, 1.0) * tendrilIntensity1;
                    
                    // Secondary tendril - yellow-orange (flame edge color)
                    vec4 secondaryTendril = vec4(1.0, 0.5, 0.05, 1.0) * tendrilIntensity2;
                    
                    // Tertiary tendril - deeper red (flame base color)
                    vec4 tertiaryTendril = vec4(0.7, 0.1, 0.05, 1.0) * tendrilIntensity3;
                    
                    // Micro-tendrils - purple/blue tints for magical contrast
                    vec4 microTendrilColor1 = vec4(0.3, 0.1, 0.5, 1.0) * microTendril1 * 0.5;  // Purple micro-tendril
                    vec4 microTendrilColor2 = vec4(0.1, 0.05, 0.3, 1.0) * microTendril2 * 0.4; // Blue micro-tendril
                    
                    // ===== TEMPORAL COLOR VARIATION =====
                    // Add time-based variation to make tendrils feel alive and organic
                    float colorShift = sin(time * 1.5) * 0.3 + 0.7;                        // Slow color shifting
                    float intensityPulse = 0.7 + 0.3 * pow(sin(time * 2.3) * 0.5 + 0.5, 2.0); // Intensity pulsing
                    
                    // ===== COMBINE ALL TENDRIL LAYERS =====
                    // Blend all tendril effects with time-based variations
                    lightningColor = primaryTendril * intensityPulse +                      // Pulsing primary
                                    secondaryTendril * colorShift +                        // Color-shifting secondary
                                    tertiaryTendril * (0.6 + 0.4 * sin(time * 1.1)) +    // Oscillating tertiary
                                    microTendrilColor1 + microTendrilColor2;               // Steady micro-tendrils
                    
                    // ===== TENDRIL GLOW EFFECT =====
                    // Add soft halo around tendrils using control panel glow setting
                    float glowThickness = 0.05 * u_tendril_glow;  // User-controlled glow size
                    float glowIntensity = swirlTendril(p, touch1, touch2, time * 0.8, glowThickness, baseTurbulence * 0.5) * 0.3;
                    lightningColor += vec4(0.5, 0.1, 0.05, 0.7) * glowIntensity * u_tendril_glow; // Orange glow
                }
                
                // ===== FINAL COLOR COMPOSITION =====
                // Layer all effects together: background -> energy field -> fluid -> tendrils
                vec4 finalColor = mix(
                    mix(backgroundColor, auroraColor * 0.4, backgroundEnergy),  // Background with energy field
                    fluidColor,                                                 // Fluid dynamics layer
                    clamp(activity * 4.0, 0.0, 1.0)                           // Activity-based blending
                );
                
                // ===== ADD TENDRIL EFFECTS =====
                // Tendrils are additive - they brighten the final image
                finalColor += lightningColor;
                
                return finalColor;
            }
            
            /**
             * FRAGMENT SHADER MAIN FUNCTION
             * ==============================
             * 
             * Entry point for fragment shader execution.
             * Processes uniforms, calls main effects functions, handles target highlighting,
             * and applies shockwave effects.
             */
            void main() {
                // ===== COORDINATE TRANSFORMATION =====
                // Convert touch coordinates from 0-1 range to -1 to 1 range for shader math
                vec2 touch1 = u_touch1 * 2.0 - 1.0;
                vec2 touch2 = u_touch2 * 2.0 - 1.0;
                touch1.y *= -1.0;  // Flip Y coordinate (WebGL vs screen coordinate system)
                touch2.y *= -1.0;
                
                // ===== GENERATE BASE FLUID EFFECTS =====
                // Call the main fluid dynamics function to get base color
                vec4 color = fluidEffect(gl_FragCoord.xy / u_resolution, u_time, touch1, touch2);
                
                // ===== TARGET HIGHLIGHTING SYSTEM =====
                // Pre-calculate pixel position in normalized coordinates for target effects
                vec2 normalizedPos = gl_FragCoord.xy / u_resolution * 2.0 - 1.0;
                
                // Process each potential target slot
                for (int i = 0; i < ${MAX_TARGETS}; i++) {
                    // Only process active targets
                    if (u_target_active[i] > 0.5) {
                        // ===== TARGET POSITION SETUP =====
                        // Convert target position to normalized coordinates
                        vec2 targetPos = u_targets[i] * 2.0 - 1.0;
                        targetPos.y *= -1.0;  // Flip Y coordinate
                        float dist = length(normalizedPos - targetPos);  // Distance to target center
                        
                        // Only apply glow effect within target radius
                        if (dist < 0.1) {
                            // ===== PULSING ANIMATION =====
                            // Create rhythmic pulsing for visual appeal
                            float pulse = sin(u_time * 8.0) * 0.2 + 0.8;        // Base pulse (0.6-1.0)
                            float glow = (0.1 - dist) / 0.1 * pulse;             // Distance-based intensity
                            
                            // ===== TARGET TYPE-SPECIFIC EFFECTS =====
                            if (u_target_type[i] < 0.5) {
                                // GOOD TARGET - Green theme with sparkles
                                vec4 glowColor = vec4(0.0, 1.0, 0.5, 1.0);      // Bright green base
                                // Add sparkle effect for positive reinforcement
                                glowColor += vec4(0.2) * pow(sin(u_time * 10.0 + dist * 50.0), 10.0);
                                color = mix(color, glowColor, glow * 0.8 + 0.3 * sin(u_time * 6.0));
                            } else {
                                // BAD TARGET - Red theme with warning pulses
                                vec4 glowColor = vec4(1.0, 0.2, 0.3, 1.0);      // Bright red base
                                // Add intense warning pulse effect
                                glowColor += vec4(0.3, 0.0, 0.0, 0.0) * pow(sin(u_time * 15.0), 4.0);
                                color = mix(color, glowColor, glow * 0.8 + 0.3 * sin(u_time * 6.0));
                            }
                        }
                    }
                }
                
                // ===== SHOCKWAVE EFFECTS SYSTEM =====
                // Process expanding ring effects when targets are collected
                if (u_enable_shockwaves > 0.5) {
                    // Check each potential shockwave slot
                    for (int i = 0; i < ${MAX_TARGETS}; i++) {
                        // Only process active shockwaves
                        if (u_shockwave_active[i] > 0.5) {
                            // ===== SHOCKWAVE POSITION SETUP =====
                            // Convert shockwave center to normalized coordinates
                            vec2 shockwavePos = u_shockwave_pos[i] * 2.0 - 1.0;
                            shockwavePos.y *= -1.0;  // Flip Y coordinate
                            
                            // ===== SHOCKWAVE TIMING =====
                            float timeSinceStart = u_time - u_shockwave_start[i];  // How long since shockwave began
                            
                            // Shockwaves last for 1 second
                            if (timeSinceStart < 1.0) {
                                // ===== SHOCKWAVE GEOMETRY =====
                                float waveRadius = timeSinceStart * 0.6;                    // Expansion speed
                                float dist = length(normalizedPos - shockwavePos);          // Distance from center
                                float thickness = 0.03 * (1.0 - timeSinceStart);           // Ring thickness (thins over time)
                                
                                // ===== RING SHAPE CALCULATION =====
                                // Create a ring by checking distance to expanding wavefront
                                float waveFront = smoothstep(0.0, thickness, abs(dist - waveRadius));
                                waveFront = 1.0 - waveFront;  // Invert for ring shape
                                
                                // ===== SHOCKWAVE COLORING =====
                                // Only render visible parts of the wave
                                if (waveFront > 0.05) {
                                    // Color based on original target type
                                    if (u_shockwave_type[i] < 0.5) {
                                        // GOOD TARGET SHOCKWAVE - Green expanding ring
                                        vec4 waveColor = vec4(0.0, 1.0, 0.5, 1.0) * (1.0 - timeSinceStart) * 0.7 * u_shockwave_intensity;
                                        color += waveColor * waveFront;
                                    } else {
                                        // BAD TARGET SHOCKWAVE - Red expanding ring
                                        vec4 waveColor = vec4(1.0, 0.2, 0.3, 1.0) * (1.0 - timeSinceStart) * 0.7 * u_shockwave_intensity;
                                        color += waveColor * waveFront;
                                    }
                                    
                                    // ===== INNER DISTORTION EFFECT =====
                                    // Add color distortion inside the shockwave for impact feel
                                    if (dist < waveRadius) {
                                        float distortionFactor = 0.05 * (1.0 - dist/waveRadius) * (1.0 - timeSinceStart) * u_shockwave_intensity;
                                        color.rgb += sin(color.gbr * 10.0 + u_time * 5.0) * distortionFactor;
                                    }
                                }
                            }
                        }
                    }
                }
                
                // ===== FINAL OUTPUT =====
                // Output the final composed color
                gl_FragColor = color;
            }
        `;
        
        // =============================================================================
        // WEBGL SHADER COMPILATION SYSTEM
        // =============================================================================
        
        /**
         * Create and compile a WebGL shader from source code
         * 
         * @param {WebGLRenderingContext} gl - WebGL context
         * @param {number} type - Shader type (gl.VERTEX_SHADER or gl.FRAGMENT_SHADER)
         * @param {string} source - GLSL shader source code
         * @returns {WebGLShader|null} Compiled shader or null on error
         */
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compilation error:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            
            return shader;
        }
        
        /**
         * Link vertex and fragment shaders into a complete WebGL program
         * 
         * @param {WebGLRenderingContext} gl - WebGL context
         * @param {WebGLShader} vertexShader - Compiled vertex shader
         * @param {WebGLShader} fragmentShader - Compiled fragment shader
         * @returns {WebGLProgram|null} Linked program or null on error
         */
        function createProgram(gl, vertexShader, fragmentShader) {
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Program linking error:', gl.getProgramInfoLog(program));
                return null;
            }
            
            return program;
        }
        
        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
        const program = createProgram(gl, vertexShader, fragmentShader);
        
        // Set up position buffer
        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
            -1, -1,
            1, -1,
            -1, 1,
            -1, 1,
            1, -1,
            1, 1
        ]), gl.STATIC_DRAW);
        
        // Get uniform locations
        const resolutionUniformLocation = gl.getUniformLocation(program, 'u_resolution');
        const timeUniformLocation = gl.getUniformLocation(program, 'u_time');
        const touch1UniformLocation = gl.getUniformLocation(program, 'u_touch1');
        const touch2UniformLocation = gl.getUniformLocation(program, 'u_touch2');
        
        // Get target uniform locations
        const targetLocations = [];
        const targetActiveLocations = [];
        const targetTypeLocations = [];
        for (let i = 0; i < MAX_TARGETS; i++) {
            targetLocations.push(gl.getUniformLocation(program, `u_targets[${i}]`));
            targetActiveLocations.push(gl.getUniformLocation(program, `u_target_active[${i}]`));
            targetTypeLocations.push(gl.getUniformLocation(program, `u_target_type[${i}]`));
        }
        
        // Get shockwave uniform locations
        const shockwaveActiveLocations = [];
        const shockwavePosLocations = [];
        const shockwaveStartLocations = [];
        const shockwaveTypeLocations = [];
        for (let i = 0; i < MAX_TARGETS; i++) {
            shockwaveActiveLocations.push(gl.getUniformLocation(program, `u_shockwave_active[${i}]`));
            shockwavePosLocations.push(gl.getUniformLocation(program, `u_shockwave_pos[${i}]`));
            shockwaveStartLocations.push(gl.getUniformLocation(program, `u_shockwave_start[${i}]`));
            shockwaveTypeLocations.push(gl.getUniformLocation(program, `u_shockwave_type[${i}]`));
        }
        
        // =============================================================================
        // INPUT HANDLING SYSTEM
        // =============================================================================
        
        /**
         * Touch and mouse state management
         * Default positions create a subtle initial effect when game loads
         */
        let touch1 = { x: 0.25, y: 0.5 };  // First touch point (normalized 0-1 coordinates)
        let touch2 = { x: 0.75, y: 0.5 };  // Second touch point (normalized 0-1 coordinates)
        let isMouseDown = false;            // Mouse button state for desktop users
        
        /**
         * Handle touch events for mobile/tablet users
         * Supports multi-touch - up to 2 simultaneous touch points
         * Also triggers target collection checking and game rule evaluation
         * 
         * @param {TouchEvent} e - Touch event from browser
         */
        function handleTouches(e) {
            e.preventDefault();  // Prevent default browser touch behaviors (scrolling, etc.)
            
            // ===== GAME STATE UPDATES =====
            // Track dual-touch state for gameplay mechanics
            bothThumbsActive = (e.touches.length >= 2);
            
            // ===== TOUCH POSITION UPDATES =====
            // Update first touch point if available
            if (e.touches.length >= 1) {
                touch1.x = e.touches[0].clientX / canvas.width;   // Normalize to 0-1 range
                touch1.y = e.touches[0].clientY / canvas.height;
            }
            
            // Update second touch point if available (dual-touch mode)
            if (e.touches.length >= 2) {
                touch2.x = e.touches[1].clientX / canvas.width;   // Normalize to 0-1 range
                touch2.y = e.touches[1].clientY / canvas.height;
                
                // Initialize bonus score timing on first dual-touch activation
                if (lastActiveScoreTime === 0) {
                    lastActiveScoreTime = Date.now();
                }
            }
            
            // ===== GAMEPLAY MECHANICS =====
            // Check if touch points are overlapping any targets
            checkTargets();
        }
        
        /**
         * Handle mouse movement for desktop users
         * Creates a dual-touch simulation using mouse position and its inverse
         * This allows desktop users to experience the dual-stream effects
         * 
         * @param {MouseEvent} e - Mouse event from browser
         */
        function handleMouseMove(e) {
            // Only process if mouse button is held down
            if (!isMouseDown) return;
            
            // ===== PRIMARY TOUCH SIMULATION =====
            // First touch point follows mouse directly
            touch1.x = e.clientX / canvas.width;   // Normalize mouse X to 0-1
            touch1.y = e.clientY / canvas.height;  // Normalize mouse Y to 0-1
            
            // ===== SECONDARY TOUCH SIMULATION =====
            // Create artificial second touch point using inverse coordinates
            // This creates interesting symmetrical effects for desktop users
            touch2.x = 1 - touch1.x;  // Opposite side horizontally
            touch2.y = 1 - touch1.y;  // Opposite side vertically
            
            // ===== GAMEPLAY MECHANICS =====
            // Check for target collection with simulated dual-touch
            checkTargets();
        }
        
        /**
         * Handle mouse button press for desktop users
         * Activates the dual-touch simulation and initializes game mechanics
         * 
         * @param {MouseEvent} e - Mouse event from browser
         */
        function handleMouseDown(e) {
            // ===== MOUSE STATE ACTIVATION =====
            isMouseDown = true;
            
            // ===== GAME STATE SETUP =====
            // Desktop mouse simulates dual-touch gameplay
            bothThumbsActive = true;
            if (lastActiveScoreTime === 0) {
                lastActiveScoreTime = Date.now();  // Start bonus score timer
            }
            
            // ===== INITIAL POSITION SETUP =====
            // Set up both simulated touch points
            touch1.x = e.clientX / canvas.width;   // Primary follows mouse
            touch1.y = e.clientY / canvas.height;
            
            touch2.x = 1 - touch1.x;  // Secondary is inverse position
            touch2.y = 1 - touch1.y;
            
            // ===== IMMEDIATE TARGET CHECK =====
            // Check for targets on initial mouse press
            checkTargets();
        }
        
        /**
         * Handle mouse button release for desktop users
         * Deactivates the dual-touch simulation
         */
        function handleMouseUp() {
            // ===== DEACTIVATE MOUSE SIMULATION =====
            isMouseDown = false;        // Stop mouse tracking
            bothThumbsActive = false;   // End dual-touch simulation
        }
        
        /**
         * Handle direct clicks on targets for easier desktop gameplay
         * Provides an alternative to the flowing touch mechanics
         * Allows users to click directly on targets to collect them
         * 
         * @param {MouseEvent} e - Mouse click event
         */
        function handleClick(e) {
            // ===== CLICK POSITION CALCULATION =====
            const mouseX = e.clientX / canvas.width;   // Normalize click X to 0-1
            const mouseY = e.clientY / canvas.height;  // Normalize click Y to 0-1
            
            // ===== TARGET COLLISION DETECTION =====
            // Check each active target for collision with click position
            targets.forEach(target => {
                if (target.collected) return;  // Skip already collected targets
                
                // Calculate distance from click to target center
                const dist = Math.hypot(
                    target.x - mouseX,
                    target.y - mouseY
                );
                
                // Collection radius: same as touch-based collection
                if (dist < 0.08) {
                    collectTarget(target);
                }
            });
        }
        
        // Touch events
        canvas.addEventListener('touchstart', handleTouches);
        canvas.addEventListener('touchmove', handleTouches);
        
        // Mouse events
        canvas.addEventListener('mousedown', handleMouseDown);
        canvas.addEventListener('mousemove', handleMouseMove);
        canvas.addEventListener('mouseup', handleMouseUp);
        canvas.addEventListener('mouseleave', handleMouseUp);
        canvas.addEventListener('click', handleClick);
        
        // =============================================================================
        // SCORING SYSTEM
        // =============================================================================
        
        /**
         * Update player score with visual and audio feedback
         * Handles both positive and negative score changes with appropriate effects
         * 
         * @param {number} points - Points to add (positive) or subtract (negative)
         */
        function updateScore(points) {
            // ===== UPDATE SCORE VALUE =====
            score += points;
            document.getElementById('score').textContent = `Score: ${score}`;
            
            // ===== VISUAL FEEDBACK SETUP =====
            const scoreElement = document.getElementById('score');
            scoreElement.classList.remove('negative');  // Clear previous state
            
            // ===== POSITIVE SCORE FEEDBACK =====
            if (points > 0) {
                scoreDirection = 1;  // Track positive direction for animations
                
                // Audio feedback for positive actions
                if (audioEnabled) {
                    createCollectSound();  // Pleasant major arpeggio
                }
                
                // Haptic feedback - short, pleasant vibration
                vibrate(50);
                
            // ===== NEGATIVE SCORE FEEDBACK =====
            } else {
                scoreDirection = -1;  // Track negative direction for animations
                scoreElement.classList.add('negative');  // Red color styling
                
                // Audio feedback for negative actions
                if (audioEnabled) {
                    createBadSound();  // Harsh, warning sound
                }
                
                // Haptic feedback - longer, more intense vibration pattern
                vibrate([50, 50, 100]);
            }
            
            // ===== TIMING RECORDS =====
            lastScoreChange = Date.now();  // Record when score changed for animations
            
            // ===== RESET VISUAL STATE =====
            // Remove negative styling after brief display period
            setTimeout(() => {
                scoreElement.classList.remove('negative');
            }, 500);
        }
        
        // =============================================================================
        // TARGET MANAGEMENT SYSTEM
        // =============================================================================
        
        /**
         * Generate a new target at a random position
         * Creates either a good target (green, gives points) or bad target (red, loses points)
         * Targets appear as pulsing circles with CSS animations
         */
        function createTarget() {
            // ===== TARGET LIMIT CHECK =====
            // Don't exceed maximum simultaneous targets
            if (targets.length >= MAX_TARGETS) return;
            
            // ===== TARGET TYPE DETERMINATION =====
            // 30% chance for penalty targets, 70% for reward targets
            const isBad = Math.random() < 0.3;
            
            // ===== TARGET OBJECT CREATION =====
            const target = {
                x: Math.random() * 0.8 + 0.1,  // Random X position (10%-90% to avoid edges)
                y: Math.random() * 0.8 + 0.1,  // Random Y position (10%-90% to avoid edges)
                createdAt: Date.now(),          // Timestamp for lifespan tracking
                collected: false,               // Collection state flag
                isBad: isBad,                   // Target type (good/bad)
                element: document.createElement('div')  // DOM element for visual representation
            };
            
            // ===== VISUAL SETUP =====
            // Apply CSS styling based on target type
            target.element.className = isBad ? 'target bad' : 'target good';
            target.element.style.left = `${target.x * 100}%`;   // Position element
            target.element.style.top = `${target.y * 100}%`;
            
            // ===== ADD TO DOM AND TRACKING =====
            document.getElementById('targets').appendChild(target.element);
            targets.push(target);
        }
        
        /**
         * Remove a target from both DOM and tracking array
         * Called when targets expire or are collected
         * 
         * @param {Object} target - Target object to remove
         */
        function removeTarget(target) {
            // ===== DOM CLEANUP =====
            target.element.remove();  // Remove visual element from page
            
            // ===== ARRAY CLEANUP =====
            targets = targets.filter(t => t !== target);  // Remove from tracking array
        }
        
        /**
         * Update target system - remove expired targets and generate new ones
         * Called every frame to maintain target population and handle lifecycle
         */
        function updateTargets() {
            const now = Date.now();
            
            // ===== EXPIRED TARGET CLEANUP =====
            // Remove targets that have exceeded their lifespan
            targets.forEach(target => {
                if (now - target.createdAt > targetLifespan && !target.collected) {
                    removeTarget(target);
                }
            });
            
            // ===== NEW TARGET GENERATION =====
            // Randomly generate new targets if below maximum count
            // Generation rate is controlled by user settings
            const generationChance = 0.01 * gameSettings.targetGenerationRate;
            if (targets.length < MAX_TARGETS && Math.random() < generationChance) {
                createTarget();
            }
        }
        
        // =============================================================================
        // SHOCKWAVE EFFECTS SYSTEM
        // =============================================================================
        
        /**
         * Create a new expanding shockwave effect when a target is collected
         * Shockwaves are visual feedback that expand outward from collection point
         * Color matches the collected target type (green=good, red=bad)
         * 
         * @param {number} x - X position of shockwave center (0-1 normalized)
         * @param {number} y - Y position of shockwave center (0-1 normalized) 
         * @param {boolean} isGood - Whether this was a good target (affects color)
         */
        function createShockwave(x, y, isGood) {
            // ===== FIND AVAILABLE SHOCKWAVE SLOT =====
            // Shockwaves reuse the same array slots as targets for efficiency
            let index = -1;
            for (let i = 0; i < MAX_TARGETS; i++) {
                if (!shockwaves[i] || !shockwaves[i].active) {
                    index = i;  // Found an available slot
                    break;
                }
            }
            
            // ===== SLOT AVAILABILITY CHECK =====
            // If all slots are busy with active shockwaves, skip this one
            if (index === -1) return;
            
            // ===== CREATE SHOCKWAVE OBJECT =====
            shockwaves[index] = {
                active: true,                   // Active state flag
                x: x,                          // Center X position
                y: y,                          // Center Y position
                startTime: Date.now() / 1000,  // Start time in seconds (for shader timing)
                isGood: isGood                 // Target type (affects color)
            };
        }
        
        // =============================================================================
        // TARGET COLLISION DETECTION
        // =============================================================================
        
        /**
         * Check if either touch point is overlapping any targets
         * Called whenever touch positions change or mouse moves
         * Triggers target collection when collision is detected
         */
        function checkTargets() {
            // ===== CHECK EACH ACTIVE TARGET =====
            targets.forEach(target => {
                if (target.collected) return;  // Skip already collected targets
                
                // ===== DISTANCE CALCULATIONS =====
                // Calculate distance from target center to each touch point
                const distToTouch1 = Math.hypot(
                    target.x - touch1.x,
                    target.y - touch1.y
                );
                
                const distToTouch2 = Math.hypot(
                    target.x - touch2.x,
                    target.y - touch2.y
                );
                
                // ===== COLLISION DETECTION =====
                // Collection radius of 0.08 (8% of screen) for forgiving gameplay
                if (distToTouch1 < 0.08 || distToTouch2 < 0.08) {
                    collectTarget(target);
                }
            });
        }
        
        /**
         * Collect/activate a target when touched
         * Handles scoring, visual effects, audio feedback, and cleanup
         * 
         * @param {Object} target - Target object to collect
         */
        function collectTarget(target) {
            // ===== PREVENT DOUBLE COLLECTION =====
            if (target.collected) return;  // Already collected, ignore
            
            // ===== MARK AS COLLECTED =====
            target.collected = true;  // Prevent further collection attempts
            
            // ===== CREATE VISUAL SHOCKWAVE =====
            // Shockwave color matches target type (good=green, bad=red)
            createShockwave(target.x, target.y, !target.isBad);
            
            // ===== TARGET TYPE-SPECIFIC HANDLING =====
            if (target.isBad) {
                // BAD TARGET - Penalty feedback
                target.element.style.border = '4px solid rgba(255, 51, 102, 1.0)';     // Red border
                target.element.style.boxShadow = '0 0 25px rgba(255, 51, 102, 1.0)';   // Red glow
                updateScore(-15);  // Lose 15 points (significant penalty)
                
            } else {
                // GOOD TARGET - Reward feedback  
                target.element.style.border = '4px solid rgba(0, 255, 170, 1.0)';      // Green border
                target.element.style.boxShadow = '0 0 25px rgba(0, 255, 170, 1.0)';    // Green glow
                updateScore(10);   // Gain 10 points (standard reward)
            }
            
            // ===== COLLECTION ANIMATION =====
            target.element.style.animation = 'none';  // Stop pulsing animation
            target.element.style.transform = 'translate(-50%, -50%) scale(1.2)';  // Scale up briefly
            
            // ===== CLEANUP TIMER =====
            // Remove target after brief display of collection effects
            setTimeout(() => {
                removeTarget(target);
            }, 500);
        }
        
        // =============================================================================
        // ADVANCED GAMEPLAY MECHANICS
        // =============================================================================
        
        /**
         * Animation timing baseline - used to calculate elapsed time for all animations
         */
        let startTime = Date.now();
        
        /**
         * Check if the tendril/lightning effect intersects with any targets
         * This creates an advanced gameplay mechanic where the energy beam between
         * touch points can also collect targets, not just direct touch
         * 
         * Uses simplified collision detection approximating the complex shader tendril path
         */
        function checkTendrilTargetIntersection() {
            // ===== FEATURE GATE CHECK =====
            // Only perform expensive collision checking if tendrils are enabled
            if (!gameSettings.enableTendrils) return;
            
            // ===== DISTANCE REQUIREMENT =====
            // Tendrils only appear when touch points are sufficiently separated
            let touchDistance = Math.hypot(
                touch1.x - touch2.x,
                touch1.y - touch2.y
            );
            
            // Minimum distance threshold matches shader logic
            if (touchDistance < 0.15) return;
            
            // ===== SIMPLIFIED TENDRIL PATH APPROXIMATION =====
            // Sample multiple points along the tendril path for collision detection
            // This approximates the complex swirling patterns from the shader
            const numSamples = 10;  // Balance between accuracy and performance
            
            // ===== CHECK EACH TARGET FOR TENDRIL INTERSECTION =====
            targets.forEach(target => {
                if (target.collected) return;  // Skip collected targets
                
                let hit = false;
                
                // ===== SAMPLE POINTS ALONG TENDRIL PATH =====
                for (let i = 0; i <= numSamples; i++) {
                    const t = i / numSamples;  // Parameter along path (0-1)
                    
                    // ===== LINEAR INTERPOLATION BASE =====
                    // Start with straight line between touch points
                    const x = touch1.x + (touch2.x - touch1.x) * t;
                    const y = touch1.y + (touch2.y - touch1.y) * t;
                    
                    // ===== ORGANIC SWIRL APPROXIMATION =====
                    // Add simplified version of shader's organic movement
                    const time = Date.now() / 1000;
                    const offset = 0.05 * gameSettings.tendrilTurbulence * Math.sin(t * 6 + time * 2);
                    
                    // ===== DISTANCE TO TARGET =====
                    const dist = Math.hypot(
                        target.x - (x + offset),  // Apply swirl offset
                        target.y - y
                    );
                    
                    // ===== THICKNESS CALCULATION =====
                    // User-controllable tendril thickness plus target hit radius
                    const thickness = 0.05 * gameSettings.tendrilThickness;
                    
                    // ===== COLLISION CHECK =====
                    if (dist < thickness + 0.03) {  // 0.03 = target hit radius
                        hit = true;
                        break;  // Found collision, no need to check more points
                    }
                }
                
                // ===== PROCESS TENDRIL HIT =====
                if (hit) {
                    // Different scoring for tendril vs direct touch collection
                    if (target.isBad) {
                        updateScore(-5);  // Smaller penalty than direct touch (-5 vs -15)
                    } else {
                        updateScore(5);   // Smaller reward than direct touch (+5 vs +10)
                    }
                    collectTarget(target);
                }
            });
        }
        
        /**
         * Enforce gameplay rule: penalize players for keeping touch points too close together
         * This encourages dynamic, spread-out play and prevents "cheating" by keeping 
         * fingers close together for easy target collection
         */
        function checkThumbsDistance() {
            // ===== DUAL-TOUCH REQUIREMENT =====
            // Only applies when both touch points are active
            if (!bothThumbsActive) return;
            
            // ===== CALCULATE TOUCH SEPARATION =====
            const touchDistance = Math.hypot(
                touch1.x - touch2.x,
                touch1.y - touch2.y
            );
            
            // ===== PROXIMITY PENALTY LOGIC =====
            // Apply penalty if thumbs are too close (and penalty not already active)
            if (touchDistance < THUMBS_TOO_CLOSE_THRESHOLD && !thumbsClosePenaltyActive) {
                // ===== ACTIVATE PENALTY STATE =====
                thumbsClosePenaltyActive = true;  // Prevent spam penalties
                updateScore(-3);  // Small but noticeable penalty
                
                // ===== FEEDBACK FOR RULE VIOLATION =====
                // Haptic feedback to indicate rule violation
                if (navigator.vibrate) {
                    navigator.vibrate([50, 50, 50]);  // Triple pulse indicates penalty
                }
                
                // ===== PENALTY COOLDOWN =====
                // Prevent constant penalties with timeout
                setTimeout(() => {
                    thumbsClosePenaltyActive = false;  // Re-enable penalty checking
                }, 1000);
            }
        }
        
        /**
         * Reward system for maintaining active dual-touch gameplay
         * Provides small bonus points for keeping both touch points active over time
         * Encourages continuous engagement rather than passive play
         */
        function checkActiveThumbsBonus() {
            const now = Date.now();
            
            // ===== DUAL-TOUCH BONUS LOGIC =====
            // Award bonus points for sustained dual-touch activity
            const timeSinceLastBonus = now - lastActiveScoreTime;
            
            if (bothThumbsActive && timeSinceLastBonus > BOTH_THUMBS_ACTIVE_SCORE_INTERVAL) {
                updateScore(1);  // Small but steady bonus reward
                lastActiveScoreTime = now;  // Reset bonus timer
            }
        }
        
        // =============================================================================
        // MAIN RENDERING LOOP
        // =============================================================================
        
        /**
         * Main rendering and game loop function
         * Called every frame via requestAnimationFrame for smooth 60fps animation
         * 
         * Responsibilities:
         * 1. Update game state (targets, timing, mechanics)
         * 2. Set up WebGL rendering context
         * 3. Pass all uniforms to shaders
         * 4. Execute GPU rendering
         * 5. Schedule next frame
         */
        function render() {
            // ===== CANVAS AND TARGET MANAGEMENT =====
            resize();           // Ensure canvas matches window size
            updateTargets();    // Handle target lifecycle (creation, expiration)
            
            // ===== ADVANCED GAMEPLAY MECHANICS =====
            checkTendrilTargetIntersection();  // Tendril-target collision detection
            checkThumbsDistance();             // Proximity penalty enforcement
            checkActiveThumbsBonus();          // Dual-touch reward system
            
            // ===== ANIMATION TIMING =====
            const currentTime = (Date.now() - startTime) / 1000;  // Elapsed time in seconds
            
            // ===== WEBGL RENDERING SETUP =====
            // Clear to pure black background
            gl.clearColor(0, 0, 0, 1);
            gl.clear(gl.COLOR_BUFFER_BIT);
            
            // Activate our shader program
            gl.useProgram(program);
            
            // ===== CORE UNIFORM VALUES =====
            // Pass essential values to fragment shader
            gl.uniform2f(resolutionUniformLocation, canvas.width, canvas.height);  // Screen dimensions
            gl.uniform1f(timeUniformLocation, currentTime);                        // Animation time
            gl.uniform2f(touch1UniformLocation, touch1.x, touch1.y);               // First touch position
            gl.uniform2f(touch2UniformLocation, touch2.x, touch2.y);               // Second touch position
            
            // ===== USER CONTROL UNIFORMS =====
            // Pass real-time settings from control panel to shader
            gl.uniform1f(gl.getUniformLocation(program, 'u_fluid_intensity'), gameSettings.fluidIntensity);
            gl.uniform1f(gl.getUniformLocation(program, 'u_enable_background'), gameSettings.enableBackground ? 1.0 : 0.0);
            gl.uniform1f(gl.getUniformLocation(program, 'u_enable_tendrils'), gameSettings.enableTendrils ? 1.0 : 0.0);
            gl.uniform1f(gl.getUniformLocation(program, 'u_tendril_thickness'), gameSettings.tendrilThickness);
            gl.uniform1f(gl.getUniformLocation(program, 'u_tendril_turbulence'), gameSettings.tendrilTurbulence);
            gl.uniform1f(gl.getUniformLocation(program, 'u_tendril_glow'), gameSettings.tendrilGlow);
            gl.uniform1f(gl.getUniformLocation(program, 'u_enable_shockwaves'), gameSettings.enableShockwaves ? 1.0 : 0.0);
            gl.uniform1f(gl.getUniformLocation(program, 'u_shockwave_intensity'), gameSettings.shockwaveIntensity);
            
            // ===== TARGET SYSTEM UNIFORMS =====
            // Pass current target states to shader for highlighting effects
            for (let i = 0; i < MAX_TARGETS; i++) {
                if (i < targets.length && !targets[i].collected) {
                    // Active target - send position and type data
                    gl.uniform2f(targetLocations[i], targets[i].x, targets[i].y);           // Target position
                    gl.uniform1f(targetActiveLocations[i], 1.0);                            // Mark as active
                    gl.uniform1f(targetTypeLocations[i], targets[i].isBad ? 1.0 : 0.0);     // Type: good/bad
                } else {
                    // Empty slot - send default values
                    gl.uniform2f(targetLocations[i], 0, 0);      // Default position
                    gl.uniform1f(targetActiveLocations[i], 0.0); // Mark as inactive
                    gl.uniform1f(targetTypeLocations[i], 0.0);   // Default type
                }
            }
            
            // ===== SHOCKWAVE SYSTEM UNIFORMS =====
            // Pass active shockwave data to shader for expanding ring effects
            for (let i = 0; i < MAX_TARGETS; i++) {
                if (shockwaves[i] && shockwaves[i].active) {
                    const timeSinceStart = currentTime - shockwaves[i].startTime;
                    
                    // ===== SHOCKWAVE LIFECYCLE MANAGEMENT =====
                    if (timeSinceStart > 1.0) {
                        // Shockwave has expired (1 second duration)
                        shockwaves[i].active = false;
                        gl.uniform1f(shockwaveActiveLocations[i], 0.0);
                    } else {
                        // Active shockwave - send all data to shader
                        gl.uniform1f(shockwaveActiveLocations[i], 1.0);                              // Mark as active
                        gl.uniform2f(shockwavePosLocations[i], shockwaves[i].x, shockwaves[i].y);   // Center position
                        gl.uniform1f(shockwaveStartLocations[i], shockwaves[i].startTime);          // Start time
                        gl.uniform1f(shockwaveTypeLocations[i], shockwaves[i].isGood ? 0.0 : 1.0);  // Type for coloring
                    }
                } else {
                    // Empty slot - mark as inactive
                    gl.uniform1f(shockwaveActiveLocations[i], 0.0);
                }
            }
            
            // ===== VERTEX ATTRIBUTE SETUP =====
            // Configure the vertex buffer for full-screen quad rendering
            const positionAttributeLocation = gl.getAttribLocation(program, 'a_position');
            gl.enableVertexAttribArray(positionAttributeLocation);
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);
            
            // ===== EXECUTE GPU RENDERING =====
            // Draw two triangles to form a full-screen quad
            // All visual effects are computed in the fragment shader
            gl.drawArrays(gl.TRIANGLES, 0, 6);
            
            // ===== SCHEDULE NEXT FRAME =====
            // Request next frame for smooth 60fps animation
            requestAnimationFrame(render);
        }
        
        // =============================================================================
        // GAME INITIALIZATION AND AUDIO HANDLING
        // =============================================================================
        
        /**
         * Modern browsers require user interaction before audio can play
         * This function enables audio on first user interaction with the page
         * Required due to browser autoplay policies
         */
        function enableAudio() {
            // ===== RESUME AUDIO CONTEXT =====
            // Browser may have suspended audio context due to autoplay policy
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
            
            // ===== AUDIO TEST CONFIRMATION =====
            // Play brief test tone to verify audio is working
            if (audioEnabled) {
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                gain.gain.value = 0.2;      // Audible but not jarring volume
                osc.frequency.value = 440;  // A4 note (standard reference)
                osc.connect(gain);
                gain.connect(audioContext.destination);
                osc.start();
                osc.stop(audioContext.currentTime + 0.1);  // Brief 100ms tone
            }
            
            // ===== CLEANUP EVENT LISTENERS =====
            // Remove these listeners - audio is now initialized
            document.removeEventListener('click', enableAudio);
            document.removeEventListener('touchstart', enableAudio);
            
            // ===== USER FEEDBACK =====
            // Show temporary confirmation that audio is active
            const audioAlert = document.createElement('div');
            audioAlert.textContent = 'Audio enabled! üîä';
            audioAlert.style.position = 'absolute';
            audioAlert.style.top = '70px';
            audioAlert.style.left = '0';
            audioAlert.style.width = '100%';
            audioAlert.style.textAlign = 'center';
            audioAlert.style.color = '#00ffaa';
            audioAlert.style.fontFamily = 'Arial, sans-serif';
            audioAlert.style.fontSize = '18px';
            audioAlert.style.zIndex = '20';
            audioAlert.style.pointerEvents = 'none';
            document.body.appendChild(audioAlert);
            
            // ===== CLEANUP NOTIFICATION =====
            // Remove notification after brief display
            setTimeout(() => {
                audioAlert.remove();
            }, 2000);
        }
        
        // ===== AUDIO INITIALIZATION LISTENERS =====
        // Set up listeners for first user interaction (required for audio)
        document.addEventListener('click', enableAudio);
        document.addEventListener('touchstart', enableAudio);
        
        // ===== GAME STARTUP =====
        // Create the first target to give players something to aim for
        createTarget();
        
        // Start the main rendering loop
        render();
    </script>
</body>
</html>