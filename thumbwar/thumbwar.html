<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Fluid Dynamics Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: none;
        }
        body {
            overflow: hidden;
            background-color: #000;
            width: 100vw;
            height: 100vh;
            position: fixed;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            touch-action: none;
        }
        #score {
            position: absolute;
            top: 20px;
            left: 0;
            width: 100%;
            text-align: center;
            color: #00ffaa;
            font-family: Arial, sans-serif;
            font-size: 24px;
            text-shadow: 0 0 10px rgba(0, 255, 170, 0.8);
            z-index: 10;
            pointer-events: none;
            transition: color 0.3s;
        }
        #score.negative {
            color: #ff3366;
            text-shadow: 0 0 10px rgba(255, 51, 102, 0.8);
        }
        #targets {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        .target {
            position: absolute;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }
        .target.good {
            border: 3px solid rgba(0, 255, 170, 0.8);
            box-shadow: 0 0 15px rgba(0, 255, 170, 0.7);
            animation: pulseGood 1.5s infinite alternate;
        }
        .target.bad {
            border: 3px solid rgba(255, 51, 102, 0.8);
            box-shadow: 0 0 15px rgba(255, 51, 102, 0.7);
            animation: pulseBad 1.5s infinite alternate;
        }
        
        @keyframes pulseGood {
            0% { box-shadow: 0 0 10px rgba(0, 255, 170, 0.7); }
            100% { box-shadow: 0 0 20px rgba(0, 255, 170, 0.9); }
        }
        
        @keyframes pulseBad {
            0% { box-shadow: 0 0 10px rgba(255, 51, 102, 0.7); }
            100% { box-shadow: 0 0 20px rgba(255, 51, 102, 0.9); }
        }
        
        #instructions {
            position: absolute;
            bottom: 20px;
            left: 0;
            width: 100%;
            text-align: center;
            color: #00ffaa;
            font-family: Arial, sans-serif;
            font-size: 16px;
            text-shadow: 0 0 8px rgba(0, 255, 170, 0.6);
            z-index: 10;
            pointer-events: none;
            padding: 0 20px;
        }
        
        #audio-toggle {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #00ffaa;
            color: #00ffaa;
            font-family: Arial, sans-serif;
            padding: 5px 10px;
            border-radius: 20px;
            z-index: 20;
            cursor: pointer;
        }
        
        /* Control Panel Styles */
        #control-panel-toggle {
            position: absolute;
            top: 70px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid #00ffaa;
            color: #00ffaa;
            font-family: Arial, sans-serif;
            padding: 5px 10px;
            border-radius: 20px;
            z-index: 21;
            cursor: pointer;
            font-size: 14px;
        }
        
        #control-panel {
            position: absolute;
            top: 110px;
            right: 20px;
            width: 280px;
            background: rgba(0, 0, 0, 0.85);
            border: 1px solid #00ffaa;
            border-radius: 10px;
            padding: 15px;
            color: white;
            font-family: Arial, sans-serif;
            font-size: 12px;
            z-index: 20;
            max-height: 80vh;
            overflow-y: auto;
            display: none;
            transform-origin: top right;
            transition: transform 0.3s, opacity 0.3s;
            transform: scale(0.95);
            opacity: 0;
        }
        
        #control-panel.visible {
            display: block;
            transform: scale(1);
            opacity: 1;
        }
        
        .control-section {
            margin-bottom: 15px;
            border-bottom: 1px solid rgba(0, 255, 170, 0.3);
            padding-bottom: 10px;
        }
        
        .control-section h3 {
            color: #00ffaa;
            margin: 0 0 10px 0;
            font-size: 14px;
        }
        
        .control-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 6px 0;
        }
        
        .control-label {
            flex: 1;
        }
        
        .control-input {
            flex: 1;
        }
        
        /* Sliders and inputs */
        .control-panel input[type="range"] {
            width: 100%;
            background: #333;
            height: 6px;
            -webkit-appearance: none;
            border-radius: 3px;
            outline: none;
        }
        
        .control-panel input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 12px;
            height: 12px;
            background: #00ffaa;
            border-radius: 50%;
            cursor: pointer;
        }
        
        .control-panel input[type="checkbox"] {
            -webkit-appearance: none;
            width: 30px;
            height: 16px;
            background: #333;
            border-radius: 10px;
            position: relative;
            outline: none;
            cursor: pointer;
        }
        
        .control-panel input[type="checkbox"]:checked {
            background: #00ffaa;
        }
        
        .control-panel input[type="checkbox"]:before {
            content: '';
            position: absolute;
            width: 14px;
            height: 14px;
            background: #ddd;
            border-radius: 50%;
            top: 1px;
            left: 1px;
            transition: 0.3s;
        }
        
        .control-panel input[type="checkbox"]:checked:before {
            left: 15px;
        }
        
        .parameter-value {
            display: inline-block;
            width: 30px;
            text-align: right;
            font-size: 11px;
            color: #ccc;
            margin-left: 8px;
        }
        
        /* Only show control panel on desktop */
        @media (max-width: 768px) {
            #control-panel-toggle {
                display: none;
            }
        }
    </style>
</head>
<body>
    <div id="score">Score: 0</div>
    <div id="targets"></div>
    <div id="instructions">
        On mobile: Use both thumbs to bend the fluid streams.<br>
        On desktop: Click and drag with your mouse or click directly on targets.<br>
        Catch green targets, but avoid red ones!
    </div>
    <button id="audio-toggle">üîä Click to Enable Audio</button>
    <button id="control-panel-toggle">‚öôÔ∏è Controls</button>
    <div id="control-panel" class="control-panel">
        <div class="control-section">
            <h3>Tendril Effects</h3>
            <div class="control-row">
                <label class="control-label">Enable Tendrils</label>
                <div class="control-input">
                    <input type="checkbox" id="enable-tendrils" checked>
                </div>
            </div>
            <div class="control-row">
                <label class="control-label">Thickness <span id="tendril-thickness-value" class="parameter-value">1.0</span></label>
                <div class="control-input">
                    <input type="range" id="tendril-thickness" min="0.1" max="2.0" step="0.1" value="1.0">
                </div>
            </div>
            <div class="control-row">
                <label class="control-label">Turbulence <span id="tendril-turbulence-value" class="parameter-value">1.0</span></label>
                <div class="control-input">
                    <input type="range" id="tendril-turbulence" min="0.1" max="2.0" step="0.1" value="1.0">
                </div>
            </div>
            <div class="control-row">
                <label class="control-label">Glow Intensity <span id="tendril-glow-value" class="parameter-value">1.0</span></label>
                <div class="control-input">
                    <input type="range" id="tendril-glow" min="0" max="2.0" step="0.1" value="1.0">
                </div>
            </div>
        </div>
        
        <div class="control-section">
            <h3>Fluid Dynamics</h3>
            <div class="control-row">
                <label class="control-label">Intensity <span id="fluid-intensity-value" class="parameter-value">1.0</span></label>
                <div class="control-input">
                    <input type="range" id="fluid-intensity" min="0.1" max="2.0" step="0.1" value="1.0">
                </div>
            </div>
            <div class="control-row">
                <label class="control-label">Background Effects</label>
                <div class="control-input">
                    <input type="checkbox" id="enable-background" checked>
                </div>
            </div>
        </div>
        
        <div class="control-section">
            <h3>Shockwave Effects</h3>
            <div class="control-row">
                <label class="control-label">Enable Shockwaves</label>
                <div class="control-input">
                    <input type="checkbox" id="enable-shockwaves" checked>
                </div>
            </div>
            <div class="control-row">
                <label class="control-label">Intensity <span id="shockwave-intensity-value" class="parameter-value">1.0</span></label>
                <div class="control-input">
                    <input type="range" id="shockwave-intensity" min="0" max="2.0" step="0.1" value="1.0">
                </div>
            </div>
        </div>
        
        <div class="control-section">
            <h3>Gameplay</h3>
            <div class="control-row">
                <label class="control-label">Target Generation Rate <span id="target-rate-value" class="parameter-value">1.0</span></label>
                <div class="control-input">
                    <input type="range" id="target-rate" min="0.2" max="2.0" step="0.1" value="1.0">
                </div>
            </div>
            <div class="control-row">
                <label class="control-label">Target Lifespan <span id="target-lifespan-value" class="parameter-value">5s</span></label>
                <div class="control-input">
                    <input type="range" id="target-lifespan" min="2" max="10" step="0.5" value="5">
                </div>
            </div>
        </div>
        
        <div class="control-section">
            <h3>Performance</h3>
            <div class="control-row">
                <label class="control-label">Quality Preset</label>
                <div class="control-input">
                    <select id="quality-preset">
                        <option value="high">High</option>
                        <option value="medium" selected>Medium</option>
                        <option value="low">Low</option>
                    </select>
                </div>
            </div>
            <div class="control-row">
                <label class="control-label">Fluid Iterations <span id="fluid-iterations-value" class="parameter-value">12</span></label>
                <div class="control-input">
                    <input type="range" id="fluid-iterations" min="4" max="16" step="1" value="12">
                </div>
            </div>
        </div>
    </div>
    <canvas id="canvas"></canvas>

    <script>
        // Game variables
        let score = 0;
        const MAX_TARGETS = 4; // Increased to accommodate both good and bad targets
        let targetLifespan = 5000; // milliseconds (can be modified by controls)
        let targets = [];
        let shockwaves = []; // Array to store active shockwaves
        let audioEnabled = true;
        let lastScoreChange = 0; // Track when score last changed (for animation)
        let scoreDirection = 1; // 1 for positive, -1 for negative
        
        // Game rule variables
        let bothThumbsActive = false; // Track if both thumbs are currently active
        let thumbsClosePenaltyActive = false; // Prevent constant penalties
        let lastActiveScoreTime = 0; // For passive score increase when both thumbs active
        let THUMBS_TOO_CLOSE_THRESHOLD = 0.2; // Distance threshold for "too close" penalty
        let BOTH_THUMBS_ACTIVE_SCORE_INTERVAL = 1000; // ms between score points for active play
        
        // Effect control variables (used by control panel)
        let gameSettings = {
            // Tendril controls
            enableTendrils: true,
            tendrilThickness: 1.0,
            tendrilTurbulence: 1.0, 
            tendrilGlow: 1.0,
            
            // Fluid dynamics
            fluidIntensity: 1.0,
            enableBackground: true,
            
            // Shockwave effects
            enableShockwaves: true,
            shockwaveIntensity: 1.0,
            
            // Gameplay
            targetGenerationRate: 1.0,
            targetLifespan: 5.0, // seconds
            
            // Performance
            qualityPreset: 'medium',
            fluidIterations: 12
        };
        
        // Control Panel Logic
        const controlPanelToggle = document.getElementById('control-panel-toggle');
        const controlPanel = document.getElementById('control-panel');
        
        // Toggle control panel visibility
        controlPanelToggle.addEventListener('click', () => {
            controlPanel.classList.toggle('visible');
        });
        
        // Setup control panel listeners
        function setupControlPanel() {
            // Tendril controls
            document.getElementById('enable-tendrils').addEventListener('change', e => {
                gameSettings.enableTendrils = e.target.checked;
            });
            
            document.getElementById('tendril-thickness').addEventListener('input', e => {
                gameSettings.tendrilThickness = parseFloat(e.target.value);
                document.getElementById('tendril-thickness-value').textContent = e.target.value;
            });
            
            document.getElementById('tendril-turbulence').addEventListener('input', e => {
                gameSettings.tendrilTurbulence = parseFloat(e.target.value);
                document.getElementById('tendril-turbulence-value').textContent = e.target.value;
            });
            
            document.getElementById('tendril-glow').addEventListener('input', e => {
                gameSettings.tendrilGlow = parseFloat(e.target.value);
                document.getElementById('tendril-glow-value').textContent = e.target.value;
            });
            
            // Fluid dynamics
            document.getElementById('fluid-intensity').addEventListener('input', e => {
                gameSettings.fluidIntensity = parseFloat(e.target.value);
                document.getElementById('fluid-intensity-value').textContent = e.target.value;
            });
            
            document.getElementById('enable-background').addEventListener('change', e => {
                gameSettings.enableBackground = e.target.checked;
            });
            
            // Shockwaves
            document.getElementById('enable-shockwaves').addEventListener('change', e => {
                gameSettings.enableShockwaves = e.target.checked;
            });
            
            document.getElementById('shockwave-intensity').addEventListener('input', e => {
                gameSettings.shockwaveIntensity = parseFloat(e.target.value);
                document.getElementById('shockwave-intensity-value').textContent = e.target.value;
            });
            
            // Gameplay
            document.getElementById('target-rate').addEventListener('input', e => {
                gameSettings.targetGenerationRate = parseFloat(e.target.value);
                document.getElementById('target-rate-value').textContent = e.target.value;
            });
            
            document.getElementById('target-lifespan').addEventListener('input', e => {
                gameSettings.targetLifespan = parseFloat(e.target.value);
                targetLifespan = gameSettings.targetLifespan * 1000; // convert to ms
                document.getElementById('target-lifespan-value').textContent = e.target.value + 's';
            });
            
            // Performance
            document.getElementById('quality-preset').addEventListener('change', e => {
                gameSettings.qualityPreset = e.target.value;
                applyQualityPreset(e.target.value);
            });
            
            document.getElementById('fluid-iterations').addEventListener('input', e => {
                gameSettings.fluidIterations = parseInt(e.target.value);
                document.getElementById('fluid-iterations-value').textContent = e.target.value;
            });
        }
        
        // Apply performance presets
        function applyQualityPreset(preset) {
            const iterationsSlider = document.getElementById('fluid-iterations');
            
            switch(preset) {
                case 'high':
                    gameSettings.fluidIterations = 15;
                    iterationsSlider.value = 15;
                    document.getElementById('fluid-iterations-value').textContent = '15';
                    break;
                case 'medium':
                    gameSettings.fluidIterations = 12;
                    iterationsSlider.value = 12;
                    document.getElementById('fluid-iterations-value').textContent = '12';
                    break;
                case 'low':
                    gameSettings.fluidIterations = 8;
                    iterationsSlider.value = 8;
                    document.getElementById('fluid-iterations-value').textContent = '8';
                    break;
            }
        }
        
        // Initialize control panel
        setupControlPanel();
        
        // Audio setup
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        // Audio toggle
        const audioToggle = document.getElementById('audio-toggle');
        let audioInitialized = false;
        
        audioToggle.addEventListener('click', function() {
            // First click always enables audio
            if (!audioInitialized) {
                audioEnabled = true;
                audioInitialized = true;
                this.textContent = 'üîä On';
                
                // Play test tone on first click
                if (audioContext.state === 'suspended') {
                    audioContext.resume();
                }
                
                // Play a clear, audible test tone
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                gain.gain.value = 0.2;
                osc.frequency.value = 440; // A4 note
                osc.connect(gain);
                gain.connect(audioContext.destination);
                osc.start();
                osc.stop(audioContext.currentTime + 0.1);
                
                // Alert that audio is now active
                const audioAlert = document.createElement('div');
                audioAlert.textContent = 'Audio enabled! üîä';
                audioAlert.style.position = 'absolute';
                audioAlert.style.top = '70px';
                audioAlert.style.left = '0';
                audioAlert.style.width = '100%';
                audioAlert.style.textAlign = 'center';
                audioAlert.style.color = '#00ffaa';
                audioAlert.style.fontFamily = 'Arial, sans-serif';
                audioAlert.style.fontSize = '18px';
                audioAlert.style.zIndex = '20';
                audioAlert.style.pointerEvents = 'none';
                document.body.appendChild(audioAlert);
                
                // Remove the alert after 2 seconds
                setTimeout(() => {
                    audioAlert.remove();
                }, 2000);
            } else {
                // Toggle audio on/off after first initialization
                audioEnabled = !audioEnabled;
                this.textContent = audioEnabled ? 'üîä On' : 'üîá Off';
            }
            
            // Resume audio context if it was suspended (browser policy)
            if (audioEnabled && audioContext.state === 'suspended') {
                audioContext.resume();
            }
        });
        
        // Sound effects
        function createCollectSound() {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            // Good sound: Major arpeggio
            oscillator.type = 'sine';
            oscillator.frequency.setValueAtTime(440, audioContext.currentTime); // A4
            oscillator.frequency.setValueAtTime(554.37, audioContext.currentTime + 0.1); // C#5
            oscillator.frequency.setValueAtTime(659.25, audioContext.currentTime + 0.2); // E5
            
            gainNode.gain.setValueAtTime(0, audioContext.currentTime);
            gainNode.gain.linearRampToValueAtTime(0.3, audioContext.currentTime + 0.05);
            gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.3);
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.start();
            oscillator.stop(audioContext.currentTime + 0.3);
        }
        
        function createBadSound() {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            const distortion = audioContext.createWaveShaper();
            
            // Bad sound: Distorted descending frequencies
            function makeDistortionCurve(amount) {
                const k = typeof amount === 'number' ? amount : 50;
                const n_samples = 44100;
                const curve = new Float32Array(n_samples);
                for (let i = 0; i < n_samples; ++i) {
                    const x = i * 2 / n_samples - 1;
                    curve[i] = (3 + k) * x * 20 * (Math.PI / 180) / (Math.PI + k * Math.abs(x));
                }
                return curve;
            }
            
            distortion.curve = makeDistortionCurve(400);
            
            oscillator.type = 'sawtooth';
            oscillator.frequency.setValueAtTime(300, audioContext.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(150, audioContext.currentTime + 0.3);
            
            gainNode.gain.setValueAtTime(0, audioContext.currentTime);
            gainNode.gain.linearRampToValueAtTime(0.3, audioContext.currentTime + 0.05);
            gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.4);
            
            oscillator.connect(distortion);
            distortion.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.start();
            oscillator.stop(audioContext.currentTime + 0.4);
        }
        
        // Haptic feedback (vibration)
        function vibrate(pattern) {
            if (navigator.vibrate) {
                navigator.vibrate(pattern);
            }
        }
        
        // Canvas and WebGL setup
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
        
        if (!gl) {
            alert('WebGL not supported');
        }
        
        // Resize canvas
        function resize() {
            const displayWidth = canvas.clientWidth;
            const displayHeight = canvas.clientHeight;
            
            if (canvas.width !== displayWidth || canvas.height !== displayHeight) {
                canvas.width = displayWidth;
                canvas.height = displayHeight;
                gl.viewport(0, 0, canvas.width, canvas.height);
            }
        }
        
        window.addEventListener('resize', resize);
        resize();
        
        // Shader sources
        const vertexShaderSource = `
            attribute vec2 a_position;
            void main() {
                gl_Position = vec4(a_position, 0, 1);
            }
        `;
        
        const fragmentShaderSource = `
            precision highp float;
            
            uniform vec2 u_resolution;
            uniform float u_time;
            uniform vec2 u_touch1;
            uniform vec2 u_touch2;
            uniform vec2 u_targets[${MAX_TARGETS}];
            uniform float u_target_active[${MAX_TARGETS}];
            uniform float u_target_type[${MAX_TARGETS}];  // 0 = good, 1 = bad
            
            // Added shockwave effect variables
            uniform float u_shockwave_active[${MAX_TARGETS}];
            uniform vec2 u_shockwave_pos[${MAX_TARGETS}];
            uniform float u_shockwave_start[${MAX_TARGETS}];
            uniform float u_shockwave_type[${MAX_TARGETS}]; // 0 = good, 1 = bad
            
            // Control panel uniforms
            uniform float u_fluid_intensity;
            uniform float u_enable_background;
            uniform float u_enable_tendrils;
            uniform float u_tendril_thickness;
            uniform float u_tendril_turbulence;
            uniform float u_tendril_glow;
            uniform float u_enable_shockwaves;
            uniform float u_shockwave_intensity;
            
            // Function to create an organic, swirling tendril effect between points
            float swirlTendril(vec2 p, vec2 start, vec2 end, float time, float thickness, float turbulence) {
                // Vector from start to end
                vec2 direction = end - start;
                float distance = length(direction);
                direction = normalize(direction);
                
                // Perpendicular vector for swirls
                vec2 perpendicular = vec2(-direction.y, direction.x);
                
                // Project point onto line
                float t = clamp(dot(p - start, direction) / distance, 0.0, 1.0);
                vec2 projection = start + direction * t * distance;
                
                // Base parameters for a more organic, flowing tendril
                float swirl = 0.0;
                
                // Layered sine waves with different frequencies and amplitudes for organic flow
                // Layer 1: Large, slow undulations (base flow)
                float baseFlow = sin(t * 3.14159 * 2.0 + time * 0.7) * 0.04 * turbulence;
                
                // Layer 2: Medium ripples
                float mediumRipples = sin(t * 3.14159 * 5.0 + time * 1.2) * 0.025 * turbulence;
                
                // Layer 3: Small, rapid oscillations (micro-movement)
                float microMovement = sin(t * 3.14159 * 12.0 + time * 2.5) * 0.01 * turbulence;
                
                // Layer 4: Tiny, very rapid oscillations for detail
                float detailNoise = sin(t * 3.14159 * 25.0 + time * 4.0) * 0.005 * turbulence;
                
                // Additional spiral effect
                float spiral = sin(t * 3.14159 * 3.0 + time * 0.5) * cos(t * 3.14159 * 2.0 + time * 0.3) * 0.02 * turbulence;
                
                // Temporal variation to make the flow appear to change direction/shape over time
                float timeWave1 = sin(time * 0.3) * 0.01;
                float timeWave2 = cos(time * 0.5 + t) * 0.01;
                
                // Flow distortion near the endpoints for a more natural connection
                float endpointEffect = (1.0 - pow(abs(2.0 * t - 1.0), 0.5)) * 0.01;
                
                // Combine all effects with different weights to create organic flow
                swirl = baseFlow + mediumRipples + microMovement + detailNoise + spiral + timeWave1 + timeWave2 + endpointEffect;
                
                // Temporal scaling - makes the whole tendril pulse slightly
                float tendrilPulse = 0.9 + 0.1 * sin(time * 0.8 + t * 2.0);
                swirl *= tendrilPulse;
                
                // Dynamic thickness variation along the tendril
                float thicknessVariation = 0.8 + 0.2 * sin(t * 8.0 + time * 1.5);
                float effectiveThickness = thickness * thicknessVariation;
                
                // Make tendril thinner near the midpoint for a stretched appearance
                effectiveThickness *= 0.7 + 0.3 * sin(t * 3.14159);
                
                // Apply swirl to create the curved, organic path
                vec2 offset = perpendicular * swirl;
                
                // For more interesting paths, add a secondary perpendicular component
                vec2 secondary = vec2(direction.x, direction.y); // Orthogonal to perpendicular
                offset += secondary * sin(t * 3.14159 * 4.0 + time * 0.9) * 0.01;
                
                // Calculate distance to the swirling path
                float distortedDistance = length(p - (projection + offset));
                
                // Create smooth falloff for the tendril glow
                return smoothstep(effectiveThickness, effectiveThickness * 0.2, distortedDistance);
            }
            
            vec4 fluidEffect(vec2 uv, float time, vec2 touch1, vec2 touch2) {
                vec4 o = vec4(0.01);
                vec2 r = u_resolution;
                vec2 p = (gl_FragCoord.xy * 2.0 - r) / r.y;
                
                // Make background truly dark
                vec4 backgroundColor = vec4(0.0, 0.0, 0.0, 1.0);
                
                // Touch influence - trail effect
                float t1 = length(p - touch1) * 1.1;
                float t2 = length(p - touch2) * 1.1;
                
                // More chaotic time-based flow vectors for extreme swirling
                vec2 flowVec1 = vec2(
                    sin(time * 0.7) * 0.4 + sin(time * 1.5) * 0.3,
                    cos(time * 0.5) * 0.4 + cos(time * 1.7) * 0.3
                );
                vec2 flowVec2 = vec2(
                    sin(time * 0.5 + 2.0) * 0.4 + sin(time * 1.3) * 0.3,
                    cos(time * 0.6 + 1.0) * 0.4 + cos(time * 1.9) * 0.3
                );
                
                // Create multiple trailing points for each touch (more points = more complex streams)
                vec2 trailPos1 = touch1 + flowVec1;
                vec2 trailPos2 = touch2 + flowVec2;
                
                // Create more trail points with different offsets
                float t1a = length(p - (touch1 + flowVec1 * 0.3)) * 1.3;
                float t1b = length(p - (touch1 + flowVec1 * 0.6)) * 1.4;
                float t1c = length(p - (touch1 + flowVec1 * 0.9)) * 1.5;
                float t1d = length(p - (touch1 + flowVec1 * 1.2)) * 1.6;
                float t1e = length(p - (touch1 + flowVec1 * 1.5)) * 1.7;
                float t1f = length(p - (touch1 + vec2(sin(time*2.3), cos(time*2.1)) * 0.7)) * 1.5; // Additional chaotic trail
                
                float t2a = length(p - (touch2 + flowVec2 * 0.3)) * 1.3;
                float t2b = length(p - (touch2 + flowVec2 * 0.6)) * 1.4;
                float t2c = length(p - (touch2 + flowVec2 * 0.9)) * 1.5;
                float t2d = length(p - (touch2 + flowVec2 * 1.2)) * 1.6;
                float t2e = length(p - (touch2 + flowVec2 * 1.5)) * 1.7;
                float t2f = length(p - (touch2 + vec2(cos(time*2.5), sin(time*1.9)) * 0.7)) * 1.5; // Additional chaotic trail
                
                // Combined touch effect with all trail points
                float touchEffect = min(
                    min(min(min(t1, t1a), min(t1b, t1c)), min(min(t1d, t1e), t1f)),
                    min(min(min(t2, t2a), min(t2b, t2c)), min(min(t2d, t2e), t2f))
                );
                touchEffect = clamp(touchEffect, 0.06, 1.0); // Lower clamp value for more intense effect
                
                // Extreme fluid dynamics with added vorticity
                // Fix uninitialized variable issue
                vec2 l = vec2(0.0);
                vec2 v = p * (1.0 - (l += abs(0.7 - dot(p, p)))) / (max(0.05, touchEffect * 0.1));
                
                // Enhanced vector field for extreme swirling effect
                vec2 curl = vec2(
                    sin(p.y * 5.0 + time) * cos(p.x * 4.0 - time * 0.7) + sin(p.y * 8.0 - time * 1.3) * 0.3,
                    cos(p.x * 5.0 - time) * sin(p.y * 4.0 + time * 0.7) + cos(p.x * 8.0 + time * 1.3) * 0.3
                ) * 0.25; // Increased strength
                
                v += curl; // Add curl to create intense swirling
                
                // Fractalize the flow with turbulent noise-like patterns
                v.x += 0.2 * sin(v.y * 4.0 + time * 0.9) * cos(v.x * 3.0);
                v.y += 0.2 * cos(v.x * 4.0 - time * 0.8) * sin(v.y * 3.0);
                
                // Flow iterations - create extreme snaking patterns with turbulence
                // WebGL 1.0 requires constant loop bounds
                for(float i = 0.0; i < 12.0; i++) { // Fixed number of iterations
                    float ii = i + 1.0;
                    
                    // Create more complex flow patterns with wilder warping
                    vec2 offset = vec2(
                        sin(time * 0.4 + ii * 0.2 + sin(time)) * 0.6,
                        cos(time * 0.3 + ii * 0.2 + cos(time)) * 0.6
                    );
                    
                    // Use complex sinusoidal waves to create fire-like movement
                    vec2 warp = vec2(
                        sin(v.x * 2.0 + time * 0.6) * 0.3 + sin(v.x * 5.0 - time * 0.3) * 0.1,
                        cos(v.y * 2.0 + time * 0.5) * 0.3 + cos(v.y * 5.0 - time * 0.2) * 0.1
                    );
                    
                    // Create turbulent snake-like patterns with complex oscillation
                    v += cos(v.yx * ii * 0.7 + offset + time * 0.8) / (ii * 0.4) + warp + 0.6;
                    
                    // Add fluctuating intensity with multiple frequencies for flame-like effect
                    float flicker = 0.8 + sin(time * 5.0 + ii) * 0.2 + sin(time * 9.0 + ii * 0.7) * 0.1;
                    o += (sin(v.xyyx * 1.8 + time * 0.4) + 1.0) * abs(v.x - v.y) * 0.3 * flicker;
                }
                
                // Northern lights style color mapping with more dramatic gradients
                float intensity = clamp(o.x + o.y + o.z + o.w, 0.1, 4.0);
                float factor = exp(-1.8 * l.x) / intensity * 2.0;
                
                // Core texture noise for touch points - adds detailed texture at heart of blobs
                float noise1 = sin(p.x * 30.0 + time) * sin(p.y * 30.0 + time * 1.2) * 0.5 + 0.5;
                float noise2 = sin(p.x * 20.0 - time * 1.3) * sin(p.y * 20.0 + time) * 0.5 + 0.5;
                
                // Create fire/magic-like colors with more dramatic variation and core texturing
                // Enhanced color transitions for more vibrant visuals
                vec4 auroraColor = vec4(
                    0.5 * (1.0 + sin(v.x * 3.0 + time * 0.4 + noise1 * 0.5)),  // More intense red
                    0.8 * (1.0 + sin(v.y * 2.0 + time * 0.5 + noise2 * 0.7)),  // Stronger green
                    0.7 * (1.0 + sin(v.x * v.y + time * 0.6 + noise1 * noise2)),  // More vibrant blue
                    1.0
                );
                
                // Core colors of touch points - make more vibrant and varied
                vec4 core1Color = vec4(
                    0.1 + 0.4 * sin(time * 2.0),           // More dramatic pulsing red
                    0.9 + 0.3 * sin(time * 2.5 + 2.0),     // Strong green with variation
                    0.6 + 0.4 * sin(time * 3.0 + 4.0),     // More intense pulsing blue
                    1.0
                );
                
                vec4 core2Color = vec4(
                    0.2 + 0.4 * sin(time * 2.2 + 1.0),     // More dramatic red pulse
                    0.3 + 0.3 * sin(time * 2.7 + 3.0),     // Enhanced green
                    0.9 + 0.3 * sin(time * 3.2 + 5.0),     // Strong blue with variation
                    1.0
                );
                
                // More intense touch colors with trail falloff and core texturing
                float coreFactor1 = 4.0 * pow(1.0 - min(1.0, t1 * 0.8), 5.0);
                float coreFactor2 = 4.0 * pow(1.0 - min(1.0, t2 * 0.8), 5.0);
                
                float trailFactor1 = 3.0 * pow(1.0 - min(1.0, t1 * 0.9), 4.0);
                float trailFactor1a = 2.5 * pow(1.0 - min(1.0, t1a * 0.9), 4.0) * 0.7;
                float trailFactor1b = 2.0 * pow(1.0 - min(1.0, t1b * 0.9), 4.0) * 0.5;
                float trailFactor1c = 1.5 * pow(1.0 - min(1.0, t1c * 0.9), 4.0) * 0.4;
                float trailFactor1d = 1.2 * pow(1.0 - min(1.0, t1d * 0.9), 4.0) * 0.3;
                float trailFactor1e = 1.0 * pow(1.0 - min(1.0, t1e * 0.9), 4.0) * 0.2;
                float trailFactor1f = 2.0 * pow(1.0 - min(1.0, t1f * 0.9), 4.0) * 0.6;
                
                float trailFactor2 = 3.0 * pow(1.0 - min(1.0, t2 * 0.9), 4.0);
                float trailFactor2a = 2.5 * pow(1.0 - min(1.0, t2a * 0.9), 4.0) * 0.7;
                float trailFactor2b = 2.0 * pow(1.0 - min(1.0, t2b * 0.9), 4.0) * 0.5;
                float trailFactor2c = 1.5 * pow(1.0 - min(1.0, t2c * 0.9), 4.0) * 0.4;
                float trailFactor2d = 1.2 * pow(1.0 - min(1.0, t2d * 0.9), 4.0) * 0.3;
                float trailFactor2e = 1.0 * pow(1.0 - min(1.0, t2e * 0.9), 4.0) * 0.2;
                float trailFactor2f = 2.0 * pow(1.0 - min(1.0, t2f * 0.9), 4.0) * 0.6;
                
                // Core of touch points with texture noise
                vec4 coreTouch1 = mix(
                    vec4(0.0, 0.9, 0.5, 1.0), 
                    core1Color, 
                    noise1
                ) * coreFactor1;
                
                vec4 coreTouch2 = mix(
                    vec4(0.1, 0.3, 0.9, 1.0), 
                    core2Color, 
                    noise2
                ) * coreFactor2;
                
                // Green magic touch with trail - more vibrant greens
                vec4 touch1Color = vec4(0.0, 1.0, 0.6, 1.0) * trailFactor1;
                vec4 touch1ColorA = vec4(0.0, 0.95, 0.55, 1.0) * trailFactor1a;
                vec4 touch1ColorB = vec4(0.0, 0.9, 0.5, 1.0) * trailFactor1b;
                vec4 touch1ColorC = vec4(0.0, 0.85, 0.45, 1.0) * trailFactor1c;
                vec4 touch1ColorD = vec4(0.0, 0.8, 0.4, 1.0) * trailFactor1d;
                vec4 touch1ColorE = vec4(0.0, 0.75, 0.35, 1.0) * trailFactor1e;
                vec4 touch1ColorF = mix(vec4(0.3, 1.0, 0.6, 1.0), vec4(0.1, 0.8, 0.4, 1.0), noise1) * trailFactor1f;
                
                // Blue magic touch with trail - more intense blues
                vec4 touch2Color = vec4(0.1, 0.4, 1.0, 1.0) * trailFactor2;
                vec4 touch2ColorA = vec4(0.1, 0.38, 0.95, 1.0) * trailFactor2a;
                vec4 touch2ColorB = vec4(0.1, 0.36, 0.9, 1.0) * trailFactor2b;
                vec4 touch2ColorC = vec4(0.1, 0.34, 0.85, 1.0) * trailFactor2c;
                vec4 touch2ColorD = vec4(0.1, 0.32, 0.8, 1.0) * trailFactor2d;
                vec4 touch2ColorE = vec4(0.1, 0.3, 0.75, 1.0) * trailFactor2e;
                vec4 touch2ColorF = mix(vec4(0.2, 0.5, 1.0, 1.0), vec4(0.0, 0.3, 0.8, 1.0), noise2) * trailFactor2f;
                
                // Combine all trail colors for smoky effect with core highlights
                vec4 combinedTrailColor = coreTouch1 + touch1Color + touch1ColorA + touch1ColorB + touch1ColorC + 
                                        touch1ColorD + touch1ColorE + touch1ColorF +
                                        coreTouch2 + touch2Color + touch2ColorA + touch2ColorB + touch2ColorC + 
                                        touch2ColorD + touch2ColorE + touch2ColorF;
                
                // Apply fluid effect only where there's activity
                float activity = clamp(length(combinedTrailColor), 0.0, 1.0);
                
                // Create final magical effect
                vec4 fluidColor = mix(backgroundColor, auroraColor * factor * 3.0, clamp(intensity * 0.5, 0.0, 1.0));
                fluidColor = mix(fluidColor, combinedTrailColor, 0.9);
                
                // Add faint background energy field - enhanced with more dynamic patterns
                float backgroundEnergy = 0.0;
                if (u_enable_background > 0.5) {
                    backgroundEnergy = 0.12 * (0.5 + 0.5 * sin(p.x * 8.0 + time) * sin(p.y * 8.0 + time * 0.7));
                    backgroundEnergy += 0.08 * sin(p.x * p.y * 5.0 + time * 0.5);
                }
                
                // Create lightning/tendril effect between the two touch points
                // Only render if touch points are far enough apart and tendrils are enabled
                float touchDistance = length(touch1 - touch2);
                vec4 lightningColor = vec4(0.0);
                
                if (touchDistance > 0.15 && u_enable_tendrils > 0.5) {
                    // Apply control panel thickness and turbulence settings
                    float baseThickness = 0.01 * u_tendril_thickness; 
                    float baseTurbulence = 1.0 * u_tendril_turbulence;
                    
                    // Create multiple layers of tendrils with different properties
                    
                    // Primary tendril - thin, fast-moving
                    float tendrilIntensity1 = swirlTendril(p, touch1, touch2, time, baseThickness, baseTurbulence);
                    
                    // Secondary tendril - offset in time for different pattern
                    float tendrilIntensity2 = swirlTendril(p, touch1, touch2, time + 4.27, baseThickness * 0.8, baseTurbulence * 0.8);
                    
                    // Tertiary tendril - slower movement, thinner
                    float tendrilIntensity3 = swirlTendril(p, touch1, touch2, time * 0.7, baseThickness * 0.5, baseTurbulence * 1.2);
                    
                    // Create a more organic connection by adding a few more very thin tendrils
                    float microTendril1 = swirlTendril(p, touch1, touch2, time * 1.3 + 2.8, baseThickness * 0.3, baseTurbulence * 1.5);
                    float microTendril2 = swirlTendril(p, touch1, touch2, time * 0.9 - 3.6, baseThickness * 0.25, baseTurbulence * 1.7);
                    
                    // Color the tendrils with fiery, organic colors
                    // Main tendril - orange-red, fiery
                    vec4 primaryTendril = vec4(0.9, 0.3, 0.05, 1.0) * tendrilIntensity1;
                    
                    // Secondary tendril - yellow-orange, like a flame's edge
                    vec4 secondaryTendril = vec4(1.0, 0.5, 0.05, 1.0) * tendrilIntensity2;
                    
                    // Tertiary tendril - deeper red for depth
                    vec4 tertiaryTendril = vec4(0.7, 0.1, 0.05, 1.0) * tendrilIntensity3;
                    
                    // Micro-tendrils with subtle purple/blue tint for contrast
                    vec4 microTendrilColor1 = vec4(0.3, 0.1, 0.5, 1.0) * microTendril1 * 0.5;
                    vec4 microTendrilColor2 = vec4(0.1, 0.05, 0.3, 1.0) * microTendril2 * 0.4;
                    
                    // Create time-varying color shift with subtle variations
                    float colorShift = sin(time * 1.5) * 0.3 + 0.7;
                    float intensityPulse = 0.7 + 0.3 * pow(sin(time * 2.3) * 0.5 + 0.5, 2.0);
                    
                    // Combine all tendril effects with appropriate blending
                    lightningColor = primaryTendril * intensityPulse + 
                                    secondaryTendril * colorShift +
                                    tertiaryTendril * (0.6 + 0.4 * sin(time * 1.1)) +
                                    microTendrilColor1 + microTendrilColor2;
                    
                    // Add soft glow around the tendrils with control panel glow setting
                    float glowThickness = 0.05 * u_tendril_glow;
                    float glowIntensity = swirlTendril(p, touch1, touch2, time * 0.8, glowThickness, baseTurbulence * 0.5) * 0.3;
                    lightningColor += vec4(0.5, 0.1, 0.05, 0.7) * glowIntensity * u_tendril_glow;
                }
                
                // Final composition with background energy field and lightning
                vec4 finalColor = mix(
                    mix(backgroundColor, auroraColor * 0.4, backgroundEnergy), 
                    fluidColor, 
                    clamp(activity * 4.0, 0.0, 1.0)
                );
                
                // Add the lightning effect on top
                finalColor += lightningColor;
                
                return finalColor;
            }
            
            void main() {
                vec2 touch1 = u_touch1 * 2.0 - 1.0; // Convert to -1 to 1 range
                vec2 touch2 = u_touch2 * 2.0 - 1.0;
                touch1.y *= -1.0; // Flip Y
                touch2.y *= -1.0;
                
                vec4 color = fluidEffect(gl_FragCoord.xy / u_resolution, u_time, touch1, touch2);
                
                // Pre-calculate normalized position for targets
                vec2 normalizedPos = gl_FragCoord.xy / u_resolution * 2.0 - 1.0;
                
                // Highlight targets with dynamic pulsing effects
                for (int i = 0; i < ${MAX_TARGETS}; i++) {
                    if (u_target_active[i] > 0.5) {
                        vec2 targetPos = u_targets[i] * 2.0 - 1.0;
                        targetPos.y *= -1.0;
                        float dist = length(normalizedPos - targetPos);
                        
                        if (dist < 0.1) {
                            // Dynamic pulsing effect
                            float pulse = sin(u_time * 8.0) * 0.2 + 0.8;
                            float glow = (0.1 - dist) / 0.1 * pulse;
                            
                            // Good target: enhanced green glow with pulse
                            if (u_target_type[i] < 0.5) {
                                vec4 glowColor = vec4(0.0, 1.0, 0.5, 1.0);
                                // Add sparkle effect
                                glowColor += vec4(0.2) * pow(sin(u_time * 10.0 + dist * 50.0), 10.0);
                                color = mix(color, glowColor, glow * 0.8 + 0.3 * sin(u_time * 6.0));
                            } 
                            // Bad target: enhanced red glow with pulse
                            else {
                                vec4 glowColor = vec4(1.0, 0.2, 0.3, 1.0);
                                // Add warning pulse effect
                                glowColor += vec4(0.3, 0.0, 0.0, 0.0) * pow(sin(u_time * 15.0), 4.0);
                                color = mix(color, glowColor, glow * 0.8 + 0.3 * sin(u_time * 6.0));
                            }
                        }
                    }
                }
                
                // Add shockwave effects when targets are collected (if enabled)
                if (u_enable_shockwaves > 0.5) {
                    for (int i = 0; i < ${MAX_TARGETS}; i++) {
                        if (u_shockwave_active[i] > 0.5) {
                            vec2 shockwavePos = u_shockwave_pos[i] * 2.0 - 1.0;
                            shockwavePos.y *= -1.0;
                            
                            float timeSinceStart = u_time - u_shockwave_start[i];
                            
                            if (timeSinceStart < 1.0) {
                                float waveRadius = timeSinceStart * 0.6; // Speed of expansion
                                float dist = length(normalizedPos - shockwavePos);
                                float thickness = 0.03 * (1.0 - timeSinceStart); // Wave gets thinner as it expands
                                
                                // Create ring effect
                                float waveFront = smoothstep(0.0, thickness, abs(dist - waveRadius));
                                waveFront = 1.0 - waveFront;
                                
                                // Apply shockwave color based on target type with intensity control
                                if (waveFront > 0.05) {
                                    if (u_shockwave_type[i] < 0.5) {
                                        // Good target: green shockwave
                                        vec4 waveColor = vec4(0.0, 1.0, 0.5, 1.0) * (1.0 - timeSinceStart) * 0.7 * u_shockwave_intensity;
                                        color += waveColor * waveFront;
                                    } else {
                                        // Bad target: red shockwave
                                        vec4 waveColor = vec4(1.0, 0.2, 0.3, 1.0) * (1.0 - timeSinceStart) * 0.7 * u_shockwave_intensity;
                                        color += waveColor * waveFront;
                                    }
                                    
                                    // Add distortion to the area inside the shockwave
                                    if (dist < waveRadius) {
                                        float distortionFactor = 0.05 * (1.0 - dist/waveRadius) * (1.0 - timeSinceStart) * u_shockwave_intensity;
                                        color.rgb += sin(color.gbr * 10.0 + u_time * 5.0) * distortionFactor;
                                    }
                                }
                            }
                        }
                    }
                }
                
                gl_FragColor = color;
            }
        `;
        
        // Create shader program
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compilation error:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            
            return shader;
        }
        
        function createProgram(gl, vertexShader, fragmentShader) {
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Program linking error:', gl.getProgramInfoLog(program));
                return null;
            }
            
            return program;
        }
        
        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
        const program = createProgram(gl, vertexShader, fragmentShader);
        
        // Set up position buffer
        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
            -1, -1,
            1, -1,
            -1, 1,
            -1, 1,
            1, -1,
            1, 1
        ]), gl.STATIC_DRAW);
        
        // Get uniform locations
        const resolutionUniformLocation = gl.getUniformLocation(program, 'u_resolution');
        const timeUniformLocation = gl.getUniformLocation(program, 'u_time');
        const touch1UniformLocation = gl.getUniformLocation(program, 'u_touch1');
        const touch2UniformLocation = gl.getUniformLocation(program, 'u_touch2');
        
        // Get target uniform locations
        const targetLocations = [];
        const targetActiveLocations = [];
        const targetTypeLocations = [];
        for (let i = 0; i < MAX_TARGETS; i++) {
            targetLocations.push(gl.getUniformLocation(program, `u_targets[${i}]`));
            targetActiveLocations.push(gl.getUniformLocation(program, `u_target_active[${i}]`));
            targetTypeLocations.push(gl.getUniformLocation(program, `u_target_type[${i}]`));
        }
        
        // Get shockwave uniform locations
        const shockwaveActiveLocations = [];
        const shockwavePosLocations = [];
        const shockwaveStartLocations = [];
        const shockwaveTypeLocations = [];
        for (let i = 0; i < MAX_TARGETS; i++) {
            shockwaveActiveLocations.push(gl.getUniformLocation(program, `u_shockwave_active[${i}]`));
            shockwavePosLocations.push(gl.getUniformLocation(program, `u_shockwave_pos[${i}]`));
            shockwaveStartLocations.push(gl.getUniformLocation(program, `u_shockwave_start[${i}]`));
            shockwaveTypeLocations.push(gl.getUniformLocation(program, `u_shockwave_type[${i}]`));
        }
        
        // Touch and mouse handling
        let touch1 = { x: 0.25, y: 0.5 };
        let touch2 = { x: 0.75, y: 0.5 };
        let isMouseDown = false;
        
        function handleTouches(e) {
            e.preventDefault();
            
            // Track if both thumbs are active
            bothThumbsActive = (e.touches.length >= 2);
            
            if (e.touches.length >= 1) {
                touch1.x = e.touches[0].clientX / canvas.width;
                touch1.y = e.touches[0].clientY / canvas.height;
            }
            
            if (e.touches.length >= 2) {
                touch2.x = e.touches[1].clientX / canvas.width;
                touch2.y = e.touches[1].clientY / canvas.height;
                
                // If this is the first time both thumbs are active, initialize the lastActiveScoreTime
                if (lastActiveScoreTime === 0) {
                    lastActiveScoreTime = Date.now();
                }
            }
            
            // Check for target collection
            checkTargets();
        }
        
        // Mouse support for desktop users
        function handleMouseMove(e) {
            if (!isMouseDown) return;
            
            // Update the first touch point to follow the mouse
            touch1.x = e.clientX / canvas.width;
            touch1.y = e.clientY / canvas.height;
            
            // Create a secondary touch point that follows at an offset
            // This simulates having two fingers but with just a mouse
            touch2.x = 1 - touch1.x;
            touch2.y = 1 - touch1.y;
            
            // Check for target collection
            checkTargets();
        }
        
        function handleMouseDown(e) {
            isMouseDown = true;
            
            // When using mouse, both "thumbs" are considered active
            bothThumbsActive = true;
            if (lastActiveScoreTime === 0) {
                lastActiveScoreTime = Date.now();
            }
            
            // Update the first touch point to follow the mouse
            touch1.x = e.clientX / canvas.width;
            touch1.y = e.clientY / canvas.height;
            
            // Create a secondary touch point that follows at an offset
            touch2.x = 1 - touch1.x;
            touch2.y = 1 - touch1.y;
            
            // Check for target collection on initial click
            checkTargets();
        }
        
        function handleMouseUp() {
            isMouseDown = false;
            bothThumbsActive = false;
        }
        
        // Also check for clicks directly on targets (for easier desktop play)
        function handleClick(e) {
            const mouseX = e.clientX / canvas.width;
            const mouseY = e.clientY / canvas.height;
            
            // Check if the click was directly on a target
            targets.forEach(target => {
                if (target.collected) return;
                
                const dist = Math.hypot(
                    target.x - mouseX,
                    target.y - mouseY
                );
                
                if (dist < 0.08) {  // Same collection radius as with touch
                    collectTarget(target);
                }
            });
        }
        
        // Touch events
        canvas.addEventListener('touchstart', handleTouches);
        canvas.addEventListener('touchmove', handleTouches);
        
        // Mouse events
        canvas.addEventListener('mousedown', handleMouseDown);
        canvas.addEventListener('mousemove', handleMouseMove);
        canvas.addEventListener('mouseup', handleMouseUp);
        canvas.addEventListener('mouseleave', handleMouseUp);
        canvas.addEventListener('click', handleClick);
        
        // Score update with animation and sound
        function updateScore(points) {
            score += points;
            document.getElementById('score').textContent = `Score: ${score}`;
            
            // Visual feedback
            const scoreElement = document.getElementById('score');
            scoreElement.classList.remove('negative');
            
            if (points > 0) {
                scoreDirection = 1;
                // Play good sound
                if (audioEnabled) {
                    createCollectSound();
                }
                // Short vibration for good targets
                vibrate(50);
            } else {
                scoreDirection = -1;
                scoreElement.classList.add('negative');
                // Play bad sound
                if (audioEnabled) {
                    createBadSound();
                }
                // More intense vibration for bad targets
                vibrate([50, 50, 100]);
            }
            
            lastScoreChange = Date.now();
            
            // Reset visual feedback after a delay
            setTimeout(() => {
                scoreElement.classList.remove('negative');
            }, 500);
        }
        
        // Target generation
        function createTarget() {
            if (targets.length >= MAX_TARGETS) return;
            
            // Decide if this is a good or bad target
            const isBad = Math.random() < 0.3; // 30% chance for bad targets
            
            const target = {
                x: Math.random() * 0.8 + 0.1,
                y: Math.random() * 0.8 + 0.1,
                createdAt: Date.now(),
                collected: false,
                isBad: isBad,
                element: document.createElement('div')
            };
            
            // Set appropriate CSS class
            target.element.className = isBad ? 'target bad' : 'target good';
            target.element.style.left = `${target.x * 100}%`;
            target.element.style.top = `${target.y * 100}%`;
            document.getElementById('targets').appendChild(target.element);
            
            targets.push(target);
        }
        
        function removeTarget(target) {
            target.element.remove();
            targets = targets.filter(t => t !== target);
        }
        
        function updateTargets() {
            const now = Date.now();
            
            // Remove expired targets
            targets.forEach(target => {
                if (now - target.createdAt > targetLifespan && !target.collected) {
                    removeTarget(target);
                }
            });
            
            // Create new targets if needed, rate affected by control panel
            if (targets.length < MAX_TARGETS && Math.random() < (0.01 * gameSettings.targetGenerationRate)) {
                createTarget();
            }
        }
        
        // Create a new shockwave effect
        function createShockwave(x, y, isGood) {
            // Find an available slot for a new shockwave
            let index = -1;
            for (let i = 0; i < MAX_TARGETS; i++) {
                if (!shockwaves[i] || !shockwaves[i].active) {
                    index = i;
                    break;
                }
            }
            
            // If no slot is available, return
            if (index === -1) return;
            
            // Create the shockwave
            shockwaves[index] = {
                active: true,
                x: x,
                y: y,
                startTime: Date.now() / 1000, // Current time in seconds
                isGood: isGood
            };
        }
        
        function checkTargets() {
            targets.forEach(target => {
                if (target.collected) return;
                
                const distToTouch1 = Math.hypot(
                    target.x - touch1.x,
                    target.y - touch1.y
                );
                
                const distToTouch2 = Math.hypot(
                    target.x - touch2.x,
                    target.y - touch2.y
                );
                
                if (distToTouch1 < 0.08 || distToTouch2 < 0.08) {
                    collectTarget(target);
                }
            });
        }
        
        function collectTarget(target) {
            if (target.collected) return;
            
            target.collected = true;
            
            // Create a shockwave effect at the target's position
            createShockwave(target.x, target.y, !target.isBad);
            
            if (target.isBad) {
                // Bad target visuals
                target.element.style.border = '4px solid rgba(255, 51, 102, 1.0)';
                target.element.style.boxShadow = '0 0 25px rgba(255, 51, 102, 1.0)';
                updateScore(-15); // Lose 15 points
            } else {
                // Good target visuals
                target.element.style.border = '4px solid rgba(0, 255, 170, 1.0)';
                target.element.style.boxShadow = '0 0 25px rgba(0, 255, 170, 1.0)';
                updateScore(10); // Gain 10 points
            }
            
            target.element.style.animation = 'none';
            target.element.style.transform = 'translate(-50%, -50%) scale(1.2)';
            
            setTimeout(() => {
                removeTarget(target);
            }, 500);
        }
        
        // Animation loop
        let startTime = Date.now();
        
        // Check if tendril intersects with a target
        function checkTendrilTargetIntersection() {
            // Only check if tendrils are enabled
            if (!gameSettings.enableTendrils) return;
            
            // Only check if the thumbs are far enough apart to create a tendril
            let touchDistance = Math.hypot(
                touch1.x - touch2.x,
                touch1.y - touch2.y
            );
            
            if (touchDistance < 0.15) return;
            
            // Create a simplified path between touch points to check for collisions
            // We'll sample multiple points along the path to approximate the tendril
            const numSamples = 10;
            
            targets.forEach(target => {
                if (target.collected) return;
                
                let hit = false;
                
                // Check multiple points along the tendril path
                for (let i = 0; i <= numSamples; i++) {
                    const t = i / numSamples;
                    
                    // Simple linear interpolation between touch points
                    // This is an approximation - the actual tendril has swirls and curves
                    const x = touch1.x + (touch2.x - touch1.x) * t;
                    const y = touch1.y + (touch2.y - touch1.y) * t;
                    
                    // Add some randomization to simulate the swirly nature
                    // This is a simplification of the shader's complex patterns
                    const time = Date.now() / 1000;
                    const offset = 0.05 * gameSettings.tendrilTurbulence * Math.sin(t * 6 + time * 2);
                    
                    // Calculate distance to target
                    const dist = Math.hypot(
                        target.x - (x + offset),
                        target.y - y
                    );
                    
                    // Thickness depends on control panel settings
                    const thickness = 0.05 * gameSettings.tendrilThickness;
                    
                    if (dist < thickness + 0.03) {  // 0.03 is approximate target hit radius
                        hit = true;
                        break;
                    }
                }
                
                if (hit) {
                    // Tendril hit target!
                    if (target.isBad) {
                        // Penalize for hitting bad target with tendril
                        updateScore(-5);
                    } else {
                        // Reward for hitting good target with tendril
                        updateScore(5);
                    }
                    collectTarget(target);
                }
            });
        }
        
        // Check if thumbs are too close and apply penalty
        function checkThumbsDistance() {
            if (!bothThumbsActive) return;
            
            const touchDistance = Math.hypot(
                touch1.x - touch2.x,
                touch1.y - touch2.y
            );
            
            // If thumbs are too close, apply penalty (but only once)
            if (touchDistance < THUMBS_TOO_CLOSE_THRESHOLD && !thumbsClosePenaltyActive) {
                thumbsClosePenaltyActive = true;
                updateScore(-3);
                
                // Visual and haptic feedback
                if (navigator.vibrate) {
                    navigator.vibrate([50, 50, 50]);  // More intense vibration for penalty
                }
                
                // Add a small timeout to prevent constant penalties
                setTimeout(() => {
                    thumbsClosePenaltyActive = false;
                }, 1000);
            }
        }
        
        // Check for bonus when both thumbs are active
        function checkActiveThumbsBonus() {
            const now = Date.now();
            
            // Only apply if both thumbs are currently active
            if (bothThumbsActive && now - lastActiveScoreTime > BOTH_THUMBS_ACTIVE_SCORE_INTERVAL) {
                updateScore(1);  // Small bonus for keeping both thumbs active
                lastActiveScoreTime = now;
            }
        }
        
        function render() {
            resize();
            updateTargets();
            
            // Game rule checks
            checkTendrilTargetIntersection();
            checkThumbsDistance();
            checkActiveThumbsBonus();
            
            const currentTime = (Date.now() - startTime) / 1000;
            
            // True black background
            gl.clearColor(0, 0, 0, 1);
            gl.clear(gl.COLOR_BUFFER_BIT);
            
            gl.useProgram(program);
            
            // Set uniforms
            gl.uniform2f(resolutionUniformLocation, canvas.width, canvas.height);
            gl.uniform1f(timeUniformLocation, currentTime);
            gl.uniform2f(touch1UniformLocation, touch1.x, touch1.y);
            gl.uniform2f(touch2UniformLocation, touch2.x, touch2.y);
            
            // Set control panel uniforms
            gl.uniform1f(gl.getUniformLocation(program, 'u_fluid_intensity'), gameSettings.fluidIntensity);
            gl.uniform1f(gl.getUniformLocation(program, 'u_enable_background'), gameSettings.enableBackground ? 1.0 : 0.0);
            gl.uniform1f(gl.getUniformLocation(program, 'u_enable_tendrils'), gameSettings.enableTendrils ? 1.0 : 0.0);
            gl.uniform1f(gl.getUniformLocation(program, 'u_tendril_thickness'), gameSettings.tendrilThickness);
            gl.uniform1f(gl.getUniformLocation(program, 'u_tendril_turbulence'), gameSettings.tendrilTurbulence);
            gl.uniform1f(gl.getUniformLocation(program, 'u_tendril_glow'), gameSettings.tendrilGlow);
            gl.uniform1f(gl.getUniformLocation(program, 'u_enable_shockwaves'), gameSettings.enableShockwaves ? 1.0 : 0.0);
            gl.uniform1f(gl.getUniformLocation(program, 'u_shockwave_intensity'), gameSettings.shockwaveIntensity);
            
            // Set target uniforms
            for (let i = 0; i < MAX_TARGETS; i++) {
                if (i < targets.length && !targets[i].collected) {
                    gl.uniform2f(targetLocations[i], targets[i].x, targets[i].y);
                    gl.uniform1f(targetActiveLocations[i], 1.0);
                    gl.uniform1f(targetTypeLocations[i], targets[i].isBad ? 1.0 : 0.0);
                } else {
                    gl.uniform2f(targetLocations[i], 0, 0);
                    gl.uniform1f(targetActiveLocations[i], 0.0);
                    gl.uniform1f(targetTypeLocations[i], 0.0);
                }
            }
            
            // Set shockwave uniforms
            for (let i = 0; i < MAX_TARGETS; i++) {
                if (shockwaves[i] && shockwaves[i].active) {
                    const timeSinceStart = currentTime - shockwaves[i].startTime;
                    
                    // Deactivate shockwaves after 1 second
                    if (timeSinceStart > 1.0) {
                        shockwaves[i].active = false;
                        gl.uniform1f(shockwaveActiveLocations[i], 0.0);
                    } else {
                        gl.uniform1f(shockwaveActiveLocations[i], 1.0);
                        gl.uniform2f(shockwavePosLocations[i], shockwaves[i].x, shockwaves[i].y);
                        gl.uniform1f(shockwaveStartLocations[i], shockwaves[i].startTime);
                        gl.uniform1f(shockwaveTypeLocations[i], shockwaves[i].isGood ? 0.0 : 1.0);
                    }
                } else {
                    gl.uniform1f(shockwaveActiveLocations[i], 0.0);
                }
            }
            
            // Set position attribute
            const positionAttributeLocation = gl.getAttribLocation(program, 'a_position');
            gl.enableVertexAttribArray(positionAttributeLocation);
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);
            
            // Draw
            gl.drawArrays(gl.TRIANGLES, 0, 6);
            
            requestAnimationFrame(render);
        }
        
        // Start the game - audio needs user interaction to work in modern browsers
        
        // Add additional event listeners to ensure audio context starts
        // First user interaction with the page will enable audio
        function enableAudio() {
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
            
            // Play a test sound to ensure audio is working
            if (audioEnabled) {
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                gain.gain.value = 0.2;  // More audible test sound
                osc.frequency.value = 440; // A4 note
                osc.connect(gain);
                gain.connect(audioContext.destination);
                osc.start();
                osc.stop(audioContext.currentTime + 0.1);
            }
            
            // Remove event listeners once audio is enabled
            document.removeEventListener('click', enableAudio);
            document.removeEventListener('touchstart', enableAudio);
            
            // Alert the user that audio is now enabled
            const audioAlert = document.createElement('div');
            audioAlert.textContent = 'Audio enabled! üîä';
            audioAlert.style.position = 'absolute';
            audioAlert.style.top = '70px';
            audioAlert.style.left = '0';
            audioAlert.style.width = '100%';
            audioAlert.style.textAlign = 'center';
            audioAlert.style.color = '#00ffaa';
            audioAlert.style.fontFamily = 'Arial, sans-serif';
            audioAlert.style.fontSize = '18px';
            audioAlert.style.zIndex = '20';
            audioAlert.style.pointerEvents = 'none';
            document.body.appendChild(audioAlert);
            
            // Remove the alert after 2 seconds
            setTimeout(() => {
                audioAlert.remove();
            }, 2000);
        }
        
        // Add user interaction listeners to enable audio
        document.addEventListener('click', enableAudio);
        document.addEventListener('touchstart', enableAudio);
        
        // Initial target creation and start render loop
        createTarget();
        render();
    </script>
</body>
</html>