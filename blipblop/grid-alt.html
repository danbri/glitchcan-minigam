<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>Dual Pattern Bass Sequencer</title>
    <style>
        :root {
            --bg-color: #120458;
            --primary-glow: #ff00a0;
            --secondary-glow: #2de2e6;
            --dark-accent: #0d033d;
            --light-text: #eeeeee;
            --button-text: #120458;
            --monospace-font: 'Courier New', Courier, monospace;
            --sans-serif-font: 'Arial', sans-serif;
        }

        body {
            font-family: var(--sans-serif-font);
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: var(--bg-color);
            color: var(--primary-glow);
            padding: 15px;
            margin: 0;
            overscroll-behavior: none;
            user-select: none;
            -webkit-user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        h1 {
            font-size: 1.8em;
            font-weight: bold;
            text-shadow: 0 0 6px var(--primary-glow), 0 0 12px var(--primary-glow);
            margin: 20px 0;
            text-align: center;
        }

        #sequencer-container {
            width: fit-content; /* Adjust size to content */
            max-width: 100%;
            margin: 20px 0;
            background-color: var(--dark-accent);
            padding: 8px;
            border: 1px solid var(--primary-glow);
            border-radius: 6px;
            box-shadow: 0 0 15px rgba(255, 0, 160, 0.3);
        }

        #sequencer {
            display: grid;
            gap: 4px; /* Slightly more space */
            position: relative;
        }

        .row-label {
            display: flex;
            align-items: center;
            justify-content: center; /* Center label */
            font-weight: bold;
            min-width: 35px; /* Narrower */
            color: var(--primary-glow);
            font-size: 0.9em;
            padding-right: 5px;
        }

        .note {
            width: 32px; /* Slightly larger */
            height: 32px;
            border: 1px solid var(--primary-glow);
            cursor: pointer;
            transition: opacity 0.15s ease, box-shadow 0.15s ease, transform 0.1s ease;
            border-radius: 4px; /* More rounded */
            position: relative;
            background-color: rgba(255, 255, 255, 0.05); /* Subtle base background */
        }
        /* Apply note color via inline style, control base appearance here */
        .note[style*="background-color"] {
             background-color: inherit; /* Let inline style override if set, otherwise use base */
        }

        .note.active {
            box-shadow: 0 0 8px currentColor, 0 0 15px currentColor; /* Use note's color for glow */
            transform: scale(1.03);
            border-width: 2px; /* Emphasize active border */
        }

        .note.playing {
            /* Use white highlight distinct from active state */
            box-shadow: 0 0 10px #ffffff, 0 0 20px #ffffff !important;
            border: 2px solid #ffffff !important;
            opacity: 1 !important; /* Ensure full visibility */
            transform: scale(1.06);
        }

        .vertical-highlight {
            position: absolute;
            top: 8px; /* Align with grid padding */
            bottom: 8px;
            width: calc(32px + 4px); /* note width + gap */
            background-color: rgba(45, 226, 230, 0.35); /* secondary glow, slightly more opaque */
            pointer-events: none;
            transition: left 0.05s linear;
            z-index: 3;
            border-radius: 3px;
            left: -100px; /* Starts hidden */
            display: none; /* Hide initially */
        }
        body.playing .vertical-highlight {
            display: block; /* Show only when playing */
        }


        #controls {
            margin: 15px 0;
            display: flex;
            gap: 15px; /* Space between buttons */
            justify-content: center;
            flex-wrap: wrap; /* Allow wrapping on small screens */
        }

        button {
            padding: 12px 25px;
            font-size: 1.1em;
            font-weight: bold;
            background-color: var(--secondary-glow);
            border: none;
            color: var(--button-text);
            cursor: pointer;
            transition: all 0.2s ease;
            border-radius: 5px;
            box-shadow: 0 3px 6px rgba(0,0,0,0.2), 0 0 8px rgba(45, 226, 230, 0.5);
            min-width: 100px; /* Ensure decent button width */
            text-align: center;
        }
        button:hover {
            background-color: var(--primary-glow);
            color: var(--light-text);
            box-shadow: 0 4px 8px rgba(0,0,0,0.3), 0 0 15px var(--primary-glow);
        }
        button:active {
            transform: translateY(1px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2), 0 0 5px var(--primary-glow);
        }
        /* Style for the active pattern button */
        #togglePatternButton.patternB {
             background-color: #ff80ed; /* Different color for Pattern B */
             box-shadow: 0 3px 6px rgba(0,0,0,0.2), 0 0 8px rgba(255, 128, 237, 0.5);
        }
         #togglePatternButton.patternB:hover {
             background-color: #f757e1;
             color: var(--light-text);
             box-shadow: 0 4px 8px rgba(0,0,0,0.3), 0 0 15px #f757e1;
         }


        #log-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 95%;
            max-width: 400px; /* Wider logs */
            margin-top: 15px;
            gap: 10px;
        }

        #activity-stream, #console-log {
            width: 100%;
            height: 60px; /* Slightly taller */
            overflow-y: scroll;
            border: 1px solid var(--primary-glow);
            padding: 8px;
            background-color: rgba(18, 4, 88, 0.75);
            font-size: 0.8em;
            border-radius: 4px;
            color: var(--light-text);
            box-sizing: border-box; /* Include padding in width */
        }

        #console-log {
            color: var(--secondary-glow);
            font-family: var(--monospace-font);
        }
    </style>
</head>
<body>


    <div id="sequencer-container">
        <div id="sequencer">
            <!-- Grid elements generated here -->
        </div>
    </div>

    <div id="controls">
      <button id="playPause">Play</button>
      <button id="togglePatternButton">Pattern A</button> <!-- Toggle Button Added -->
    </div>

    <div id="log-container">
        <div id="activity-stream">Activity Log Initialized...</div>
        <div id="console-log">Console Log Initialized...</div>
    </div>

    <script>
        let audioContext;
        // Notes array (pitch-ordered E2 to F3)
        const notes = [
            { index: 0, name: 'E2',   freq: 82.41,  key: 'E2', color: '#4575b4', voice: 'sawtooth' },
            { index: 1, name: 'G2',   freq: 98.00,  key: 'G2', color: '#7d0abf', voice: 'sawtooth' },
            { index: 2, name: 'A2',   freq: 110.00, key: 'A2', color: '#d73027', voice: 'sawtooth' },
            { index: 3, name: 'B2',   freq: 123.47, key: 'B2', color: '#2477db', voice: 'sawtooth' },
            { index: 4, name: 'C3',   freq: 130.81, key: 'C3', color: '#7d0abf', voice: 'sawtooth' },
            { index: 5, name: 'D3',   freq: 146.83, key: 'D3', color: '#1a9850', voice: 'sawtooth' },
            { index: 6, name: 'E3',   freq: 164.81, key: 'E3', color: '#fee08b', voice: 'sawtooth' },
            { index: 7, name: 'F3',   freq: 174.61, key: 'F3', color: '#FF69B4', voice: 'sawtooth' },
        ];

        const steps = 8;
        let isPlaying = false;
        let currentStep = 0;
        let intervalId = null;
        const stepDuration = 0.25; // Duration of one eighth note step

        const sequencer = document.getElementById('sequencer');
        const playPauseBtn = document.getElementById('playPause');
        const togglePatternBtn = document.getElementById('togglePatternButton'); // Get toggle button
        const activityStream = document.getElementById('activity-stream');
        const consoleElement = document.getElementById('console-log');

        // --- Grid Data for Both Patterns ---
        const gridA = notes.map(() => Array(steps).fill(false)); // Pattern A: E2-G2-D3-A2 eighths
        const gridB = notes.map(() => Array(steps).fill(false)); // Pattern B: E2-B2-E2-G2 sparse

        // Initialize Pattern A (E-E-G-G-D-D-A-A)
        gridA[0][0] = true; gridA[0][1] = true; // E2 (index 0)
        gridA[1][2] = true; gridA[1][3] = true; // G2 (index 1)
        gridA[5][4] = true; gridA[5][5] = true; // D3 (index 5)
        gridA[2][6] = true; gridA[2][7] = true; // A2 (index 2)

        // Initialize Pattern B (E-rest-B-rest-E-rest-G-rest)
        gridB[0][0] = true; // E2 (index 0) on Step 1
        gridB[3][2] = true; // B2 (index 3) on Step 3
        gridB[0][4] = true; // E2 (index 0) on Step 5
        gridB[1][6] = true; // G2 (index 1) on Step 7

        let activePattern = 'A'; // Start with Pattern A

        // --- Web Audio Functions ---

        function initAudioContext() { /* (Same - robust) */
             if (!audioContext) {
                try {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    consoleLog('Audio context initialized.');
                    if (audioContext.state === 'suspended') {
                         audioContext.resume().then(() => { consoleLog('Audio context resumed successfully on init.'); })
                         .catch(e => consoleLog(`Context suspended, needs interaction to resume.`));
                    }
                } catch (e) { consoleError('Web Audio API not supported.'); alert('Web Audio API not supported.'); return false; }
            } else if (audioContext.state === 'suspended') { consoleLog(`Context suspended, needs interaction to resume.`); }
            return true;
        }

        function playNote(noteData, duration = stepDuration * 0.9) { /* (Same - Suno tone match) */
            if (!audioContext || audioContext.state !== 'running') {
                consoleError(`PlayNote called but context not running (State: ${audioContext ? audioContext.state : 'null'})`);
                 if(audioContext && audioContext.state === 'suspended'){ audioContext.resume().catch(e => consoleError('Silent resume failed in playNote')); }
                return;
            }
            const now = audioContext.currentTime;
            const oscType = noteData.voice || 'sawtooth'; const filterFreq = 350; const filterQ = 1.0; const attackTime = 0.02; const sustainLevel = 0.4; const releaseTime = 0.18;
            const effectiveSustainDuration = Math.max(0.01, duration - attackTime);
            const oscillator = audioContext.createOscillator(); const filter = audioContext.createBiquadFilter(); const gainNode = audioContext.createGain();
            oscillator.type = oscType; oscillator.frequency.setValueAtTime(noteData.freq, now);
            filter.type = 'lowpass'; filter.frequency.setValueAtTime(filterFreq, now); filter.Q.setValueAtTime(filterQ, now);
            gainNode.gain.setValueAtTime(0, now); gainNode.gain.linearRampToValueAtTime(sustainLevel, now + attackTime);
            const releaseStartTime = now + effectiveSustainDuration;
            gainNode.gain.setValueAtTime(sustainLevel, releaseStartTime); gainNode.gain.linearRampToValueAtTime(0.0001, releaseStartTime + releaseTime);
            oscillator.connect(filter); filter.connect(gainNode); gainNode.connect(audioContext.destination);
            oscillator.start(now); oscillator.stop(releaseStartTime + releaseTime + 0.05);
        }

        // --- UI and Sequencer Logic ---

         function createSequencer() {
            sequencer.innerHTML = ''; // Clear existing grid
            sequencer.style.gridTemplateColumns = `auto repeat(${steps}, 1fr)`; // Setup columns

            notes.forEach((noteData) => {
                // Create Row Label
                const rowLabel = document.createElement('div');
                rowLabel.className = 'row-label';
                rowLabel.textContent = noteData.name;
                sequencer.appendChild(rowLabel);

                // Create Note Cells for the row
                for (let col = 0; col < steps; col++) {
                    const noteElement = document.createElement('div');
                    noteElement.className = 'note';
                    noteElement.dataset.row = noteData.index; // Store index (0-7)
                    noteElement.dataset.col = col;
                    noteElement.style.setProperty('--note-color', noteData.color); // Use CSS variable for glow
                    noteElement.style.backgroundColor = noteData.color; // Set base color

                    // Add event listeners
                    noteElement.addEventListener('click', toggleNote);
                    noteElement.addEventListener('touchstart', (e) => { e.preventDefault(); toggleNote(e); }, { passive: false });
                    sequencer.appendChild(noteElement);
                }
            });

            // Add highlight bar (initially hidden)
            const verticalHighlight = document.createElement('div');
            verticalHighlight.className = 'vertical-highlight';
            sequencer.appendChild(verticalHighlight);

            updateGridVisuals(); // Set initial visual state based on activePattern
            consoleLog(`Sequencer grid created. Initial pattern: ${activePattern}`);
        }

        // NEW: Updates the visual state of all grid cells based on the active pattern
        function updateGridVisuals() {
            const currentGrid = (activePattern === 'A') ? gridA : gridB;
            const noteElements = sequencer.querySelectorAll('.note');

            noteElements.forEach(noteElement => {
                const row = parseInt(noteElement.dataset.row, 10);
                const col = parseInt(noteElement.dataset.col, 10);
                const isActive = currentGrid[row][col];

                noteElement.style.opacity = isActive ? '1' : '0.35'; // Make inactive slightly more visible
                noteElement.classList.toggle('active', isActive);
            });
            consoleLog(`Grid visuals updated to Pattern ${activePattern}`);
        }


        function toggleNote(event) {
             // Standard init/resume check
             if (!initAudioContext()) return;
             if(audioContext.state === 'suspended'){
                 audioContext.resume().then(()=>{ consoleLog('Audio resumed on note toggle.'); _performToggle(event); })
                 .catch(e => consoleError('Failed to resume audio on toggle.'));
                 return;
             }
             _performToggle(event);
        }

        // Updated: Modify the correct grid array (A or B)
        function _performToggle(event) {
            const target = event.target;
            if (!target.classList.contains('note')) return;

            const row = parseInt(target.dataset.row, 10);
            const col = parseInt(target.dataset.col, 10);
            if (isNaN(row) || isNaN(col) || row < 0 || row >= notes.length || col < 0 || col >= steps) {
                 consoleError(`Invalid note coordinates: index=${row}, col=${col}`); return;
            }

            // Determine which grid to modify
            const targetGrid = (activePattern === 'A') ? gridA : gridB;

            // Toggle the state in the selected grid array
            targetGrid[row][col] = !targetGrid[row][col];

            // Update the visual state of the clicked cell immediately
            target.style.opacity = targetGrid[row][col] ? '1' : '0.35';
            target.classList.toggle('active', targetGrid[row][col]);

            // Play feedback sound if note was activated
            if (targetGrid[row][col]) {
                const noteToPlay = notes.find(n => n.index === row);
                if(noteToPlay) { playNote(noteToPlay, 0.15); }
            }

            const noteName = notes.find(n => n.index === row)?.name || `Row ${row}`;
            logActivity(`Pattern ${activePattern}: Toggled ${noteName} [Col ${col}] to ${targetGrid[row][col] ? 'ON' : 'OFF'}`);
        }

        // NEW: Function to toggle between patterns
        function togglePattern() {
            activePattern = (activePattern === 'A') ? 'B' : 'A'; // Flip the active pattern
            togglePatternBtn.textContent = `Pattern ${activePattern}`; // Update button text
            togglePatternBtn.classList.toggle('patternB', activePattern === 'B'); // Optional: for styling B differently
            updateGridVisuals(); // Update the entire grid's appearance
            logActivity(`Switched to Pattern ${activePattern}`);
        }


         function logActivity(message) { /*(Same)*/
            const logEntry = document.createElement('div');
            const time = new Date().toLocaleTimeString([], { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit'});
            logEntry.textContent = `[${time}] ${message}`;
            activityStream.insertBefore(logEntry, activityStream.firstChild);
            if (activityStream.childNodes.length > 30) { activityStream.removeChild(activityStream.lastChild); }
        }
        function consoleLog(message) { /*(Same)*/
            console.log(message);
            const logEntry = document.createElement('div');
            logEntry.textContent = `> ${message}`;
            consoleElement.appendChild(logEntry);
            consoleElement.scrollTop = consoleElement.scrollHeight;
        }
        function consoleError(message) { /*(Same)*/
            console.error(message);
            const logEntry = document.createElement('div');
            logEntry.style.color = '#FF6B6B';
            logEntry.textContent = `> ERROR: ${message}`;
            consoleElement.appendChild(logEntry);
            consoleElement.scrollTop = consoleElement.scrollHeight;
        }

        // Updated: Use the active grid for playback
        function step() {
             if (!isPlaying || !audioContext || audioContext.state !== 'running') return;

            const currentGrid = (activePattern === 'A') ? gridA : gridB; // Select grid for playback check
            const prevStep = (currentStep - 1 + steps) % steps;

            // Update highlights
            sequencer.querySelectorAll(`.note[data-col="${prevStep}"]`).forEach(noteEl => { noteEl.classList.remove('playing'); });
            const highlightElements = sequencer.querySelectorAll(`.note[data-col="${currentStep}"]`);

            // Play notes based on the *active* grid
            notes.forEach((noteData) => {
                const row = noteData.index;
                const noteElement = sequencer.querySelector(`.note[data-row="${row}"][data-col="${currentStep}"]`); // Find visual element
                if(noteElement) noteElement.classList.add('playing'); // Add playing class for visual

                if (currentGrid[row][currentStep]) { // Check ACTIVE grid data
                    playNote(noteData); // Play the note
                }
            });

            // Move highlight bar
            const verticalHighlight = sequencer.querySelector('.vertical-highlight');
            if (verticalHighlight) {
                 const firstLabel = sequencer.querySelector('.row-label');
                 const firstNote = sequencer.querySelector('.note');
                 if (firstLabel && firstNote) {
                     const labelWidth = parseFloat(getComputedStyle(firstLabel).width);
                     const noteWidth = parseFloat(getComputedStyle(firstNote).width);
                     const gap = parseFloat(getComputedStyle(sequencer).gap);
                     const highlightLeft = labelWidth + 8 + 5 + currentStep * (noteWidth + gap); // Adjust for label padding + grid padding
                     verticalHighlight.style.left = `${highlightLeft}px`;
                 }
            }

            currentStep = (currentStep + 1) % steps; // Advance step
        }

        function togglePlayPause() { /*(Same robustness check logic)*/
            if (!initAudioContext()) { alert("Could not initialize audio..."); return; }
             if (audioContext.state === 'suspended') {
                audioContext.resume().then(() => {
                     consoleLog('Audio context resumed on play toggle.');
                     if (isPlaying) { stopPlayback(); } else { startPlayback(); }
                }).catch(e => { consoleError(`Failed to resume audio context on play toggle: ${e}`); alert("Audio couldn't start..."); });
             } else {
                 if (isPlaying) { stopPlayback(); } else { startPlayback(); }
             }
        }

        function startPlayback() { /*(Same)*/
            if (isPlaying || !audioContext || audioContext.state !== 'running') return;
            currentStep = 0;
             document.body.classList.add('playing'); // Add class for highlight visibility
             step(); // Play first step immediately
            intervalId = setInterval(step, stepDuration * 1000);
            playPauseBtn.textContent = 'Pause';
            isPlaying = true;
            logActivity('Sequencer Started');
            consoleLog('Playback started.');
        }

        function stopPlayback() { /*(Same)*/
             if (!isPlaying) return;
            clearInterval(intervalId);
            intervalId = null;
             document.body.classList.remove('playing'); // Remove class to hide highlight
             sequencer.querySelectorAll(`.note.playing`).forEach(noteEl => { noteEl.classList.remove('playing'); });
              const verticalHighlight = sequencer.querySelector('.vertical-highlight');
              if(verticalHighlight) verticalHighlight.style.left = '-100px'; // Move highlight offscreen
            playPauseBtn.textContent = 'Play';
            isPlaying = false;
            logActivity('Sequencer Stopped');
            consoleLog('Playback stopped.');
        }


        // --- Initialization ---
        createSequencer(); // Create grid, sets initial visuals based on activePattern='A'
        playPauseBtn.addEventListener('click', togglePlayPause);
        togglePatternBtn.addEventListener('click', togglePattern); // Add listener for pattern toggle

        // Initial interaction handler
        const initInteractionHandler = () => { initAudioContext(); consoleLog('Initial user interaction detected.'); };
        document.body.addEventListener('click', initInteractionHandler, { once: true });
        document.body.addEventListener('touchstart', initInteractionHandler, { once: true });

        consoleLog('Dual Pattern Sequencer initialized.');
        logActivity('App loaded. Interact (tap/click) then Press Play.');

    </script>
</body>
</html>
