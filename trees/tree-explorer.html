<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bristol Trees Explorer</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.Default.css" />
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            background: #f5f5f5;
        }
        
        .header {
            background: #2c5530;
            color: white;
            padding: 1rem;
            text-align: center;
        }
        
        .container {
            display: flex;
            height: calc(100vh - 100px);
        }
        
        .sidebar {
            width: 400px;
            background: white;
            border-right: 1px solid #ddd;
            overflow-y: auto;
            padding: 1rem;
        }
        
        .map-container {
            flex: 1;
            position: relative;
        }
        
        #map {
            width: 100%;
            height: 100%;
        }
        
        .query-section {
            margin-bottom: 1.5rem;
            padding: 1rem;
            border: 1px solid #ddd;
            border-radius: 8px;
            background: #fafafa;
        }
        
        .query-section h3 {
            margin: 0 0 1rem 0;
            color: #2c5530;
        }
        
        select, input, textarea, button {
            width: 100%;
            padding: 0.5rem;
            margin: 0.25rem 0;
            border: 1px solid #ccc;
            border-radius: 4px;
            box-sizing: border-box;
        }
        
        button {
            background: #2c5530;
            color: white;
            cursor: pointer;
            border: none;
        }
        
        button:hover {
            background: #1a3d1f;
        }
        
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        
        .results {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #ddd;
            padding: 0.5rem;
            background: white;
            font-family: monospace;
            font-size: 0.8em;
        }
        
        .loading {
            text-align: center;
            padding: 2rem;
            color: #666;
        }
        
        .stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.5rem;
            margin: 1rem 0;
        }
        
        .stat-box {
            background: white;
            padding: 1rem;
            border-radius: 4px;
            text-align: center;
            border: 1px solid #ddd;
        }
        
        .stat-number {
            font-size: 1.5em;
            font-weight: bold;
            color: #2c5530;
        }
        
        .progress {
            width: 100%;
            height: 20px;
            background: #f0f0f0;
            border-radius: 10px;
            overflow: hidden;
            margin: 1rem 0;
        }
        
        .progress-bar {
            height: 100%;
            background: #2c5530;
            transition: width 0.3s ease;
        }
        
        .tree-emoji-icon {
            background: none !important;
            border: none !important;
            font-size: 16px;
            text-align: center;
            line-height: 20px;
            cursor: pointer;
            transition: transform 0.2s ease;
        }
        
        .tree-emoji-icon:hover {
            transform: scale(1.2);
            filter: drop-shadow(0 0 5px rgba(255, 165, 0, 0.8));
        }
        
        .eaten-tree {
            opacity: 0.3;
            filter: grayscale(100%);
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üêâ MUSK THE DRAGON: Bristol Tree Quest</h1>
        <p>Help MUSK eat all the trees in Bristol to survive! Educational tree-eating adventure</p>
        <div id="gameStats" style="display: flex; justify-content: center; gap: 2rem; margin-top: 0.5rem;">
            <div>‚ù§Ô∏è Health: <span id="health">100</span></div>
            <div>üçÉ Trees Eaten: <span id="score">0</span></div>
            <div>‚è±Ô∏è Time: <span id="timer">0</span>s</div>
            <div>üå≥ Trees Remaining: <span id="remaining">0</span></div>
        </div>
    </div>
    
    <div class="container">
        <div class="sidebar">
            <div id="loading" class="loading">
                <p>Loading tree database...</p>
                <div class="progress">
                    <div class="progress-bar" id="progressBar" style="width: 0%"></div>
                </div>
                <p id="loadingStatus">Initializing...</p>
            </div>
            
            <div id="controls" style="display: none;">
                <div class="query-section">
                    <h3>üêâ MUSK's Status</h3>
                    <div style="background: #f0f8ff; padding: 1rem; border-radius: 8px; margin: 1rem 0;">
                        <div style="font-size: 2em; text-align: center; margin-bottom: 0.5rem;">üêâ</div>
                        <div id="dragonStatus">MUSK is hungry and needs trees!</div>
                        <div style="margin-top: 0.5rem;">
                            <div style="background: #ddd; height: 10px; border-radius: 5px;">
                                <div id="healthBar" style="background: #ff4444; height: 100%; width: 100%; border-radius: 5px; transition: width 0.3s;"></div>
                            </div>
                        </div>
                    </div>
                    <button onclick="startGame()" id="startBtn">üéÆ Start Game</button>
                    <button onclick="pauseGame()" id="pauseBtn" style="display: none;">‚è∏Ô∏è Pause</button>
                </div>
                
                <div class="stats">
                    <div class="stat-box">
                        <div class="stat-number" id="totalTrees">0</div>
                        <div>Total Trees</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-number" id="uniqueSpecies">0</div>
                        <div>Species</div>
                    </div>
                </div>
                
                <div class="query-section">
                    <h3>üå≥ Tree Learning</h3>
                    <div id="treeInfo" style="background: #f9f9f9; padding: 1rem; border-radius: 8px; min-height: 100px;">
                        <div style="text-align: center; color: #888;">Click on trees to learn about them!</div>
                    </div>
                </div>
                
                <div class="query-section">
                    <h3>üêâ Dragon Controls</h3>
                    <p style="font-size: 0.9em; margin: 0.5rem 0;">
                        üñ±Ô∏è Click on üå≥ trees to eat them<br>
                        üîç Zoom in to find individual trees<br>
                        ‚ù§Ô∏è Health decreases over time<br>
                        üçÉ Eating trees restores health
                    </p>
                    <button onclick="showTreesInView()" id="showTreesBtn">üîç Find Trees Here</button>
                    <button onclick="clearIndividualTrees()">üßπ Clear Area</button>
                    <p id="viewportInfo" style="font-size: 0.8em; color: #666; margin: 0.5rem 0;">Zoom in to find trees automatically</p>
                </div>
                
                <div class="query-section">
                    <h3>Custom SQL Query</h3>
                    <textarea id="customQuery" rows="4" placeholder="Examples:
SELECT x, y, common_name, site_name FROM trees WHERE common_name = 'Oak' LIMIT 50
SELECT common_name, COUNT(*) as count FROM trees GROUP BY common_name ORDER BY count DESC LIMIT 10
SELECT * FROM trees WHERE site_name LIKE '%Park%' AND x IS NOT NULL LIMIT 20"></textarea>
                    <button onclick="runCustomQuery()">Run Query & Show on Map</button>
                    <button onclick="runQueryTextOnly()">Run Query (Text Only)</button>
                </div>
                
                <div class="query-section">
                    <h3>Query Results</h3>
                    <div class="results" id="queryResults">No query executed yet</div>
                </div>
            </div>
        </div>
        
        <div class="map-container">
            <div id="map"></div>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet.markercluster@1.4.1/dist/leaflet.markercluster.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/sql.js@1.8.0/dist/sql-wasm.js"></script>
    <script>
        let db;
        let map;
        let markers = [];
        let currentData = [];
        let clusterGroup;
        let individualMarkers = [];
        let debounceTimer;
        let isLoadingTrees = false;
        
        // Game variables
        let gameState = {
            isPlaying: false,
            health: 100,
            score: 0,
            startTime: 0,
            totalTrees: 0,
            eatenTrees: new Set(),
            gameTimer: null,
            healthDecayTimer: null
        };
        
        // Initialize the application
        async function init() {
            updateProgress(10, "Loading SQLite...");
            await initSQLite();
            
            updateProgress(20, "Loading CSV data...");
            await loadCSVData();
            
            updateProgress(80, "Setting up map...");
            initMap();
            
            updateProgress(90, "Finalizing...");
            await populateFilters();
            
            updateProgress(100, "Complete!");
            document.getElementById('loading').style.display = 'none';
            document.getElementById('controls').style.display = 'block';
            
            // Load initial data
            loadAllTrees();
        }
        
        function updateProgress(percent, status) {
            document.getElementById('progressBar').style.width = percent + '%';
            document.getElementById('loadingStatus').textContent = status;
        }
        
        async function initSQLite() {
            const sqlPromise = initSqlJs({
                locateFile: file => `https://cdn.jsdelivr.net/npm/sql.js@1.8.0/dist/${file}`
            });
            const SQL = await sqlPromise;
            db = new SQL.Database();
        }
        
        async function loadCSVData() {
            try {
                updateProgress(30, "Fetching CSV file...");
                const response = await fetch('Trees.csv');
                const csvText = await response.text();
                
                updateProgress(40, "Parsing CSV...");
                const lines = csvText.split('\n');
                const headers = lines[0].split(',').map(h => h.replace(/"/g, '').trim());
                
                updateProgress(50, "Creating database table...");
                // Create table with proper column names
                const createTableSQL = `
                    CREATE TABLE trees (
                        objectid INTEGER,
                        asset_id TEXT,
                        site_name TEXT,
                        plot_no TEXT,
                        feature_id TEXT,
                        location TEXT,
                        type TEXT,
                        prim_meas TEXT,
                        unit TEXT,
                        site_code TEXT,
                        feat_gp TEXT,
                        x REAL,
                        y REAL,
                        dead TEXT,
                        classification TEXT,
                        extent_easting_1 REAL,
                        extent_northing_1 REAL,
                        extent_easting_2 REAL,
                        extent_northing_2 REAL,
                        layers TEXT,
                        latin_code TEXT,
                        latin_name TEXT,
                        feature_type_name TEXT,
                        common_name TEXT,
                        full_common_name TEXT,
                        crown_height TEXT,
                        crown_width TEXT,
                        crown_area TEXT,
                        dbh TEXT,
                        location_risk_zone TEXT,
                        epicormic TEXT,
                        insurance_claim_history TEXT,
                        central_asset_id TEXT,
                        contract_area_name TEXT,
                        customer TEXT,
                        dead_flag TEXT,
                        feature_group TEXT,
                        feature_group_code TEXT,
                        featuretypecode TEXT,
                        notes TEXT,
                        revision_no TEXT,
                        tree_species TEXT,
                        tree_modified_risk TEXT,
                        canopy_size_at_maturity TEXT,
                        sponsorship TEXT,
                        sponsorship_package TEXT,
                        planting_season TEXT,
                        planting_funder TEXT,
                        planting_notes TEXT,
                        species_notes TEXT,
                        tree_type TEXT,
                        jobs_required TEXT,
                        services_visibility TEXT,
                        constraints TEXT,
                        cancellation_reason TEXT,
                        notes_for_status TEXT,
                        cancellation_notes TEXT
                    )
                `;
                db.run(createTableSQL);
                
                updateProgress(60, "Inserting tree data...");
                // Insert data in batches
                const batchSize = 1000;
                let inserted = 0;
                
                for (let i = 1; i < lines.length; i += batchSize) {
                    const batch = lines.slice(i, i + batchSize);
                    const values = [];
                    
                    for (const line of batch) {
                        if (line.trim()) {
                            const row = parseCSVLine(line);
                            if (row.length >= headers.length) {
                                values.push('(' + row.map(val => `'${val.replace(/'/g, "''")}'`).join(',') + ')');
                            }
                        }
                    }
                    
                    if (values.length > 0) {
                        const insertSQL = `INSERT INTO trees VALUES ${values.join(',')}`;
                        try {
                            db.run(insertSQL);
                            inserted += values.length;
                            updateProgress(60 + (i / lines.length) * 20, `Inserted ${inserted} trees...`);
                        } catch (e) {
                            console.warn('Batch insert error:', e);
                        }
                    }
                }
                
                console.log(`Loaded ${inserted} trees into database`);
                
            } catch (error) {
                console.error('Error loading CSV:', error);
                updateProgress(0, "Error loading data");
            }
        }
        
        function parseCSVLine(line) {
            const result = [];
            let current = '';
            let inQuotes = false;
            
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                if (char === '"') {
                    inQuotes = !inQuotes;
                } else if (char === ',' && !inQuotes) {
                    result.push(current.trim());
                    current = '';
                } else {
                    current += char;
                }
            }
            result.push(current.trim());
            return result;
        }
        
        function initMap() {
            // Bristol coordinates
            map = L.map('map').setView([51.4545, -2.5879], 11);
            
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '¬© OpenStreetMap contributors'
            }).addTo(map);
            
            // Initialize cluster group
            clusterGroup = L.markerClusterGroup({
                chunkedLoading: true,
                chunkInterval: 500,
                chunkDelay: 50
            });
            map.addLayer(clusterGroup);
            
            // Add map event listeners for viewport-based loading
            map.on('moveend zoomend', debounceViewportLoad);
        }
        
        async function populateFilters() {
            // Update stats only (removed filter dropdowns for game)
            const totalResult = db.exec("SELECT COUNT(*) FROM trees");
            const speciesCountResult = db.exec("SELECT COUNT(DISTINCT common_name) FROM trees WHERE common_name != ''");
            
            document.getElementById('totalTrees').textContent = totalResult[0].values[0][0];
            document.getElementById('uniqueSpecies').textContent = speciesCountResult[0].values[0][0];
        }
        
        function loadAllTrees() {
            // Load ALL trees into clusters (no limit)
            const result = db.exec("SELECT x, y, common_name, site_name, latin_name FROM trees WHERE x IS NOT NULL AND y IS NOT NULL AND x != '' AND y != ''");
            loadTreesIntoClusters(result);
        }
        
        function loadTreesIntoClusters(result) {
            if (result.length === 0) return;
            
            const data = result[0];
            const columns = data.columns;
            const xIndex = columns.indexOf('x');
            const yIndex = columns.indexOf('y');
            const nameIndex = columns.indexOf('common_name');
            const siteIndex = columns.indexOf('site_name');
            
            if (xIndex < 0 || yIndex < 0) return;
            
            updateProgress(85, `Adding ${data.values.length} trees to clusters...`);
            
            // Clear existing clusters
            clusterGroup.clearLayers();
            
            // Add all trees to cluster group
            let added = 0;
            data.values.forEach((row, index) => {
                const x = parseFloat(row[xIndex]);
                const y = parseFloat(row[yIndex]);
                
                if (!isNaN(x) && !isNaN(y)) {
                    const latLng = convertBNGToLatLng(x, y);
                    
                    if (latLng) {
                        // Create small cluster markers (no emoji for performance)
                        const marker = L.marker(latLng);
                        const name = row[nameIndex] || 'Unknown species';
                        const site = row[siteIndex] || 'Unknown location';
                        marker.bindPopup(`<strong>üå≥ ${name}</strong><br>üìç ${site}`);
                        clusterGroup.addLayer(marker);
                        added++;
                    }
                }
                
                // Update progress occasionally
                if (index % 1000 === 0) {
                    updateProgress(85 + (index / data.values.length) * 10, `Added ${added} trees...`);
                }
            });
            
            console.log(`Added ${added} trees to clusters`);
            gameState.totalTrees = added;
            document.getElementById('remaining').textContent = added;
            document.getElementById('queryResults').textContent = `Loaded ${added} trees into clusters. Start the game to begin MUSK's adventure!`;
        }
        
        // Filter functions removed for game mode
        
        function runCustomQuery() {
            const query = document.getElementById('customQuery').value;
            if (!query.trim()) return;
            
            try {
                const result = db.exec(query);
                
                // Always try to show on map first if coordinates exist
                if (result.length > 0) {
                    const columns = result[0].columns;
                    const xIndex = columns.indexOf('x');
                    const yIndex = columns.indexOf('y');
                    
                    if (xIndex >= 0 && yIndex >= 0) {
                        displayTreesOnMap(result);
                    } else {
                        // If no coordinates, just show text results
                        displayQueryResults(result);
                    }
                } else {
                    document.getElementById('queryResults').textContent = 'Query executed successfully - no results returned';
                }
            } catch (error) {
                document.getElementById('queryResults').textContent = 'SQL Error: ' + error.message;
            }
        }
        
        function runQueryTextOnly() {
            const query = document.getElementById('customQuery').value;
            if (!query.trim()) return;
            
            try {
                const result = db.exec(query);
                displayQueryResults(result);
            } catch (error) {
                document.getElementById('queryResults').textContent = 'SQL Error: ' + error.message;
            }
        }
        
        function debounceViewportLoad() {
            if (debounceTimer) {
                clearTimeout(debounceTimer);
            }
            
            // Only auto-load if zoomed in enough (zoom level 14+)
            if (map.getZoom() >= 14) {
                debounceTimer = setTimeout(() => {
                    showTreesInView();
                }, 2000); // 2 second delay after stopping movement
                
                document.getElementById('viewportInfo').textContent = 'Loading trees in 2 seconds...';
            } else {
                document.getElementById('viewportInfo').textContent = 'Zoom in closer to auto-load individual trees';
            }
        }
        
        function showTreesInView() {
            if (isLoadingTrees) return;
            
            const bounds = map.getBounds();
            const bneBounds = convertLatLngBoundsToBNG(bounds);
            
            if (!bneBounds) {
                document.getElementById('queryResults').textContent = 'Unable to determine map bounds for tree loading';
                return;
            }
            
            isLoadingTrees = true;
            document.getElementById('showTreesBtn').disabled = true;
            document.getElementById('showTreesBtn').textContent = 'Loading...';
            
            const query = `
                SELECT x, y, common_name, site_name, latin_name 
                FROM trees 
                WHERE x IS NOT NULL AND y IS NOT NULL 
                AND x != '' AND y != '' 
                AND x BETWEEN ${bneBounds.west} AND ${bneBounds.east}
                AND y BETWEEN ${bneBounds.south} AND ${bneBounds.north}
                LIMIT 500
            `;
            
            try {
                const result = db.exec(query);
                displayIndividualTrees(result);
                
                const count = result.length > 0 ? result[0].values.length : 0;
                document.getElementById('viewportInfo').textContent = `Loaded ${count} individual trees in current view`;
                
            } catch (error) {
                document.getElementById('queryResults').textContent = 'Error loading trees: ' + error.message;
            } finally {
                isLoadingTrees = false;
                document.getElementById('showTreesBtn').disabled = false;
                document.getElementById('showTreesBtn').textContent = 'Show Trees in Current View';
            }
        }
        
        function convertLatLngBoundsToBNG(bounds) {
            const bristolLatLng = { lat: 51.4545, lng: -2.5879 };
            const bristolBNG = { x: 359000, y: 173000 };
            
            // Convert corners to BNG (approximate)
            const scaleX = 69000; // roughly 1 degree = 69km at this latitude  
            const scaleY = 111000; // roughly 1 degree = 111km
            
            const west = bristolBNG.x + (bounds.getWest() - bristolLatLng.lng) * scaleX;
            const east = bristolBNG.x + (bounds.getEast() - bristolLatLng.lng) * scaleX;
            const south = bristolBNG.y + (bounds.getSouth() - bristolLatLng.lat) * scaleY;
            const north = bristolBNG.y + (bounds.getNorth() - bristolLatLng.lat) * scaleY;
            
            return { west, east, south, north };
        }
        
        function displayIndividualTrees(result) {
            // Clear existing individual markers
            clearIndividualTrees();
            
            if (result.length === 0) {
                document.getElementById('queryResults').textContent = 'No trees found in current view';
                return;
            }
            
            const data = result[0];
            const columns = data.columns;
            const xIndex = columns.indexOf('x');
            const yIndex = columns.indexOf('y');
            const nameIndex = columns.indexOf('common_name');
            const siteIndex = columns.indexOf('site_name');
            
            if (xIndex < 0 || yIndex < 0) {
                document.getElementById('queryResults').textContent = 'No coordinate data found';
                return;
            }
            
            let plotted = 0;
            
            data.values.forEach(row => {
                const x = parseFloat(row[xIndex]);
                const y = parseFloat(row[yIndex]);
                
                if (!isNaN(x) && !isNaN(y)) {
                    const latLng = convertBNGToLatLng(x, y);
                    
                    if (latLng) {
                        // Create tree emoji markers for individual trees
                        const treeIcon = L.divIcon({
                            html: 'üå≥',
                            iconSize: [20, 20],
                            className: 'tree-emoji-icon'
                        });
                        
                        const marker = L.marker(latLng, { icon: treeIcon }).addTo(map);
                        const name = row[nameIndex] || 'Unknown species';
                        const site = row[siteIndex] || 'Unknown location';
                        const latin = row[4] || 'Species unknown'; // latin_name column
                        const coords = `(${x.toFixed(0)}, ${y.toFixed(0)})`;
                        
                        const treeData = {
                            x: x,
                            y: y,
                            name: name,
                            site: site,
                            latin: latin
                        };
                        
                        // Add click handler for eating trees
                        marker.on('click', () => {
                            eatTree(marker, treeData);
                        });
                        
                        marker.bindPopup(`
                            <strong>üå≥ ${name}</strong><br>
                            <em>${latin}</em><br>
                            üìç ${site}<br>
                            <small>BNG: ${coords}</small><br>
                            ${gameState.isPlaying ? '<br><button onclick="eatTree(marker, treeData)">üêâ MUSK EAT TREE</button>' : ''}
                        `);
                        individualMarkers.push(marker);
                        plotted++;
                    }
                }
            });
            
            document.getElementById('queryResults').textContent = `Showing ${plotted} individual trees (üå≥) in current view`;
        }
        
        function clearIndividualTrees() {
            individualMarkers.forEach(marker => map.removeLayer(marker));
            individualMarkers = [];
            document.getElementById('viewportInfo').textContent = 'Individual trees cleared';
        }
        
        function displayTreesOnMap(result) {
            // This function now redirects to displayIndividualTrees for consistency
            displayIndividualTrees(result);
            
            // Fit map to markers if we have any
            if (individualMarkers.length > 0) {
                const group = new L.featureGroup(individualMarkers);
                map.fitBounds(group.getBounds().pad(0.1));
            }
        }
        
        function convertBNGToLatLng(easting, northing) {
            // More accurate conversion for Bristol area using empirical adjustment
            // Bristol city center is approximately at BNG: 359000, 173000
            const bristolBNG = { x: 359000, y: 173000 };
            const bristolLatLng = { lat: 51.4545, lng: -2.5879 };
            
            // Calculate offset from Bristol center
            const deltaX = easting - bristolBNG.x;
            const deltaY = northing - bristolBNG.y;
            
            // Convert to degrees (approximate scale factors for Bristol area)
            const scaleX = 1 / 69000; // roughly 1 degree = 69km at this latitude
            const scaleY = 1 / 111000; // roughly 1 degree = 111km
            
            const lat = bristolLatLng.lat + (deltaY * scaleY);
            const lng = bristolLatLng.lng + (deltaX * scaleX);
            
            // Bounds check for greater Bristol area
            if (lat > 51.2 && lat < 51.7 && lng > -3.0 && lng < -2.2) {
                return [lat, lng];
            }
            return null;
        }
        
        function displayQueryResults(result) {
            const resultsDiv = document.getElementById('queryResults');
            
            if (result.length === 0) {
                resultsDiv.textContent = 'No results found';
                return;
            }
            
            const data = result[0];
            let output = `Found ${data.values.length} rows\n\n`;
            output += data.columns.join(' | ') + '\n';
            output += '-'.repeat(data.columns.join(' | ').length) + '\n';
            
            data.values.slice(0, 20).forEach(row => {
                output += row.join(' | ') + '\n';
            });
            
            if (data.values.length > 20) {
                output += `\n... and ${data.values.length - 20} more rows`;
            }
            
            resultsDiv.textContent = output;
        }
        
        // Game functions
        function startGame() {
            gameState.isPlaying = true;
            gameState.health = 100;
            gameState.score = 0;
            gameState.startTime = Date.now();
            gameState.eatenTrees.clear();
            
            updateGameUI();
            
            document.getElementById('startBtn').style.display = 'none';
            document.getElementById('pauseBtn').style.display = 'inline-block';
            document.getElementById('dragonStatus').textContent = 'MUSK is on the hunt for trees! üêâ';
            
            // Start game timers
            startGameTimers();
        }
        
        function pauseGame() {
            gameState.isPlaying = false;
            clearInterval(gameState.gameTimer);
            clearInterval(gameState.healthDecayTimer);
            
            document.getElementById('startBtn').style.display = 'inline-block';
            document.getElementById('startBtn').textContent = '‚ñ∂Ô∏è Resume Game';
            document.getElementById('pauseBtn').style.display = 'none';
            document.getElementById('dragonStatus').textContent = 'Game paused. MUSK is resting...';
        }
        
        function startGameTimers() {
            // Game timer (updates every second)
            gameState.gameTimer = setInterval(() => {
                if (gameState.isPlaying) {
                    const elapsed = Math.floor((Date.now() - gameState.startTime) / 1000);
                    document.getElementById('timer').textContent = elapsed;
                }
            }, 1000);
            
            // Health decay timer (loses health over time)
            gameState.healthDecayTimer = setInterval(() => {
                if (gameState.isPlaying && gameState.health > 0) {
                    gameState.health = Math.max(0, gameState.health - 0.5);
                    updateGameUI();
                    
                    if (gameState.health <= 0) {
                        gameOver();
                    } else if (gameState.health <= 20) {
                        document.getElementById('dragonStatus').textContent = 'MUSK is starving! Find trees quickly! üö®';
                    } else if (gameState.health <= 50) {
                        document.getElementById('dragonStatus').textContent = 'MUSK is getting hungry... üò∞';
                    }
                }
            }, 1000);
        }
        
        function eatTree(marker, treeData) {
            if (!gameState.isPlaying) return;
            
            const treeId = `${treeData.x}_${treeData.y}`;
            if (gameState.eatenTrees.has(treeId)) return;
            
            // Remove tree from map
            map.removeLayer(marker);
            individualMarkers = individualMarkers.filter(m => m !== marker);
            
            // Update game state
            gameState.eatenTrees.add(treeId);
            gameState.score++;
            gameState.health = Math.min(100, gameState.health + 15); // Restore health
            
            // Educational content
            showTreeInfo(treeData);
            
            // Update UI
            updateGameUI();
            
            // Check win condition
            if (gameState.score >= gameState.totalTrees) {
                winGame();
            } else {
                document.getElementById('dragonStatus').textContent = `MUSK devoured a ${treeData.name}! Delicious! üòã`;
            }
        }
        
        function showTreeInfo(treeData) {
            const commonName = treeData.name || 'Unknown tree';
            const latinName = treeData.latin || 'Species unknown';
            const location = treeData.site || 'Location unknown';
            
            const info = `
                <h4>üå≥ ${commonName}</h4>
                <p><em>${latinName}</em></p>
                <p>üìç ${location}</p>
                <p>üêâ MUSK gained 15 health from eating this ${commonName.toLowerCase()}!</p>
                <small>Trees provide oxygen, reduce pollution, and support wildlife habitats.</small>
            `;
            
            document.getElementById('treeInfo').innerHTML = info;
        }
        
        function updateGameUI() {
            document.getElementById('health').textContent = Math.round(gameState.health);
            document.getElementById('score').textContent = gameState.score;
            document.getElementById('remaining').textContent = gameState.totalTrees - gameState.score;
            
            // Update health bar
            const healthPercent = (gameState.health / 100) * 100;
            document.getElementById('healthBar').style.width = healthPercent + '%';
            
            // Change health bar color based on health level
            const healthBar = document.getElementById('healthBar');
            if (gameState.health > 70) {
                healthBar.style.background = '#44ff44';
            } else if (gameState.health > 30) {
                healthBar.style.background = '#ffaa00';
            } else {
                healthBar.style.background = '#ff4444';
            }
        }
        
        function gameOver() {
            gameState.isPlaying = false;
            clearInterval(gameState.gameTimer);
            clearInterval(gameState.healthDecayTimer);
            
            const elapsed = Math.floor((Date.now() - gameState.startTime) / 1000);
            document.getElementById('dragonStatus').innerHTML = `
                üíÄ MUSK starved to death!<br>
                üçÉ Trees eaten: ${gameState.score}<br>
                ‚è±Ô∏è Survived: ${elapsed}s<br>
                <button onclick="startGame()" style="margin-top: 0.5rem;">üîÑ Try Again</button>
            `;
            
            document.getElementById('startBtn').style.display = 'inline-block';
            document.getElementById('startBtn').textContent = 'üéÆ New Game';
            document.getElementById('pauseBtn').style.display = 'none';
        }
        
        function winGame() {
            gameState.isPlaying = false;
            clearInterval(gameState.gameTimer);
            clearInterval(gameState.healthDecayTimer);
            
            const elapsed = Math.floor((Date.now() - gameState.startTime) / 1000);
            document.getElementById('dragonStatus').innerHTML = `
                üéâ MUSK ATE ALL THE TREES!<br>
                üêâ Bristol is now treeless!<br>
                ‚è±Ô∏è Time: ${elapsed}s<br>
                <small>In reality, trees are vital for our ecosystem!</small><br>
                <button onclick="startGame()" style="margin-top: 0.5rem;">üéÆ Play Again</button>
            `;
            
            document.getElementById('startBtn').style.display = 'inline-block';
            document.getElementById('startBtn').textContent = 'üéÆ New Game';
            document.getElementById('pauseBtn').style.display = 'none';
        }
        
        // Initialize the app when page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>