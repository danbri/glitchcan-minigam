<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Retro Platform Adventure - Expanded</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    /* ======== Base / Reset ======== */
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { width: 100%; height: 100%; overflow: hidden; background: #111; font-family: sans-serif; }
    #gameContainer { position: relative; width: 100vw; height: 100vh; overflow: hidden; }

    /* ======== UI Header & Narrative ======== */
    #uiHeader {
      position: absolute;
      top: 0; left: 0; right: 0;
      background: rgba(0, 0, 0, 0.7);
      color: #fff;
      padding: 8px 12px;
      z-index: 100;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    #narrativePanel {
      position: absolute;
      bottom: 0; left: 0; right: 0;
      background: rgba(0, 0, 0, 0.85);
      color: #fff;
      padding: 12px;
      z-index: 100;
      display: none;
    }
    #narrativeText { margin-bottom: 8px; }
    .choiceBtn {
      background: #444;
      color: #fff;
      border: none;
      padding: 6px 12px;
      margin-right: 6px;
      cursor: pointer;
      border-radius: 4px;
    }
    .choiceBtn:hover { background: #666; }

    /* ======== Overlays (Start / Victory / Game Over) ======== */
    .overlay {
      position: absolute;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.95);
      color: #fff;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 200;
      text-align: center;
      padding: 20px;
    }
    .overlay button {
      background: #0088cc;
      color: #fff;
      border: none;
      padding: 10px 20px;
      margin-top: 20px;
      font-size: 18px;
      border-radius: 4px;
      cursor: pointer;
    }
    .overlay button:hover { background: #00aaff; }

    /* ======== Game Elements ======== */
    .platform {
      position: absolute;
      background: #5a3e1b;
    }
    .platform.elevator { background: #7a7a7a; }
    .platform.escalator { background: #3e7a5a; }

    .interactive {
      position: absolute;
      font-size: 32px;
      cursor: pointer;
    }
    .decoration {
      position: absolute;
      font-size: 24px;
    }
    .enemy {
      position: absolute;
      font-size: 32px;
    }
    .collectible {
      position: absolute;
      font-size: 24px;
      transition: transform 0.4s ease;
    }
    .player {
      position: absolute;
      font-size: 32px;
      z-index: 50;
      transition: transform 0.1s linear;
    }
    .boss {
      font-size: 48px; /* Larger for a "boss" enemy */
    }

    /* ======== Mobile Controls ======== */
    #mobileControls {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: none;
      gap: 10px;
      z-index: 150;
    }
    #mobileControls button {
      width: 50px; height: 50px;
      font-size: 24px;
      border: none; border-radius: 50%;
      background: rgba(255, 255, 255, 0.2);
      color: #fff;
    }
  </style>
</head>
<body>
  <div id="gameContainer">
    <!-- UI Header -->
    <div id="uiHeader">
      <div id="scoreDisplay">Score: 0</div>
      <div id="livesDisplay">Lives: 3</div>
      <div id="roomDisplay">Room: (0, 0)</div>
    </div>
    
    <!-- Player -->
    <div id="player" class="player">ü§ñ</div>
    
    <!-- Narrative Panel -->
    <div id="narrativePanel">
      <div id="narrativeText"></div>
      <div id="choiceContainer"></div>
    </div>
    
    <!-- Overlay (start screen, replaced on victory or game over) -->
    <div id="overlay" class="overlay">
      <h1>Retro Platform Adventure - Expanded</h1>
      <p>Use arrow keys or on‚Äêscreen buttons to move/jump.<br>
         Press X or tap the action button to interact.</p>
      <button id="startGameBtn">Start Game</button>
    </div>
    
    <!-- Mobile Controls -->
    <div id="mobileControls">
      <button id="btnLeft">‚óÄ</button>
      <button id="btnJump">‚ñ≤</button>
      <button id="btnRight">‚ñ∂</button>
      <button id="btnAction">X</button>
    </div>
  </div>
  
  <script>
  (() => {
    // ==========================
    // Game State
    // ==========================
    const gameState = {
      score: 0,
      lives: 3,
      roomX: 0,
      roomY: 0,
      narrativeNode: 'start',
      running: false,
      time: 0,
      player: {
        x: 50,
        y: 300,
        vx: 0,
        vy: 0,
        width: 32,
        height: 32,
        onGround: false,
        onLadder: false
      },
      platforms: [],
      enemies: [],
      collectibles: [],
      interactiveObjects: [],
      input: {
        left: false,
        right: false,
        up: false,
        down: false,
        action: false
      }
    };

    // ==========================
    // Narrative Nodes
    // ==========================
    // Each node has text, commands to run immediately, and choices.
    // Commands supported: "AWARD_POINTS X", "GOTO_ROOM X,Y", "WIN_GAME"
    const narrativeNodes = {
      start: {
        text: "Welcome to the Retro Platform Adventure! Begin your quest.",
        commands: [],
        choices: [
          { text: "Let's go!", next: "explore" }
        ]
      },
      explore: {
        text: "You find yourself in a mysterious chamber. A door stands nearby.",
        commands: [],
        choices: [
          { text: "Open the door", next: "door" },
          { text: "Look around", next: "look" }
        ]
      },
      look: {
        text: "Strange symbols on the wall glow with energy. You touch them.",
        commands: ["AWARD_POINTS 50"],
        choices: [
          { text: "Continue", next: "door" }
        ]
      },
      door: {
        text: "The door leads to another chamber. You step through...",
        commands: ["GOTO_ROOM 1,0"],
        choices: [
          { text: "Ok", next: "explore2" }
        ]
      },
      // "Level 2" or second area
      explore2: {
        text: "This new area is slightly more challenging. Another door stands ahead.",
        commands: [],
        choices: [
          { text: "Proceed deeper...", next: "door2" }
        ]
      },
      door2: {
        text: "You sense a powerful presence beyond the door...",
        commands: ["GOTO_ROOM 2,0"],
        choices: [
          { text: "Go", next: "bossIntro" }
        ]
      },
      bossIntro: {
        text: "A huge glitchy monster (üëæ) looms before you. Prepare for a fight!",
        commands: [],
        choices: [
          { text: "Fight the boss", next: "bossFight" }
        ]
      },
      // The boss fight node just transitions you to the boss room. 
      bossFight: {
        text: "Defeat the boss to claim victory.",
        commands: ["GOTO_ROOM 2,1"],
        choices: []
      },
      bossVictory: {
        text: "You have vanquished the glitch monster!",
        commands: ["AWARD_POINTS 500", "WIN_GAME"],
        choices: []
      }
    };

    // ==========================
    // DOM Elements
    // ==========================
    const gameContainer = document.getElementById('gameContainer');
    const playerEl = document.getElementById('player');
    const scoreDisplay = document.getElementById('scoreDisplay');
    const livesDisplay = document.getElementById('livesDisplay');
    const roomDisplay = document.getElementById('roomDisplay');
    const narrativePanel = document.getElementById('narrativePanel');
    const narrativeText = document.getElementById('narrativeText');
    const choiceContainer = document.getElementById('choiceContainer');
    const overlay = document.getElementById('overlay');
    const startGameBtn = document.getElementById('startGameBtn');
    const mobileControls = document.getElementById('mobileControls');
    const btnLeft = document.getElementById('btnLeft');
    const btnRight = document.getElementById('btnRight');
    const btnJump = document.getElementById('btnJump');
    const btnAction = document.getElementById('btnAction');

    // ==========================
    // UI Functions
    // ==========================
    function updateUI() {
      scoreDisplay.textContent = "Score: " + gameState.score;
      livesDisplay.textContent = "Lives: " + gameState.lives;
      roomDisplay.textContent = `Room: (${gameState.roomX}, ${gameState.roomY})`;
    }

    // Show narrative node
    function updateNarrative(nodeKey) {
      const node = narrativeNodes[nodeKey];
      if (!node) return;
      gameState.narrativeNode = nodeKey;
      
      // Display text
      narrativeText.textContent = node.text;
      
      // Run immediate commands
      node.commands.forEach(cmd => {
        const parts = cmd.split(" ");
        if (parts[0] === "AWARD_POINTS") {
          const pts = parseInt(parts[1]);
          gameState.score += pts;
          updateUI();
        } else if (parts[0] === "GOTO_ROOM") {
          const coords = parts[1].split(",");
          transitionRoom(parseInt(coords[0]), parseInt(coords[1]));
        } else if (parts[0] === "WIN_GAME") {
          winGame();
        }
      });

      // Build choices
      choiceContainer.innerHTML = "";
      node.choices.forEach(choice => {
        const btn = document.createElement('button');
        btn.classList.add('choiceBtn');
        btn.textContent = choice.text;
        btn.addEventListener('click', () => {
          narrativePanel.style.display = 'none';
          updateNarrative(choice.next);
        });
        choiceContainer.appendChild(btn);
      });

      // Show the panel if there are choices or text
      narrativePanel.style.display = (node.choices.length > 0 || node.text) ? 'block' : 'none';
    }

    // ==========================
    // Random Utilities
    // ==========================
    function seededRandom(seed) {
      let x = Math.sin(seed) * 10000;
      return x - Math.floor(x);
    }
    function randRange(seed, min, max) {
      return min + seededRandom(seed) * (max - min);
    }

    // ==========================
    // Room Generation
    // ==========================
    function generateRoom(roomX, roomY) {
      // Clear old elements
      document.querySelectorAll('.platform, .enemy, .collectible, .interactive, .decoration').forEach(el => el.remove());
      gameState.platforms = [];
      gameState.enemies = [];
      gameState.collectibles = [];
      gameState.interactiveObjects = [];

      const roomWidth = gameContainer.clientWidth;
      const roomHeight = gameContainer.clientHeight;

      // Background color
      let hue = (roomX * 45 + roomY * 70) % 360;
      gameContainer.style.background = `hsl(${hue}, 30%, 15%)`;

      // Ground platform
      const ground = document.createElement('div');
      ground.className = 'platform';
      ground.style.left = '0px';
      ground.style.top = (roomHeight - 40) + 'px';
      ground.style.width = roomWidth + 'px';
      ground.style.height = '40px';
      gameContainer.appendChild(ground);
      gameState.platforms.push({ x: 0, y: roomHeight - 40, width: roomWidth, height: 40, element: ground, type: "static" });

      // Add some variety of platforms
      for (let i = 0; i < 4; i++) {
        let seed = roomX * 100 + roomY * 10 + i;
        let w = randRange(seed, 80, 150);
        let h = 20;
        let x = randRange(seed + 1, 0, roomWidth - w);
        let y = randRange(seed + 2, 60, roomHeight - 120);
        let type = "static";
        if (i % 3 === 0) type = "elevator";
        if (i % 3 === 1) type = "escalator";

        const plat = document.createElement('div');
        plat.className = 'platform';
        if (type === "elevator") plat.classList.add("elevator");
        if (type === "escalator") plat.classList.add("escalator");
        plat.style.left = x + 'px';
        plat.style.top = y + 'px';
        plat.style.width = w + 'px';
        plat.style.height = h + 'px';
        gameContainer.appendChild(plat);

        gameState.platforms.push({
          x, y, width: w, height: h,
          element: plat,
          type,
          direction: 1,
          range: { min: y - 20, max: y + 20 }
        });
      }

      // Decorations
      const themes = ['jungle', 'library', 'default'];
      let themeIndex = Math.floor(randRange(roomX + roomY, 0, themes.length));
      let theme = themes[themeIndex];
      let decorationEmoji = (theme === 'jungle') ? 'üå¥' : (theme === 'library') ? 'üìö' : '‚ú®';
      for (let i = 0; i < 6; i++) {
        let seed = roomX * 200 + roomY * 20 + i;
        let dec = document.createElement('div');
        dec.className = 'decoration';
        dec.textContent = decorationEmoji;
        let size = 24;
        dec.style.fontSize = size + 'px';
        let dx = randRange(seed, 0, roomWidth - size);
        let dy = randRange(seed + 1, 0, roomHeight - size);
        dec.style.left = dx + 'px';
        dec.style.top = dy + 'px';
        gameContainer.appendChild(dec);
      }

      // If this is the "boss" room at (2,1), place a big ‚Äúboss‚Äù.
      if (roomX === 2 && roomY === 1) {
        let boss = document.createElement('div');
        boss.className = 'enemy boss';
        boss.textContent = 'üëæ'; 
        // Place it near the center
        let bx = roomWidth/2 - 48;
        let by = roomHeight - 40 - 80;
        boss.style.left = bx + 'px';
        boss.style.top = by + 'px';
        gameContainer.appendChild(boss);

        gameState.enemies.push({
          x: bx, y: by, width: 48, height: 48,
          vx: 1.0,
          bounds: { min: bx - 70, max: bx + 70 },
          element: boss,
          contactTimer: 0,
          isBoss: true
        });
      } else {
        // Normal enemy
        let enemy = document.createElement('div');
        enemy.className = 'enemy';
        enemy.textContent = 'üëæ';
        let ex = randRange(roomX + roomY, 100, roomWidth - 100);
        let ey = roomHeight - 40 - 32;
        enemy.style.left = ex + 'px';
        enemy.style.top = ey + 'px';
        gameContainer.appendChild(enemy);

        gameState.enemies.push({
          x: ex, y: ey, width: 32, height: 32,
          vx: 1.2,
          bounds: { min: ex - 50, max: ex + 50 },
          element: enemy,
          contactTimer: 0
        });
      }

      // Door on a random platform if not the boss room
      if (!(roomX === 2 && roomY === 1)) {
        const randomPlatform = gameState.platforms[Math.floor(Math.random() * gameState.platforms.length)];
        let door = document.createElement('div');
        door.className = 'interactive';
        door.textContent = 'üö™';
        door.style.left = (randomPlatform.x + randomPlatform.width/2 - 16) + 'px';
        door.style.top = (randomPlatform.y - 32) + 'px';
        door.addEventListener('click', () => {
          // For demonstration, let's open a node that transitions.
          updateNarrative('door2');
        });
        gameContainer.appendChild(door);

        gameState.interactiveObjects.push({
          x: randomPlatform.x + randomPlatform.width/2 - 16,
          y: randomPlatform.y - 32,
          width: 32,
          height: 32,
          type: 'door',
          destination: { x: roomX + 1, y: roomY },
          element: door
        });
      }

      // A collectible (üçé)
      let collectible = document.createElement('div');
      collectible.className = 'collectible';
      let cx = randRange(roomX + roomY, 50, roomWidth - 50);
      let cy = roomHeight - 40 - 32;
      collectible.textContent = 'üçé';
      collectible.style.left = cx + 'px';
      collectible.style.top = cy + 'px';
      gameContainer.appendChild(collectible);

      gameState.collectibles.push({
        x: cx, y: cy, width: 32, height: 32,
        collected: false,
        element: collectible,
        animation: 'pop'
      });
    }

    // ==========================
    // Room Transition
    // ==========================
    function transitionRoom(newX, newY) {
      // Fade the player out
      playerEl.style.transition = "opacity 0.5s";
      playerEl.style.opacity = 0.3;
      setTimeout(() => {
        gameState.roomX = newX;
        gameState.roomY = newY;
        updateUI();
        generateRoom(newX, newY);
        // Reset player position (simple approach)
        gameState.player.x = 50;
        gameState.player.y = 300;
        playerEl.style.left = gameState.player.x + "px";
        playerEl.style.top = gameState.player.y + "px";
        // Reset opacity
        playerEl.style.opacity = 1;
      }, 500);
    }

    // ==========================
    // Collision Detection
    // ==========================
    function isColliding(a, b) {
      return a.x < b.x + b.width &&
             a.x + a.width > b.x &&
             a.y < b.y + b.height &&
             a.y + a.height > b.y;
    }

    // ==========================
    // Main Game Loop
    // ==========================
    function gameLoop() {
      if (!gameState.running) return;
      gameState.time++;
      const player = gameState.player;

      // Movement
      if (gameState.input.left) player.vx -= 0.6;
      if (gameState.input.right) player.vx += 0.6;
      if (gameState.input.up && player.onGround) {
        player.vy = -11;
        player.onGround = false;
      }

      // Gravity
      if (!player.onLadder) player.vy += 0.6;
      // Friction
      player.vx *= 0.85;

      // Update player position
      player.x += player.vx;
      player.y += player.vy;

      // If player falls below screen
      if (player.y > gameContainer.clientHeight) {
        gameState.lives--;
        if (gameState.lives <= 0) {
          gameOver();
          return;
        } else {
          player.x = 50; player.y = 300;
          player.vx = 0; player.vy = 0;
        }
      }

      // Check platform collisions
      player.onGround = false;
      gameState.platforms.forEach(plat => {
        // Elevator movement
        if (plat.type === "elevator") {
          plat.y += 0.5 * plat.direction;
          if (plat.y < plat.range.min || plat.y > plat.range.max) {
            plat.direction *= -1;
          }
          plat.element.style.top = plat.y + "px";
        }
        // Collision (only if moving downward)
        if (player.vy >= 0 && isColliding(player, plat)) {
          player.y = plat.y - player.height;
          player.vy = 0;
          player.onGround = true;
          // Escalator can push horizontally
          if (plat.type === "escalator") {
            player.vx += 0.5 * plat.direction;
          }
        }
      });

      // Update player element
      playerEl.style.left = player.x + "px";
      playerEl.style.top = player.y + "px";

      // Enemies
      gameState.enemies.forEach(enemy => {
        enemy.x += enemy.vx;
        if (enemy.x < enemy.bounds.min || enemy.x > enemy.bounds.max) {
          enemy.vx *= -1;
        }
        enemy.element.style.left = enemy.x + "px";

        // Check collision with player
        if (isColliding(player, enemy)) {
          enemy.contactTimer++;
          // Boss gets "defeated" after more sustained contact?
          if (enemy.isBoss) {
            if (enemy.contactTimer > 60) {
              // Boss is defeated => bossVictory
              updateNarrative("bossVictory");
            }
          } else {
            // Normal enemy contact => drop collectible
            if (enemy.contactTimer > 30) {
              let drop = document.createElement('div');
              drop.className = 'collectible';
              drop.style.left = enemy.x + "px";
              drop.style.top = enemy.y + "px";
              drop.textContent = 'üí∞';
              gameContainer.appendChild(drop);
              gameState.collectibles.push({
                x: enemy.x, y: enemy.y, width: 32, height: 32,
                collected: false, element: drop, animation: 'burst'
              });
              enemy.contactTimer = 0;
            }
          }
        } else {
          enemy.contactTimer = 0;
        }
      });

      // Collectibles
      gameState.collectibles.forEach(coll => {
        if (!coll.collected && isColliding(player, coll)) {
          coll.collected = true;
          coll.element.style.transform = "scale(2)";
          gameState.score += 100;
          updateUI();
          setTimeout(() => {
            coll.element.remove();
          }, 400);
        }
      });

      requestAnimationFrame(gameLoop);
    }

    // ==========================
    // Game Over and Win
    // ==========================
    function gameOver() {
      gameState.running = false;
      overlay.innerHTML = "<h1>Game Over</h1><button id='restartBtn'>Restart</button>";
      overlay.style.display = "flex";
      document.getElementById('restartBtn').addEventListener('click', () => location.reload());
    }
    function winGame() {
      gameState.running = false;
      overlay.innerHTML = "<h1>Victory!</h1><p>You have defeated the final boss!</p><button id='restartBtn'>Play Again</button>";
      overlay.style.display = "flex";
      document.getElementById('restartBtn').addEventListener('click', () => location.reload());
    }

    // ==========================
    // Input Handling
    // ==========================
    window.addEventListener("keydown", (e) => {
      if (e.key === "ArrowLeft") gameState.input.left = true;
      if (e.key === "ArrowRight") gameState.input.right = true;
      if (e.key === "ArrowUp" || e.key === " ") gameState.input.up = true;
      if (e.key === "ArrowDown") gameState.input.down = true;
      if (e.key.toLowerCase() === "x") gameState.input.action = true;
    });
    window.addEventListener("keyup", (e) => {
      if (e.key === "ArrowLeft") gameState.input.left = false;
      if (e.key === "ArrowRight") gameState.input.right = false;
      if (e.key === "ArrowUp" || e.key === " ") gameState.input.up = false;
      if (e.key === "ArrowDown") gameState.input.down = false;
      if (e.key.toLowerCase() === "x") gameState.input.action = false;
    });

    // Mobile controls
    btnLeft.addEventListener("touchstart", () => gameState.input.left = true);
    btnLeft.addEventListener("touchend", () => gameState.input.left = false);
    btnRight.addEventListener("touchstart", () => gameState.input.right = true);
    btnRight.addEventListener("touchend", () => gameState.input.right = false);
    btnJump.addEventListener("touchstart", () => gameState.input.up = true);
    btnJump.addEventListener("touchend", () => gameState.input.up = false);
    btnAction.addEventListener("touchstart", () => gameState.input.action = true);
    btnAction.addEventListener("touchend", () => gameState.input.action = false);

    if ('ontouchstart' in window) {
      mobileControls.style.display = "flex";
    }

    // ==========================
    // Start Game
    // ==========================
    startGameBtn.addEventListener("click", () => {
      overlay.style.display = "none";
      gameState.running = true;
      updateUI();
      // Generate initial room and narrative
      generateRoom(gameState.roomX, gameState.roomY);
      updateNarrative("start");
      requestAnimationFrame(gameLoop);
    });
  })();
  </script>
</body>
</html>
